<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mambo</title>
  
  <subtitle>Today I Learned 🔥</subtitle>
  <link href="https://kdevkr.github.io/atom.xml" rel="self"/>
  
  <link href="https://kdevkr.github.io/"/>
  <updated>2023-12-02T14:52:11.015Z</updated>
  <id>https://kdevkr.github.io/</id>
  
  <author>
    <name>Mambo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>인텔리제이 SQL 코드 스타일</title>
    <link href="https://kdevkr.github.io/intellij-sql-code-style/"/>
    <id>https://kdevkr.github.io/intellij-sql-code-style/</id>
    <published>2023-12-02T05:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<p>인텔리제이 얼티메이트 버전에서는 데이터베이스 대한 기능을 내장하고 있고 <a href="https://www.jetbrains.com/help/idea/settings-code-style-sql.html">SQL 코드 서식</a>에 대한 포맷팅 기능도 제공해주고 있다. 하지만, 기본적인 SQL 코드 스타일에서는 키워드나 컬럼 유형에 대해서는 대문자로 변경해주지 않는데 개인적으로 키워드들은 대문자로 표현하는 것을 선호하는 편이므로 이에 대한 설정 방법을 공유하고자 한다.</p><h4 id="SQL-코드-스타일-설정하기"><a href="#SQL-코드-스타일-설정하기" class="headerlink" title="SQL 코드 스타일 설정하기"></a>SQL 코드 스타일 설정하기</h4><p><img data-src="/images/posts/intellij-sql-code-style/01.png" alt="Case → Word Case">  </p><p>코드 스타일 설정 메뉴에서 <a href="https://www.jetbrains.com/help/idea/configure-the-sql-code-style.html">The Database Tools and SQL plugin</a> 에 대한 코드 서식을 지정할 수 있다. <code>설정 → 에디터 → 코드 스타일 → SQL → 일반</code> 에서 키워드를 대문자로 설정하는 옵션을 찾아볼 수 있다. 위 이미지는 키워드를 대문자로 설정하고 컬럼 유형을 키워드로 인식될 수 있도록 변경한 것을 보여준다.</p><h4 id="Optional-SELECT-쿼리-시-콤마-위치-선택하기-🤔"><a href="#Optional-SELECT-쿼리-시-콤마-위치-선택하기-🤔" class="headerlink" title="(Optional) SELECT 쿼리 시 콤마 위치 선택하기 🤔"></a>(Optional) SELECT 쿼리 시 콤마 위치 선택하기 🤔</h4><p><img data-src="/images/posts/intellij-sql-code-style/02.png" alt="Queries → Place comma">  </p><p><code>Queries → Common → Place comma</code> 옵션으로 SELECT 쿼리 시 결과물이 되는 필드에 대해서 콤마 위치를 앞에 오도록 선택할 수 있다. 개발자마다 선호하는 스타일이 다를 수 있는데 개인적으로 콤마가 앞에 오는 경우 복사 및 붙여넣기 시 들여쓰기 이슈가 발생할 수 있어 콤마가 뒤에 오도록 작성하는 편이다.</p><p>SQL 코드 포맷팅을 많이 수행해왔지만 최근까지도 나는 대&#x2F;소문자 변환 단축키를 사용해서 이쁘게 키워드 부분들을 변환해왔다. 나와 같은 개발자가 있었다면 불편함에서 벗어나길 바란다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;인텔리제이 얼티메이트 버전에서는 데이터베이스 대한 기능을 내장하고 있고 &lt;a href=&quot;https://www.jetbrains.com/help/idea/settings-code-style-sql.html&quot;&gt;SQL 코드 서식&lt;/a&gt;에 대한 포맷팅 </summary>
      
    
    
    
    
    <category term="SQL" scheme="https://kdevkr.github.io/tags/SQL/"/>
    
    <category term="Code Style" scheme="https://kdevkr.github.io/tags/Code-Style/"/>
    
  </entry>
  
  <entry>
    <title>서버 시간 동기화</title>
    <link href="https://kdevkr.github.io/server-time-sync/"/>
    <id>https://kdevkr.github.io/server-time-sync/</id>
    <published>2023-12-01T05:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.019Z</updated>
    
    <content type="html"><![CDATA[<p>오늘은 개발자에게도 중요한 서버 시간에 대한 동기화를 알아보도록 하자. AWS 클라우드에 의존하는 개발자들은 <a href="https://aws.amazon.com/ko/blogs/korea/keeping-time-with-amazon-time-sync-service/">Amazon Time Sync Service</a>를 참조하도록 설정된 EC2 인스턴스를 활용하고 있기 때문에 시간 동기화에 대해 신경써야할 부분은 적다. 하지만, 클라우드 시대에 살고 있지만 많은 이유로 인하여 온-프레미스 환경에서 동작해야하는 시스템은 상당히 많다. 온-프레미스 인프라 구성에서는 인터넷 통신이 제한되는 경우가 많기 때문에 자체적인 타임 서버를 구성하고 의존하도록 되어있을 것이다.</p><p>신규 프로젝트를 마무리하기 위해 검수하는 과정에서 전달받은 피드백 중 하나는 기존에 사용하고 있던 시스템의 데이터 시간과 일치하지 않는다는 것이었는데 이것은 보안 상의 이유로 개발중인 시스템이 본래 시스템의 네트워크에 연결되도록 고려하거나 계약되지 않았기 때문이다. 따라서, 인터넷 통신이 되지 않으므로 공개적인 NTP 서버와의 통신이 불가능하므로 컴퓨터 메인보드에 존재하는 RTC(Real Time Clock) 에 의존하고 있을 것이기에 조금씩 시간 차이가 많이 나게 될 수 있다.</p><h4 id="Linux-인스턴스의-시간-설정"><a href="#Linux-인스턴스의-시간-설정" class="headerlink" title="Linux 인스턴스의 시간 설정"></a><a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/set-time.html#configure-amazon-time-service-ubuntu">Linux 인스턴스의 시간 설정</a></h4><ul><li><code>timedatectl</code>: 시간 정보</li><li><code>chronyc tracking</code>: 시간 동기화 지표</li><li><code>chronyc -a makestep</code>: 즉시 동기화</li></ul><p>리눅스에서 어떻게 시간을 동기화하고 있는지 확인하고자 하는 경우 <code>timedatectl</code> 명령어를 사용할 수 있다. 아래와 같이 시스템 클럭에 동기화되며 NTP 서비스도 활성화되어있음을 알 수 있다. 만약, NTP 서버 주소를 추가하거나 변경했는데 반영되지 않는다면 즉시 동기화 명령어를 수행해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 시간 정보</span></span><br><span class="line">$ timedatectl</span><br><span class="line">               Local time: Fri 2023-12-01 11:57:48 UTC</span><br><span class="line">           Universal time: Fri 2023-12-01 11:57:48 UTC</span><br><span class="line">                 RTC time: Fri 2023-12-01 11:57:49    </span><br><span class="line">                Time zone: Etc/UTC (UTC, +0000)       </span><br><span class="line">System clock synchronized: <span class="built_in">yes</span>                        </span><br><span class="line">              NTP service: active                     </span><br><span class="line">          RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 동기화 지표</span></span><br><span class="line">$ chronyc tracking</span><br><span class="line">Reference ID    : 0356046A (ec2-3-86-4-106.compute-1.amazonaws.com)</span><br><span class="line">Stratum         : 5</span><br><span class="line">Ref time (UTC)  : Fri Dec 01 12:04:57 2023</span><br><span class="line">System time     : 0.000258254 seconds fast of NTP time</span><br><span class="line">Last offset     : -0.000113504 seconds</span><br><span class="line">RMS offset      : 0.002757813 seconds</span><br><span class="line">Frequency       : 451.939 ppm slow</span><br><span class="line">Residual freq   : +0.044 ppm</span><br><span class="line">Skew            : 22.140 ppm</span><br><span class="line">Root delay      : 0.185094610 seconds</span><br><span class="line">Root dispersion : 0.001233191 seconds</span><br><span class="line">Update interval : 16.5 seconds</span><br><span class="line">Leap status     : Normal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 즉시 동기화 수행</span></span><br><span class="line">$ chronyc -a makestep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># chrony 설정 파일</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/chrony/chrony.conf</span><br><span class="line">...</span><br><span class="line">server time.aws.com prefer iburst minpoll 4 maxpoll 4</span><br><span class="line">pool 1.kr.pool.ntp.org iburst</span><br><span class="line">pool 1.asia.pool.ntp.org iburst</span><br><span class="line">pool 2.asia.pool.ntp.org iburst</span><br><span class="line">server time.bora.net iburst</span><br><span class="line">server time.google.com iburst</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="윈도우-서버-동기화하기"><a href="#윈도우-서버-동기화하기" class="headerlink" title="윈도우 서버 동기화하기"></a><a href="https://customer.gabia.com/manual/cloud/7700/7720">윈도우 서버 동기화하기</a></h4><p>만약, 윈도우 서버를 사용하고 있다면 <code>시간 및 날짜 설정</code> 기능에서 <code>인터넷 시간 서버</code>를 변경하도록 하자. 그리고 더 자세한 설정이 필요하다면 관련 레지스트리 설정을 검색해서 적용해야한다.</p><h4 id="시간-동기화-관련-깨알지식"><a href="#시간-동기화-관련-깨알지식" class="headerlink" title="시간 동기화 관련 깨알지식"></a>시간 동기화 관련 깨알지식</h4><p>컴퓨터 메인보드에는 하드웨어 시계를 위해 시간 정보를 저장하는 RTC(Real Time Clock) 배터리가 존재한다. 자동차 블랙박스에서도 RTC 배터리를 내장하고 있고 (GPS 연동이 없는 경우) 시간이 조금씩 맞지 않는 문제를 경험할 수 있다. 그리고 타임 서버 구성을 위한 시간 동기화용 GPS 서버도 있다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;오늘은 개발자에게도 중요한 서버 시간에 대한 동기화를 알아보도록 하자. AWS 클라우드에 의존하는 개발자들은 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/korea/keeping-time-with-amazon-time</summary>
      
    
    
    
    
    <category term="NTP" scheme="https://kdevkr.github.io/tags/NTP/"/>
    
    <category term="chrony" scheme="https://kdevkr.github.io/tags/chrony/"/>
    
  </entry>
  
  <entry>
    <title>AWS SDK for Java BOM</title>
    <link href="https://kdevkr.github.io/aws-sdk-for-java-bom/"/>
    <id>https://kdevkr.github.io/aws-sdk-for-java-bom/</id>
    <published>2023-10-22T06:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<p>AWS 경험이 많지 않은 개발자 혹은 신규 프로젝트를 위한 구성 시 종종 신경쓰지 않아 발생하는 문제는 AWS 서비스와의 연동을 위한 자바 라이브러리를 사용하기 위해 AWS Java SDK 를 추가하는 것으로 인한 과도하된 애플리케이션 용량이다. 처음부터 공식 문서를 제대로 참고한다면 Java SDK 를 위한 Maven BOM 을 추가하는 방식으로 구성했을 것이다. 그렇지 않은 경우라면 아래와 같이 AWS Java SDK 전체를 추가했을 것이다.</p><h4 id="애플리케이션-빌드-용량-문제"><a href="#애플리케이션-빌드-용량-문제" class="headerlink" title="애플리케이션 빌드 용량 문제"></a>애플리케이션 빌드 용량 문제</h4><figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;software.amazon.awssdk:aws-sdk-java:2.21.4&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.amazonaws:aws-java-sdk:1.12.570&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 경우는 연동하려는 서비스마다 참고한 코드가 다름으로 인해 V1과 V2 라이브러리를 혼재한 경우를 의미할지도 모른다. 만약, 정말로 프로젝트에서 추가하는 방식이 위와 같다면 여러분이 인텔리제이와 같은 IDE 도구로 프로젝트를 열었을때 수 많은 라이브러리들을 다운받기 위해서 열일하는 프로그램을 볼 수 있게 될 것이다.</p><p>사실 오랫동안 기다려서 한번 다운로드 받게되면 캐시하여 사용하게 되므로 딱히 문제점을 인지하지 못할지도 모른다. 메이븐이나 그래들로 다운받는 라이브러리들은 프로젝트 폴더에 위치하는게 아니기 때문이다. 내재된 문제에 대해서는 빌드 과정에서 인지하게 된다. 빌드된 애플리케이션 실행 파일을 살펴보면 무려 800 메가를 넘는 용량을 가진다.</p><p><img data-src="/images/posts/aws-sdk-for-java-bom/01.png">  </p><h4 id="애플리케이션에-최적화된-빌드-용량"><a href="#애플리케이션에-최적화된-빌드-용량" class="headerlink" title="애플리케이션에 최적화된 빌드 용량"></a>애플리케이션에 최적화된 빌드 용량</h4><p>애플리케이션 빌드 시 정상적인 결과를 가질 수 있도록 Java SDK for Java 를 위한 Maven BOM 으로 버전을 관리하고 애플리케이션에서 사용하는 라이브러리만을 추가하도록 하자. </p><figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation platform(<span class="string">&#x27;software.amazon.awssdk:bom:2.21.4&#x27;</span>)</span><br><span class="line">    implementation platform(<span class="string">&#x27;com.amazonaws:aws-java-sdk-bom:1.12.570&#x27;</span>)</span><br><span class="line">    implementation <span class="string">&#x27;software.amazon.awssdk:ec2&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.amazonaws:aws-java-sdk-s3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/posts/aws-sdk-for-java-bom/02.png">  </p><p>오래전에 발생하여 공유했던 트러블슈팅인데 시간이 지나면서 신규 프로젝트에서도 동일한 상황이 발생해서 정리하여 공유해본다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AWS 경험이 많지 않은 개발자 혹은 신규 프로젝트를 위한 구성 시 종종 신경쓰지 않아 발생하는 문제는 AWS 서비스와의 연동을 위한 자바 라이브러리를 사용하기 위해 AWS Java SDK 를 추가하는 것으로 인한 과도하된 애플리케이션 용량이다.</summary>
      
    
    
    
    
    <category term="Maven BOM" scheme="https://kdevkr.github.io/tags/Maven-BOM/"/>
    
    <category term="aws-java-sdk" scheme="https://kdevkr.github.io/tags/aws-java-sdk/"/>
    
    <category term="aws-sdk-java" scheme="https://kdevkr.github.io/tags/aws-sdk-java/"/>
    
  </entry>
  
  <entry>
    <title>Cross Site Request Forgery (CSRF)</title>
    <link href="https://kdevkr.github.io/spring-boot-security-csrf/"/>
    <id>https://kdevkr.github.io/spring-boot-security-csrf/</id>
    <published>2023-10-21T00:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>프론트엔드와 백엔드 애플리케이션이 분리되어있어도 <a href="https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html">Cross Site Request Forgery (CSRF)</a>를 비활성화하지 말자.</p></blockquote><p>CSRF 자체에 대해서 잘 모르는 개발자라면 <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">Cross-Site Request Forgery Prevention Cheat Sheet</a>를 참고해보도록 하자. 애플리케이션 보안 가이드에서 <a href="https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#csrf-considerations">로그인과 로그아웃 행위에 대해서는 CSRF 토큰을 사용한 검증을 요구</a>하는 편이다. 스프링 시큐리티에서는 <a href="https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-protection">CSRF 공격에 방어하는 매커니즘</a>을 제공하여 쉽게 CSRF 토큰을 적용할 수 있다.</p><ul><li>HttpSessionCsrfTokenRepository</li><li>CookieCsrfTokenRepository</li><li>XorCsrfTokenRequestAttributeHandler</li><li>XorCsrfChannelInterceptor</li><li>CsrfFilter</li><li>CsrfLogoutHandler</li></ul><p>스프링 시큐리티의 SecurityFilterChain을 구성하는 과정의 <code>CsrfConfigurer</code>를 살펴보면 <code>CsrfFilter</code>를 필터에 등록하는데 CsrfTokenRepository와 CsrfTokenRequestHandler가 사용되도록 전달된다. 공식 문서를 참고해보면 기본적으로는 스프링 시큐리티 6 부터 <code>HttpSessionCsrfTokenRepository</code>와 <code>XorCsrfTokenRequestAttributeHandler</code>가 사용되도록 되어있으며 HTTP가 아닌 웹소켓을 위한 보안 설정 시(@EnableWebSocketSecurity)에는 <code>XorCsrfChannelInterceptor</code>이 적용되어 동작한다.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> SecurityConfig &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       http.csrf(csrf -&gt; csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CSRF-토큰-API-엔드포인트"><a href="#CSRF-토큰-API-엔드포인트" class="headerlink" title="CSRF 토큰 API 엔드포인트"></a>CSRF 토큰 API 엔드포인트</h4><p>백엔드와 프론트엔드 애플리케이션이 분리되어있다고 해서 HttpOnly 속성이 지정되지 않은 CSRF 쿠키를 전달하기 위해 <code>CookieCsrfTokenRepository</code>를 사용할 필요는 없다. 프론트엔드 애플리케이션을 위한 CSRF 토큰이 필요하다면 아래와 같은 CSRF 토큰을 응답해주는 API를 만들어서 제공하자. 기본적으로 GET 요청은 안전한 메소드로 간주하여 스프링 시큐리티는 CSRF 토큰에 대한 검증을 처리하지 않는다.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CsrfController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/csrf&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CsrfToken <span class="title function_">csrf</span><span class="params">(CsrfToken csrfToken)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> csrfToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.data.go.kr/data/15049185/fileData.do">애플리케이션 보안 가이드</a>에서는 로그인과 로그아웃 요청에 대해 CSRF 공격에 대한 방어를 요구한다. 간혹 백엔드와 프론트엔드 애플리케이션이 분리되어 JWT와 같은 토큰 기반 인증을 수행한다면 비활성화하거나 조치할 필요가 없다는 것을 기록한 블로그가 보이는데 이것은 잘못된 정보이다. 브라우저에서 토큰을 전달할 방법은 쿠키나 별도의 헤더 뿐이며 쿠키도 사실 상 헤더 중 하나일 뿐이다. </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultRequiresCsrfMatcher</span> <span class="keyword">implements</span> <span class="title class_">RequestMatcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;String&gt; allowedMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;HEAD&quot;</span>, <span class="string">&quot;TRACE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">this</span>.allowedMethods.contains(request.getMethod());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스프링 시큐리티에서는 기본적으로 <code>GET, HEAD, TRACE, OPTIONS</code>에 대해서는 안전한 메소드로 판단하여 CSRF 검증을 무시한다. 만약, GET을 안전하지 않는 행위로 사용한다면 CSRF 검증을 별도로 수행해야한다. 예를 들어, 쉽게 로그아웃 하기 위해서 POST 요청이 아닌 GET 요청으로 구현했다면 CSRF 필터에서 무시되고 넘어가므로 <code>requireCsrfProtectionMatcher</code> 를 수정하자.</p><h4 id="CSRF-토큰을-전달하는-방법"><a href="#CSRF-토큰을-전달하는-방법" class="headerlink" title="CSRF 토큰을 전달하는 방법"></a>CSRF 토큰을 전달하는 방법</h4><p>CSRF 토큰은 일반적으로 HTML 폼 전송 시 _csrf 파라미터로 전달하는데 X-CSRF-TOKEN 또는 X-XSRF-TOKEN 헤더로도 전달할 수 있도록 스프링 시큐리티에서 지원한다. 기본적으로는 HttpSessionCsrfTokenRepository 가 사용되는데 <code>X-CSRF-TOKEN</code> 이라는 헤더를 CookieCsrfTokenRepository는 <code>X-XSRF-TOKEN</code> 헤더를 매칭한다. 그러니까, 기본적으로는 X-CSRF-TOKEN 헤더로 전달해야하지만 쿠키 기반의 CookieCsrfTokenRepository를 적용했다면 X-XSRF-TOKEN 헤더로 요청 시 전달해야 CSRF 토큰을 제대로 검증할 수 있다.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CsrfTokenRequestHandler</span> <span class="keyword">extends</span> <span class="title class_">CsrfTokenRequestResolver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Supplier&lt;CsrfToken&gt; csrfToken)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">resolveCsrfTokenValue</span><span class="params">(HttpServletRequest request, CsrfToken csrfToken)</span> &#123;</span><br><span class="line">        Assert.notNull(request, <span class="string">&quot;request cannot be null&quot;</span>);</span><br><span class="line">        Assert.notNull(csrfToken, <span class="string">&quot;csrfToken cannot be null&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">actualToken</span> <span class="operator">=</span> request.getHeader(csrfToken.getHeaderName());</span><br><span class="line">        <span class="keyword">if</span> (actualToken == <span class="literal">null</span>) &#123;</span><br><span class="line">            actualToken = request.getParameter(csrfToken.getParameterName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> actualToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앞서 CSRF 토큰을 응답하는 API 에서는 토큰 뿐만 아니라 요청 파라미터를 전달할 이름과 헤더를 함께 제공해준다. 따라서, Axios와 같은 HTTP 요청 라이브러리를 통해 XHR 요청을 수행한다면 아래와 같이 전달할 수 있다. </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/csrf&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> csrf = res.<span class="property">data</span></span><br><span class="line">    axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">post</span>[csrf.<span class="property">headerName</span>] = csrf.<span class="property">token</span></span><br><span class="line">    axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">put</span>[csrf.<span class="property">headerName</span>] = csrf.<span class="property">token</span></span><br><span class="line">    axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">delete</span>[csrf.<span class="property">headerName</span>] = csrf.<span class="property">token</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;프론트엔드와 백엔드 애플리케이션이 분리되어있어도 &lt;a href=&quot;https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html&quot;&gt;Cross Site </summary>
      
    
    
    
    
    <category term="Spring Security" scheme="https://kdevkr.github.io/tags/Spring-Security/"/>
    
    <category term="Axios" scheme="https://kdevkr.github.io/tags/Axios/"/>
    
    <category term="CSRF" scheme="https://kdevkr.github.io/tags/CSRF/"/>
    
    <category term="XSRF" scheme="https://kdevkr.github.io/tags/XSRF/"/>
    
  </entry>
  
  <entry>
    <title>스프링 부트 보안 설정</title>
    <link href="https://kdevkr.github.io/spring-boot-security/"/>
    <id>https://kdevkr.github.io/spring-boot-security/</id>
    <published>2023-10-17T13:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>본 글은 스프링 부트 프로젝트로 만들어진 애플리케이션에서 스프링 시큐리티 모듈을 적용하는 경우에 보안 설정에 대해 정리한 것 입니다. 일반적으로 오해하고 있거나 신경쓰지 않는 부분에 대해서 다루고자 합니다.</p></blockquote><h4 id="더-안전한-CSRF-토큰-설정"><a href="#더-안전한-CSRF-토큰-설정" class="headerlink" title="더 안전한 CSRF 토큰 설정"></a>더 안전한 CSRF 토큰 설정</h4><p>리액트나 뷰와 같은 프론트엔드 개발 환경이어도 서버 애플리케이션에서 CSRF 토큰을 프론트엔드로 전달하기 위해 쿠키를 이용할 필요는 없다. 자바스크립트에서 쿠키에 저장된 XSRF-TOKEN 값을 가져올 수 있도록 httpOnly 설정을 비활성화하지 말자. 이것에 대안으로 CSRF 토큰을 제공하는 API를 만들어서 응답하면 된다.</p><figure class="highlight java"><figcaption><span>WebSecurityConfig.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerProperties serverProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CsrfTokenRepository <span class="title function_">csrfTokenRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        Session.<span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> serverProperties.getServlet().getSession().getCookie();</span><br><span class="line">        <span class="type">CookieCsrfTokenRepository</span> <span class="variable">tokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookieCsrfTokenRepository</span>();</span><br><span class="line">        tokenRepository.setCookieCustomizer(c -&gt; c.secure(cookie.getSecure())</span><br><span class="line">                .path(cookie.getPath())</span><br><span class="line">                .httpOnly(cookie.getHttpOnly())</span><br><span class="line">                .sameSite(cookie.getSameSite().attributeValue())</span><br><span class="line">                .maxAge(Duration.ofMinutes(<span class="number">30</span>)));</span><br><span class="line">        <span class="keyword">return</span> tokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.csrf(csrf -&gt; csrf.csrfTokenRepository(csrfTokenRepository()));</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>CsrfController.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CsrfController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CsrfTokenRepository csrfTokenRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/csrf&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CsrfToken <span class="title function_">csrf</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> csrfTokenRepository.loadDeferredToken(request, response).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>자바스크립트 애플리케이션을 위한 더 다양한 방법은 <a href="https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#csrf-integration-javascript">공식 문서를 참고</a>하세요.</p></blockquote><p>애플리케이션 보안에서 더 중요한 것은 로그인 및 로그아웃 요청에 대해 CSRF를 사용해서 로그인 시도를 위조하지 못하도록 하는 것이다. 스프링 시큐리티의 기본 폼 로그인이나 HTTP 베이직 인증이 아니라 별도의 API를 작성한다면 반드시 <a href="https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#csrf-testing">CSRF 토큰이 적용되는지 검증</a>하도록 하자.</p><h4 id="리버스-프록시-보안"><a href="#리버스-프록시-보안" class="headerlink" title="리버스 프록시 보안"></a>리버스 프록시 보안</h4><p>스프링 시큐리티는 기본적으로 <a href="https://docs.spring.io/spring-security/reference/features/exploits/headers.html">보안을 위한 응답 헤더</a>를 추가해준다. 다만, <a href="https://docs.spring.io/spring-security/reference/features/exploits/headers.html#headers-hsts">HSTS</a>의 경우는 애플리케이션 자체가 HTTPS 프로토콜로 실행되었을때 활성화된다. 따라서, 엔진엑스와 같은 웹 서버나 로드밸런서를 통해 리버스 프록시를 구성하는 경우에는 HTTP 포트를 사용해서 애플리케이션을 실행하므로 <code>엔진엑스와 같은 웹 서버에서 HSTS 헤더를 응답</code>하도록 하자.</p><figure class="highlight plaintext"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot;;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        limit_except GET POST PUT DELETE OPTIONS &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>리액트 또는 뷰의 빌드 에셋을 애플리케이션이 배포하지 않는다면 웹 서버에서 보안 응답 헤더를 동일하게 전달되도록 구성해야합니다.</p></blockquote><h4 id="웹소켓-보안"><a href="#웹소켓-보안" class="headerlink" title="웹소켓 보안"></a>웹소켓 보안</h4><p>스프링 시큐리티는 기본적으로 HTTP 통신에 대한 보안 설정을 제공한다. 만약, 애플리케이션 기능 요구사항을 위해 웹소켓 프로토콜을 사용한다면 <a href="https://docs.spring.io/spring-security/reference/servlet/integrations/websocket.html">웹소켓에 대한 보안</a>에 대해 별도로 체크해야한다. 스프링 시큐리티 모듈을 사용한다면 일반적인 웹소켓 구현보다는 STOMP 방식의 웹소켓 연결을 구성하는 것이 좋다. <a href="https://docs.spring.io/spring-security/reference/servlet/integrations/websocket.html#websocket-sameorigin-csrf">CSRF</a>을 적용하거나 SockJS를 위한 <a href="https://docs.spring.io/spring-security/reference/servlet/integrations/websocket.html#websocket-sockjs-sameorigin">iFrame</a> 옵션을 체크하도록 하자.</p><figure class="highlight java"><figcaption><span>WebSocketSecurity.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketSecurity</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationManager&lt;Message&lt;?&gt;&gt; messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Failed to send message to ExecutorSubscribableChannel[clientInboundChannel]: Access Denied</span></span><br><span class="line">        messages</span><br><span class="line">                .nullDestMatcher().authenticated()</span><br><span class="line">                .simpDestMatchers(<span class="string">&quot;/app/**&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .simpSubscribeDestMatchers(<span class="string">&quot;/user/queue/error&quot;</span>).authenticated()</span><br><span class="line">                .simpSubscribeDestMatchers(<span class="string">&quot;/user/**&quot;</span>, <span class="string">&quot;/topic/hello&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .anyMessage().denyAll();</span><br><span class="line">        <span class="keyword">return</span> messages.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SockJS의 웹소켓 연결을 위해 사전에 요청하는 &#x2F;info 엔드포인트는 일반적인 HTTP 통신임에 주의하도록 해야합니다.</p></blockquote><p>애플리케이션 보안 점검으로 인해 다시 한번 학습하는 것은 안 비밀이다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;본 글은 스프링 부트 프로젝트로 만들어진 애플리케이션에서 스프링 시큐리티 모듈을 적용하는 경우에 보안 설정에 대해 정리한 것 입니다. 일반적으로 오해하고 있거나 신경쓰지 않는 부분에 대해서 다루고자 합니다.&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    
    <category term="Spring Security" scheme="https://kdevkr.github.io/tags/Spring-Security/"/>
    
    <category term="Protection Aganinst Exploits" scheme="https://kdevkr.github.io/tags/Protection-Aganinst-Exploits/"/>
    
  </entry>
  
  <entry>
    <title>Invalid SockJS Path.</title>
    <link href="https://kdevkr.github.io/invalid-sockjs-path/"/>
    <id>https://kdevkr.github.io/invalid-sockjs-path/</id>
    <published>2023-10-16T13:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Invalid SockJS path ‘XXX’ required to have 3 path segments.</p></blockquote><p>구글에 <a href="https://www.google.com/search?q=Invalid+SockJS+path">Invalid SockJS path</a> 라는 키워드로 검색해보면 이와 같은 오류 로그에 대한 조치로 <a href="https://stackoverflow.com/a/64576478">Stomp 클라이언트를 사용하라는 답변</a>이나 <a href="https://github.com/spring-projects/spring-framework/issues/28103">스택 오버플로우에 질문하라는 답변</a>을 찾아볼 수 있다. 아무튼 위 상황에 대한 원인은 명확히 알 수 없는 상황에서 아래와 같은 구조에서 해당 오류가 발생했다.</p><ol><li>Nginx Websocket Proxy</li><li>Spring WebSocket with Stomp + SockJS</li><li><code>sockjs-client@1.6.1</code></li><li><code>@stomp/stompjs@7.0.0</code></li></ol><h4 id="이슈-파악"><a href="#이슈-파악" class="headerlink" title="이슈 파악"></a>이슈 파악</h4><p><a href="https://github.com/kdevkr/nginx.conf">nginx.conf</a>와 같이 엔진엑스에서 웹소켓 주소 패턴에 대해 백엔드 애플리케이션으로의 리버스 프록시 구성을 아래와 같이 해둔 상태였다. 그리고 Stomp 방식의 웹 소켓 연결을 수행하는 엔드포인트는 <code>/ws/stomp</code> 로 정의되어있었다. 본래 <code>/ws</code> 는 일반적인 웹 소켓 연결을 수행하고 <code>/ws/stmop</code>로 시작되는 것은 Stomp로 동작하는 것을 의도한 것이다.</p><figure class="highlight plaintext"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server app:8080;</span><br><span class="line">        keepalive 128;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location /ws/ &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            # hop-by-hop</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_read_timeout 65s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Vite 개발 서버에서의 Proxy 구성의 경우 올바르게 Stomp 방식의 웹소켓 연결을 수행된다.</p></blockquote><p>하지만, 엔진엑스와 함께 동작중인 배포 환경에서는 Stomp 클라이언트가 SockJS를 사용하여 연결을 수행하려고 할때 <code>/ws/stomp/info?t=0</code> 엔드포인트에 대해 404 응답을 받게되고 애플리케이션 로그에는 <code>Invalid SockJS path ...</code>가 출력되는 것을 확인했다.</p><h4 id="솔루션"><a href="#솔루션" class="headerlink" title="솔루션"></a>솔루션</h4><p>이리저리 시도해본 결과 해결책은 일반적인 웹 소켓 연결과 Stomp 방식의 연결을 아예 분리하는 것이다. <code>/ws/</code> 이외에 <code>/ws-stomp/</code>로 Stomp 방식의 웹 소켓 연결을 위한 별도의 엔드포인트 패턴을 사용하고 리버스 프록시 구성을 하고나니 해당 증상은 발생하지 않았다.</p><figure class="highlight plaintext"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server app:8080;</span><br><span class="line">        keepalive 128;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location ~ ^/(ws|ws-stomp)/ &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            # hop-by-hop</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_read_timeout 65s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아무튼 정확한 원인에 대해서는 별도로 찾아보아야겠지만 기록으로 남기고자 한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Invalid SockJS path ‘XXX’ required to have 3 path segments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;구글에 &lt;a href=&quot;https://www.google.com/search?</summary>
      
    
    
    
    
    <category term="Nginx" scheme="https://kdevkr.github.io/tags/Nginx/"/>
    
    <category term="Spring" scheme="https://kdevkr.github.io/tags/Spring/"/>
    
    <category term="SockJS" scheme="https://kdevkr.github.io/tags/SockJS/"/>
    
    <category term="Stomp" scheme="https://kdevkr.github.io/tags/Stomp/"/>
    
  </entry>
  
  <entry>
    <title>스프링 부트 웹소켓</title>
    <link href="https://kdevkr.github.io/spring-boot-websocket/"/>
    <id>https://kdevkr.github.io/spring-boot-websocket/</id>
    <published>2023-10-14T13:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>본 글에서 언급하는 관련 코드는 <a href="https://github.com/kdevkr/spring-boot-demo/tree/main/websocket-demo">github.com&#x2F;kdevkr&#x2F;spring-boot-demo&#x2F;websocket-demo</a>에서 확인할 수 있습니다.</p></blockquote><p>일반적인 스프링 부트 스타터와는 다르게 스타터 웹소켓 모듈에는 웹소켓 연결에 대한 자동 구성을 수행하지는 않는다. 웹소켓 관련한 자동 구성(WebSocketServletAutoConfiguration)은 프로젝트에서 사용중인 서블릿 컨테이너에 따라 웹소켓에 대해 처리할 수 있도록 확장하며 WebSocketMessagingAutoConfiguration 에서는 Stomp 방식의 웹소켓을 위한 메시지 브로커를 구성할 때 사용되는 메시지 컨버터를 설정한다.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(<span class="keyword">new</span> <span class="title class_">TextWebSocketHandler</span>()&#123;&#125;, <span class="string">&quot;/ws&quot;</span>)</span><br><span class="line">                .setAllowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .addInterceptors(<span class="keyword">new</span> <span class="title class_">HttpSessionHandshakeInterceptor</span>())</span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-framework/reference/web/websocket/server.html">WebSocket API</a>의 WebSocketConfigurer 인터페이스를 구현하여 웹소켓 연결에 대해서 처리할 수 있는 핸들러를 추가할 수 있다. 그러나, 일반적인 웹소켓 연결 방식에는 여러가지 단점이 있는데 세션과 시큐리티와 같은 부가적인 기능과의 연계를 직접적으로 구현해야한다는 것이다.</p><h4 id="SockJS-Fallback"><a href="#SockJS-Fallback" class="headerlink" title="SockJS Fallback"></a>SockJS Fallback</h4><p><a href="https://docs.spring.io/spring-framework/reference/web/websocket/fallback.html">SockJS</a>는 웹소켓 연결에 대한 문제를 보완하기 위해서 도입하는 기술이며 SockJS 클라이언트는 웹소켓 연결 주소를 기준으로 서버에게 &#x2F;info 엔드포인트를 요청하여 웹소켓 연결 방식에 대해 질의를 하고 응답받은 결과를 토대로 연결을 시도한다. 스프링 웹소켓 모듈의 DefaultSockJsService 에서는 아래와 같은 연결을 지원한다.</p><figure class="highlight java"><figcaption><span>DefaultSockJsService.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;TransportHandler&gt; <span class="title function_">getDefaultTransportHandlers</span><span class="params">(<span class="meta">@Nullable</span> Collection&lt;TransportHandler&gt; overrides)</span> &#123;</span><br><span class="line">    Set&lt;TransportHandler&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">XhrPollingTransportHandler</span>());</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">XhrReceivingTransportHandler</span>());</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">XhrStreamingTransportHandler</span>());</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">EventSourceTransportHandler</span>());</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">HtmlFileTransportHandler</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">WebSocketTransportHandler</span>(<span class="keyword">new</span> <span class="title class_">DefaultHandshakeHandler</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (overrides != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.addAll(overrides);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># http://localhost:8080/ws/info?t=1696757550304</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;entropy&quot;</span>: 1279751018,</span><br><span class="line">  <span class="string">&quot;origins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;*:*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;cookie_needed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;websocket&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;websocket-protocol&#125;://&#123;host&#125;:&#123;port&#125;/&#123;websocket-endpoint&#125;/&#123;server-id&#125;/&#123;session-id&#125;/&#123;transport&#125;</span></span><br><span class="line">ws://localhost:8080/ws/712/yyfmvviz/websocket</span><br></pre></td></tr></table></figure><blockquote><p>기본적으로 SockJsServiceRegistration의 웹소켓 연결 설정이 활성화되어있고 일부 로드밸런서에서 웹소켓을 지원하지 않는다면 비활성화할 수 있도록 지원한다.</p></blockquote><h4 id="Stomp-over-WebSocket"><a href="#Stomp-over-WebSocket" class="headerlink" title="Stomp over WebSocket"></a>Stomp over WebSocket</h4><h4 id="Webjars"><a href="#Webjars" class="headerlink" title="Webjars"></a>Webjars</h4><p>리액트나 뷰와 같은 프론트엔드 개발 환경을 구성한다면 자체적으로 라이브러리 패키지를 설치하고 관리하겠지만 백엔드 애플리케이션에서 라이브러리를 제공하고 싶다면 Webjars를 이용할 수도 있다.</p><figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.webjars:webjars-locator-core:0.53&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.webjars:sockjs-client:1.5.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.webjars:stomp-websocket:2.3.4&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="스프링-세션과의-통합"><a href="#스프링-세션과의-통합" class="headerlink" title="스프링 세션과의 통합"></a>스프링 세션과의 통합</h4><p>Stomp 방식의 웹 소켓 연결을 구성하는 경우에는 WebSocketMessageBrokerConfigurer를 직접 구현하기보다 스프링 세션 모듈에 포함되어있는 AbstractSessionWebSocketMessageBrokerConfigurer를 확장하는 것이 더 편리하다. 스프링 세션과 연계되는 미리 구현된 클래스들을 빈으로 등록하여 웹소켓 세션(WebSocketSession)에서 사용자 정보를 주입하고 쉽게 가져올 수 있도록 지원한다.</p><figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-websocket&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.session:spring-session-core&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StompConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractSessionWebSocketMessageBrokerConfigurer</span>&lt;MapSession&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/ws/stomp&quot;</span>)</span><br><span class="line">                .setAllowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> /topic: Broadcast, /queue: Unicast</span></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>);</span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line">        registry.setPreservePublishOrder(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>StompController.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StompController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SendTo(&quot;/topic/hello&quot;)</span></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">hello</span><span class="params">(GenericMessage&lt;String&gt; message,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@Header(name = &quot;simpSessionId&quot;)</span> String wsSessionId,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@Header(name = &quot;simpSessionAttributes&quot;)</span> Map&lt;String, Object&gt; sessionAttributes,</span></span><br><span class="line"><span class="params">                                     Principal principal)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> SessionRepositoryMessageInterceptor.getSessionId(sessionAttributes);</span><br><span class="line">        <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> Authentication) &#123;</span><br><span class="line">            username = principal.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; payload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        payload.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello, %s&quot;</span>.formatted(username));</span><br><span class="line">        payload.put(<span class="string">&quot;from&quot;</span>, <span class="string">&quot;StompController&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> similar @SendToUser</span></span><br><span class="line">        template.convertAndSendToUser(wsSessionId, <span class="string">&quot;/queue/hello&quot;</span>, payload, message.getHeaders());</span><br><span class="line">        <span class="keyword">return</span> payload;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="스프링-시큐리티와의-통합"><a href="#스프링-시큐리티와의-통합" class="headerlink" title="스프링 시큐리티와의 통합"></a>스프링 시큐리티와의 통합</h4><p>Stomp 방식의 웹 소켓 연결의 경우 스프링 세션과의 통합처럼 스프링 시큐리티와의 통합도 지원한다. 스프링 시큐리티가 기본 HTTP 보안을 설정한다면 @EnableWebSocketSecurity가 선언된 구성 클래스를 통해서 Stomp 메시지에 대해 보안 규칙을 설정할 수 있다. 일반적인 웹 소켓 연결을 구성하는 경우에 보안적인 로직을 직접 구현해야하지만 더 간단하게 적용할 수 있다.</p><figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-security&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.security:spring-security-messaging&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.security:spring-security-test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>WebSocketSecurity.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketSecurity</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationManager&lt;Message&lt;?&gt;&gt; messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Failed to send message to ExecutorSubscribableChannel[clientInboundChannel]: Access Denied</span></span><br><span class="line">        messages</span><br><span class="line">                .nullDestMatcher().authenticated()</span><br><span class="line">                .simpDestMatchers(<span class="string">&quot;/app/**&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .simpSubscribeDestMatchers(<span class="string">&quot;/user/queue/error&quot;</span>).authenticated()</span><br><span class="line">                .simpSubscribeDestMatchers(<span class="string">&quot;/user/**&quot;</span>, <span class="string">&quot;/topic/hello&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .anyMessage().denyAll();</span><br><span class="line">        <span class="keyword">return</span> messages.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebSocketSession-Management"><a href="#WebSocketSession-Management" class="headerlink" title="WebSocketSession Management"></a>WebSocketSession Management</h4><p>스케줄링 기능을 통해 특정 상황에서 웹소켓에 연결된 사용자에게 메시지를 전달할 필요성이 있다. 웹 소켓 연결에 대한 세션 관리를 해주지만 세션이 연결중인 WebSocketSession 목록은 관리해주지 않는다. 앞서, WebSocketRegistryListener를 통해 연결과 해지 그리고 메시지 수신 구독에 대한 이벤트를 처리할 핸들러를 구현할 수 있으므로 웹 소켓 세션을 저장하는 클래스를 구현해보도록 하자.</p><ul><li><a href="https://github.com/kdevkr/spring-boot-demo/blob/main/websocket-demo/src/main/java/kr/kdev/demo/WebSocketRepository.java">WebSocketRepository.java</a></li><li><a href="https://github.com/kdevkr/spring-boot-demo/blob/main/websocket-demo/src/main/java/kr/kdev/demo/WebSocketEventHandler.java">WebSocketEventHandler.java</a></li></ul><p>일부 예제에서는 WebSocketHandlerDecorator 클래스를 확장하여 웹 소켓 세션 관리를 구현하는 것을 찾아볼 수 있으나 이미 구현되어있고 굳이 핸들러를 교체할 필요가 없이 위와 같이 이벤트만을 받아서 처리하는게 더 간단하다. 또한, 굳이 핸들러 위치가 아니더라도 SimpMessagingTemplate를 통해 <a href="https://docs.spring.io/spring-framework/reference/web/websocket/stomp/handle-send.html">메시지를 송신</a>할 수 있다. SessionSubscribeEvent 와 SessionUnsubscribeEvent는 세션 자체를 전달해주지는 않지만 웹소켓 세션 아이디를 가져올 수 있으므로 특정 패턴의 구독 주소를 감지하여 세션 아이디 목록을 관리하고 애플리케이션에서 어떠한 데이터를 전달할 수 있도록 구현할 수 있을 것이다.</p><blockquote><p>스프링 세션 모듈과 연계된 웹소켓 연결을 구성하는 경우에 SimpMessaingTemplate를 통해 웹소켓 세션 아이디가 아닌 사용자 이름으로도 전달할 수 있다.</p></blockquote><h4 id="웹-소켓-관련-문서"><a href="#웹-소켓-관련-문서" class="headerlink" title="웹 소켓 관련 문서"></a>웹 소켓 관련 문서</h4><ul><li><a href="https://docs.spring.io/spring-framework/reference/web/websocket.html">Spring Framework - WebSockets</a></li><li><a href="https://docs.spring.io/spring-session/reference/web-socket.html">Spring Session - WebSocket Integration</a></li><li><a href="https://docs.spring.io/spring-security/reference/servlet/integrations/websocket.html">Spring Security - WebSocket Security</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;본 글에서 언급하는 관련 코드는 &lt;a href=&quot;https://github.com/kdevkr/spring-boot-demo/tree/main/websocket-demo&quot;&gt;github.com&amp;#x2F;kdevkr&amp;#x2F;</summary>
      
    
    
    
    
    <category term="SockJS" scheme="https://kdevkr.github.io/tags/SockJS/"/>
    
    <category term="WebSocket" scheme="https://kdevkr.github.io/tags/WebSocket/"/>
    
    <category term="STOMP" scheme="https://kdevkr.github.io/tags/STOMP/"/>
    
  </entry>
  
  <entry>
    <title>Systemd 서비스로 자바 애플리케이션 실행하기</title>
    <link href="https://kdevkr.github.io/java-app-service-with-systemd/"/>
    <id>https://kdevkr.github.io/java-app-service-with-systemd/</id>
    <published>2023-10-12T14:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.baeldung.com/linux/run-java-application-as-service">Run a Java Application as a Service on Linux</a> 를 참고해보니 <code>Systemd</code> 서비스를 사용해서 자바 애플리케이션을 실행하고 관리하는 서비스를 등록할 수 있다는 것을 알게되었다. 그동안 자바 애플리케이션을 배포하기 위한 <code>쉘 스크립트</code>를 작성하여 실행하고 종료하고 배포해오곤 했다. 반면에 Nginx의 경우 패키지로 설치하여 자동으로 서비스가 만들어져서 쉽게 실행할 수 있었다. 신규 프로젝트로 인해 데모용 애플리케이션을 새롭게 배포해야하는 요구사항이 생겼기에 이번에는 Systemd 서비스로 등록하여 관리해보자.</p><h4 id="Systemd-서비스-등록하기"><a href="#Systemd-서비스-등록하기" class="headerlink" title="Systemd 서비스 등록하기"></a>Systemd 서비스 등록하기</h4><p><code>/etc/systemd/system/</code> 폴더 하위에 <code>vi</code> 명령어를 사용해서 아래와 같이 서비스 파일을 만들어야 한다. <code>애플리케이션 또는 서비스 이름</code>을 파일명으로 작성하는 것을 추천한다. </p><figure class="highlight sh"><figcaption><span>/etc/systemd/system/app.service</span></figcaption><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Java application service</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">SuccessExitStatus=143</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=10s</span><br><span class="line"></span><br><span class="line">User=ubuntu</span><br><span class="line">Group=ubuntu</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/ubuntu/</span><br><span class="line">Environment=JAVA_HOME=/home/ubuntu/.sdkman/candidates/java/current</span><br><span class="line">ExecStart=/bin/java -jar /home/ubuntu/app.jar</span><br><span class="line">ExecStop=/bin/kill -15 <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>리눅스 서버에 여러개의 자바 버전을 혼용하는 경우 애플리케이션 실행 시 필요한 JDK 버전을 사용할 수 있도록 환경 변수를 지정하도록 하자. 예기치 않은 상황으로 애플리케이션이 종료되는 경우 다시 실행될 수 있도록 Restart 옵션을 적용하는 것을 고려하자.</p></blockquote><h4 id="Systemd-서비스-실행하기"><a href="#Systemd-서비스-실행하기" class="headerlink" title="Systemd 서비스 실행하기"></a>Systemd 서비스 실행하기</h4><p><code>service</code> 명령어를 통해 자바 애플리케이션 서비스를 실행하고 종료할 수 있으나 <code>systemctl</code> 명령어를 통해 서비스를 반영하고 리눅스 서버가 다시 실행되어 systemd 서비스가 실행되면 자동으로 시작될 수 있도록 <code>enable</code> 명령어를 수행하는 것이 좋다.</p><figure class="highlight sh"><figcaption><span>Termianl</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># Systemd 서비스 시작 시 자동 실행 등록</span></span><br><span class="line">ubuntu@ubuntu:~$ sudo systemctl <span class="built_in">enable</span> app.service</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/app.service → /etc/systemd/system/app.service.</span><br><span class="line"></span><br><span class="line">sudo systemctl status app.service <span class="comment"># sudo service app status</span></span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~$ sudo service app status</span><br><span class="line">● app.service - Java application service</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/app.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Thu 2023-10-12 14:01:24 UTC; 22min ago</span><br><span class="line">   Main PID: 25835 (java)</span><br><span class="line">      Tasks: 23 (<span class="built_in">limit</span>: 2256)</span><br><span class="line">     Memory: 150.6M</span><br><span class="line">     CGroup: /system.slice/app.service</span><br><span class="line">             └─25835 /bin/java -jar /home/ubuntu/app.jar</span><br></pre></td></tr></table></figure><blockquote><p>가끔씩 패키지로 설치한 서비스들이 예기치 않은 상황으로 리눅스 서버가 재실행되었을때 자동으로 실행되지 않는 상황이 종종 발생한다.<br>애플리케이션이 정상적으로 동작하는 것에 그치지 않고 다양한 문제에 대해 고민해야할 필요성이 있는 것 같다.</p></blockquote><h4 id="애플리케이션-로그-조회하기"><a href="#애플리케이션-로그-조회하기" class="headerlink" title="애플리케이션 로그 조회하기"></a>애플리케이션 로그 조회하기</h4><p>일반적으로 애플리케이션이 생성한 로그 파일을 <code>tail</code> 명령어를 사용하여 살펴보았으나 애플리케이션 서비스로 등록하였기에 별도의 파일로 저장하는 옵션을 두지 않았다면 <code>journalctl</code> 명령어를 사용해서 로그를 조회해야한다.</p><figure class="highlight sh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo journalctl -u app.service -f</span><br></pre></td></tr></table></figure><blockquote><p>운영중인 애플리케이션이나 서비스의 경우 잘 동작하는 쉘 스크립트를 굳이 서비스 방식으로 바꾸지는 말자.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/linux/run-java-application-as-service&quot;&gt;Run a Java Application as a Service on Linux&lt;/a&gt; 를 참고해보니 &lt;code&gt;S</summary>
      
    
    
    
    
    <category term="Systemd" scheme="https://kdevkr.github.io/tags/Systemd/"/>
    
    <category term="Java" scheme="https://kdevkr.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Nginx로 Vite 프로젝트 배포하기</title>
    <link href="https://kdevkr.github.io/deploy-vite/"/>
    <id>https://kdevkr.github.io/deploy-vite/</id>
    <published>2023-10-10T11:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Q. 프론트엔드 애플리케이션은 어떻게 배포를 해야할까?</p></blockquote><p>오래전부터 기본적으로는 백엔드 애플리케이션에서 프론트 UI 구성을 위한 에셋들을 관리하고 함께 빌드되어 배포되는 방식을 취해왔다. 그러나, 백엔드 개발자와 프론트엔드 개발자로 나누어지더니 하나의 서비스를 구성하는 프론트엔드 애플리케이션과 백엔드 애플리케이션이 나누어지고 각 애플리케이션을 개발할 수 있는 환경이 만들어지고 있다. 보통 백엔드 애플리케이션을 빌드하면서 UI 에셋 파일들을 포함하므로 배포 과정은 백엔드 개발자가 담당했던 조직이 많았을 것 같다.</p><p>만약, 조직 구성으로 인해 프론트엔드 애플리케이션 개발을 위한 프론트엔드 팀이 있는 곳이라면 프론트엔드 개발자가 배포를 직접 수행할 수도 있어보인다. 회사마다 일하는 방식은 다를 수 있기 때문에 릴리즈에 대한 부분은 QA 엔지니어가 담당하기도 한다. 아무튼 Vite 기반 프로젝트를 배포하는 방안에 대해서 정리해보자.</p><blockquote><p><a href="https://vitejs.dev/guide/static-deploy.html#deploying-a-static-site">Deploying a Static Site</a><br>It is important to note that vite preview is intended for previewing the build locally and not meant as a production server.</p></blockquote><p>로컬 환경에서 정적 페이지를 배포할 수 있는 웹 서버를 실행하는 preview 명령어를 제공하지만 위와 같이 프로덕션 환경을 위한 배포 서버는 아님에 주의해야한다. 기본적인 개념은 정적 배포를 위한 빌드 파일을 만들고나서 백엔드 서버 또는 웹 서버를 통해 정적 파일에 대한 응답을 처리하는 것이다.</p><ul><li><a href="https://ko.vitejs.dev/guide/build.html">Vite 프로덕션 버전으로 빌드하기</a></li><li><a href="https://ko.vitejs.dev/guide/backend-integration.html">Vite 백엔드 프레임워크와 함께 사용하기</a></li></ul><p>두번째 방식은 일반적으로 많이 사용되는 편으로 백엔드 서버가 스프링 부트 프로젝트라면 <a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-config/static-resources.html">정적 리소스 경로에 포함</a>될 수 있도록 하면 된다. 백엔드 애플리케이션 빌드 시 클래스패스에 포함되어도 되고 애플리케이션 프로퍼티를 통해 특정 파일 경로를 지정해도 된다. 본 글에서 정리하고자 하는 건 첫번째 방식으로 프로덕션 배포를 위한 정적 파일을 빌드하고나서 Nginx와 같은 웹서버를 통해 정적 파일을 배포하는 것이다.</p><blockquote><p>Nginx 웹서버에서 정적 파일을 배포하고 백엔드 API 요청에 대해서는 리버스 프록시 구성을 하면 된다. 리버스 프록시 구성의 장점은 백엔드 애플리케이션의 포트를 감출 수 있게 되어 조금은 보안적인 인프라 구성이 될 수 있다는 것이다. 참고로 Vite 개발 서버에서도 <a href="https://ko.vitejs.dev/config/server-options.html#server-proxy">프록시 구성</a>을 할 수 있게 제공한다.</p></blockquote><h4 id="Nginx-웹서버로-Vite-정적-파일-배포"><a href="#Nginx-웹서버로-Vite-정적-파일-배포" class="headerlink" title="Nginx 웹서버로 Vite 정적 파일 배포"></a>Nginx 웹서버로 Vite 정적 파일 배포</h4><figure class="highlight js"><figcaption><span>vite.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">manifest</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">target</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight sh"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">$ yarn --cwd <span class="string">&#x27;frontend&#x27;</span> install</span><br><span class="line">$ yarn --cwd <span class="string">&#x27;frontend&#x27;</span> run build --mode production</span><br><span class="line">vite v4.4.11 building <span class="keyword">for</span> production...</span><br></pre></td></tr></table></figure><p>빌드 명령어를 수행하면 아래와 같이 dist 폴더 아래에 정적 파일들이 생성된다.</p><ul><li>dist&#x2F;assets : 정적 에셋 모음</li><li>dist&#x2F;index.html : 진입점(EntryPoint) 파일</li><li>manifest.json : 매니페스트 파일</li></ul><p>생성된 정적 빌드 파일들을 <a href="https://github.com/kdevkr/nginx.conf">nginx.conf</a> 의 static 폴더로 대체하여 테스트를 해보자. 제대로 동작하지 않을텐데 Nginx의 설정 파일의 구성이 백엔드 애플리케이션으로 기본적인 요청을 전달하도록 되어있기 때문이다. <code>/</code> 경로에 대해서는 index.html을 응답하도록 변경해야하고 백엔드에 대한 요청이 나중에 전달되도록 수정해야한다.</p><figure class="highlight plaintext"><figcaption><span>nginx-vite.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  index index.html;</span><br><span class="line">  root /etc/nginx/static;</span><br><span class="line">  try_files $uri /index.html =404;</span><br><span class="line"></span><br><span class="line">  # 리버스 프록시</span><br><span class="line">  location ~ ^/(api|version) &#123;</span><br><span class="line">      proxy_pass http://backend;</span><br><span class="line">      proxy_redirect off;</span><br><span class="line">      proxy_buffering off;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">      access_log /var/log/nginx/access.log;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/posts/deploy-vite/01.png">  </p><p>기본적인 요청에 대해서는 static 폴더 기준으로 정적 파일을 사용해 응답하며 &#x2F;api 및 &#x2F;version 에 대해서만 백엔드 애플리케이션 요청으로 처리되도록 수정했다. 이제 아래와 같이 데모 애플리케이션이 정상적으로 보이며 &#x2F;version에 대한 요청을 전달하면 백엔드 애플리케이션에서 해당 경로가 매핑되지 않아서 스프링 부트의 화이트라벨 페이지로 404 응답을 볼 수 있다. 프론트 요청과 백엔드 요청을 효율적으로 구분할 수 있는 방안은 더 연구하고 찾아보고 학습해야할 부분이다.  </p><p>사실 상 백엔드 애플리케이션에 프론트엔드에 대한 정적 파일을 포함시키는 게 간단하지만 정적 파일을 배포하는 경량의 웹 서버를 두는 게 백엔드 애플리케이션의 부하를 줄일 수 있는 방안이다. 정적 파일에 대한 요청을 처리하기 위해서 스레드 풀에서 스레드를 사용하는 것은 생각보다 영향이 클 수도 있다. <code>선택은 여러분의 몫이다.</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Q. 프론트엔드 애플리케이션은 어떻게 배포를 해야할까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;오래전부터 기본적으로는 백엔드 애플리케이션에서 프론트 UI 구성을 위한 에셋들을 관리하고 함께 빌드되어 배포되는 방식을 취해왔다.</summary>
      
    
    
    
    
    <category term="Deployment" scheme="https://kdevkr.github.io/tags/Deployment/"/>
    
    <category term="Nginx" scheme="https://kdevkr.github.io/tags/Nginx/"/>
    
    <category term="Vite" scheme="https://kdevkr.github.io/tags/Vite/"/>
    
  </entry>
  
  <entry>
    <title>윈도우 환경에서 사설 루트 CA 인증서 등록하는 방법</title>
    <link href="https://kdevkr.github.io/windows-certlm/"/>
    <id>https://kdevkr.github.io/windows-certlm/</id>
    <published>2023-10-09T13:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.019Z</updated>
    
    <content type="html"><![CDATA[<p>윈도우 운영체제 환경에서 사설로 만들어진 루트 CA 인증서를 컴퓨터 인증서의 신뢰할 수 있는 루트 기관으로 등록할 수 있는 방법은 두가지가 있다. 첫번째로는 MMC(certlm.msc) 프로그램의 인증서 가져오기 마법사를 이용하는 방법과 크롬 또는 엣지 브라우저의 인증서 관리 메뉴를 통해 인증서 가져오기 마법사를 수행하는 방법이다. 이 글을 보는 개발자 또는 엔지니어라면 명령 프롬프트를 통해 certutil 도구로 명령어 기반으로 루트 CA 인증서를 등록할 수도 있다.</p><figure class="highlight sh"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">certutil -addstore <span class="string">&quot;Root&quot;</span> <span class="string">&quot;locaCA.crt&quot;</span></span><br><span class="line"></span><br><span class="line">Root <span class="string">&quot;신뢰할 수 있는 루트 인증 기관&quot;</span></span><br><span class="line">서명이 공개 키와 일치합니다.</span><br><span class="line"><span class="string">&quot;XXX&quot;</span> 인증서가 저장소에 추가되었습니다.</span><br><span class="line">CertUtil: -addstore 명령이 성공적으로 완료되었습니다.</span><br></pre></td></tr></table></figure><h4 id="Microsoft-Management-Console를-통해-인증서-관리"><a href="#Microsoft-Management-Console를-통해-인증서-관리" class="headerlink" title="Microsoft Management Console를 통해 인증서 관리"></a>Microsoft Management Console를 통해 인증서 관리</h4><ul><li>윈도우: 찾기 &gt; 컴퓨터 인증서 관리(certlm.msc) 또는 실행(Window 키 + R)</li><li>크롬: 설정 - 개인 정보 보호 및 보안 - 보안(세이프 브라우징 및 기타 보안 설정) - 고급 - 기기 인증서 관리(기기에서 HTTPS&#x2F;SSL 인증서 관리)</li></ul><p>인증서 가져오기 마법사가 실행하고 나서 신뢰할 수 있는 루트 인증서 기관 저장소에 사설 루트 CA 인증서를 선택하여 등록하면 된다.</p><p><img data-src="/images/posts/windows-certlm/01.png">  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;윈도우 운영체제 환경에서 사설로 만들어진 루트 CA 인증서를 컴퓨터 인증서의 신뢰할 수 있는 루트 기관으로 등록할 수 있는 방법은 두가지가 있다. 첫번째로는 MMC(certlm.msc) 프로그램의 인증서 가져오기 마법사를 이용하는 방법과 크롬 또</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>젠킨스 그리고 S3와 함께하는 배포 자동화</title>
    <link href="https://kdevkr.github.io/automated-deployment-using-s3/"/>
    <id>https://kdevkr.github.io/automated-deployment-using-s3/</id>
    <published>2023-10-09T11:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.011Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>회사 내 QA 엔지니어 퇴사로 인해 수동 배포를 수행해왔던 테스트 환경에 대해 자동화 배포로 변경하고자 학습한 내용이다. 솔루션 형태로 전달되어 고객이 직접 배포를 수행하는 프로젝트로 배포에 대한 과정도 변경사항에 포함될 수 있으므로 QA 엔지니어가 테스트 항목으로 수동 배포를 수행했다.</p></blockquote><h4 id="S3를-통한-배포-파일-다운로드-스크립트"><a href="#S3를-통한-배포-파일-다운로드-스크립트" class="headerlink" title="S3를 통한 배포 파일 다운로드 스크립트"></a>S3를 통한 배포 파일 다운로드 스크립트</h4><p>애플리케이션에 대한 릴리즈 빌드는 젠킨스 도구로 수행하며 젠킨스 서버에서 조직 내 AWS 릴리즈 버킷에 서비스 환경 폴더에 배포 파일이 저장되도록 구성되어 있다. S3 업로드하는 것은 <a href="https://plugins.jenkins.io/s3/">S3 publisher</a> 플러그인을 이용할 수 있다. </p><figure class="highlight sh"><figcaption><span>auto_deployment.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">FILE_KEY=`aws s3 <span class="built_in">ls</span> --recursive s3://app-release/japan/module/ | grep module-jp-bundle | <span class="built_in">sort</span> | <span class="built_in">tail</span> -n 1 | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>`</span><br><span class="line">FILE_NAME=`<span class="built_in">echo</span> <span class="variable">$FILE_KEY</span> | sed -e <span class="string">&quot;s/japan\/module\///&quot;</span>`</span><br><span class="line">aws s3 <span class="built_in">sync</span> s3://app-release/<span class="variable">$FILE_KEY</span> /home/ec2-user/prepare/</span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[`date --rfc-3339=seconds`] [INFO] current zip file : <span class="variable">$FILE_NAME</span>&quot;</span></span><br><span class="line"><span class="built_in">cp</span> -p /home/ec2-user/prepare/<span class="variable">$FILE_NAME</span> /home/ec2-user/prepare/backup/<span class="variable">$FILE_NAME</span></span><br><span class="line">unzip -o /home/ec2-user/prepare/<span class="variable">$FILE_NAME</span> -d /home/ec2-user/prepare/ &gt; /dev/null</span><br></pre></td></tr></table></figure><blockquote><p>젠킨스 서버에 의해 빌드 시 AWS Elastic Beanstalk 서비스에 의해 배포되는 번들과 같이 실행가능한 war 파일을 포함하여 압축 파일로 S3 버킷에 업로드 되어있다. 본 테스트 환경에서는 애플리케이션 실행 시 참조될 프로퍼티 파일은 별도로 관리하고 있다.</p></blockquote><h4 id="자동-실행을-위한-크론탭-비•활성화-스크립트"><a href="#자동-실행을-위한-크론탭-비•활성화-스크립트" class="headerlink" title="자동 실행을 위한 크론탭 비•활성화 스크립트"></a>자동 실행을 위한 크론탭 비•활성화 스크립트</h4><p>수동 배포를 수행하는 프로세스에는 예기치 않은 상황에 의해 애플리케이션 종료 시 자동으로 실행되도록 스크립트화 되어 활성화되어있는 크론탭을 비활성화하고 배포 완료 시 크론탭에 의해 동작하도록 활성화하는 방안이 필요하다. 아래의 스크립트는 <a href="https://stackoverflow.com/a/14011095">스택오버플로우 답변</a>을 참고했다.</p><figure class="highlight sh"><figcaption><span>disable_cron.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># crontab -l | sed &#x27;/^[^#].*check.sh/s/^/#/&#x27;</span></span><br><span class="line">crontab -l | sed <span class="string">&#x27;/^[^#].*check.sh/s/^/#/&#x27;</span> | crontab -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[`date --rfc-3339=seconds`] [INFO] Disable cron of check.sh&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><figcaption><span>enable_cron.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#crontab -l | sed &#x27;/^#.*check.sh/s/^#//&#x27;</span></span><br><span class="line">crontab -l | sed <span class="string">&#x27;/^#.*check.sh/s/^#//&#x27;</span> | crontab -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[`date --rfc-3339=seconds`] [INFO] Enable cron of check.sh&quot;</span></span><br></pre></td></tr></table></figure><h4 id="배포-자동화-스크립트"><a href="#배포-자동화-스크립트" class="headerlink" title="배포 자동화 스크립트"></a>배포 자동화 스크립트</h4><figure class="highlight sh"><figcaption><span>auto_deployment.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/ec2-user/</span><br><span class="line"></span><br><span class="line">OLD_FILENAME=$(<span class="built_in">ls</span> /home/ec2-user/ | grep .war | grep -v .old)</span><br><span class="line">FILENAME=$(<span class="built_in">ls</span> /home/ec2-user/prepare/ | grep .war)</span><br><span class="line">UPD_OLD=$(<span class="built_in">stat</span> -c %Y <span class="variable">$OLD_FILENAME</span>)</span><br><span class="line">UPD_NEW=$(<span class="built_in">stat</span> -c %Y /home/ec2-user/prepare/<span class="variable">$FILENAME</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[`date --rfc-3339=seconds`] [INFO] old file : <span class="variable">$OLD_FILENAME</span>(<span class="variable">$UPD_OLD</span>)&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[`date --rfc-3339=seconds`] [INFO] new file : <span class="variable">$FILENAME</span>(<span class="variable">$UPD_NEW</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UPD_NEW</span> -gt <span class="variable">$UPD_OLD</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;[`date --rfc-3339=seconds`] [INFO] Start deployment using the <span class="variable">$FILENAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 자동 실행 스크립트 비활성화</span></span><br><span class="line">  /bin/sh /home/ec2-user/disable_cron.sh</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 기존 배포 파일 백업</span></span><br><span class="line">  <span class="keyword">if</span> [ -f /home/ec2-user/<span class="variable">$OLD_FILENAME</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mv</span> /home/ec2-user/<span class="variable">$OLD_FILENAME</span> /home/ec2-user/<span class="variable">$OLD_FILENAME</span>.old</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 신규 배포 파일 복사</span></span><br><span class="line">  <span class="built_in">cp</span> /home/ec2-user/prepare/<span class="variable">$FILENAME</span> /home/ec2-user/</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 애플리케이션 종료 및 실행</span></span><br><span class="line">  sh /home/ec2-user/stop.sh</span><br><span class="line">  <span class="built_in">sleep</span> 10</span><br><span class="line">  sh /home/ec2-user/start.sh</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 자동 실행 스크립트 활성화</span></span><br><span class="line">  /bin/sh /home/ec2-user/disable_cron.sh  </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;[`date --rfc-3339=seconds`] [INFO] Deployment completed&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[`date --rfc-3339=seconds`] [WARN] There are no new deployment file&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="젠킨스-서버에서-배포-자동화-스크립트-수행"><a href="#젠킨스-서버에서-배포-자동화-스크립트-수행" class="headerlink" title="젠킨스 서버에서 배포 자동화 스크립트 수행"></a>젠킨스 서버에서 배포 자동화 스크립트 수행</h4><p>한단계 더 나아가서는 EC2 서버에서 접속해서 배포 스크립트를 실행하는 것도 젠킨스 서버에서 수행할 수 있도록 구성할 수 있다. <a href="https://plugins.jenkins.io/publish-over-ssh/">Publish over SSH</a> 플러그인을 통해 EC2 서버 접속을 위한 배스천 호스트에 SSH 연결을 수행하고 배스천 호스트에 존재하는 EC2 키 페어 파일을 통해 SSH 명령과 함께 배포 자동화 스크립트를 실행하는 명령어를 전달하면 된다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -i a.pem ec2-user@&#123;ec2-ip&#125; <span class="string">&#x27;sh /home/ec2-user/auto_deployment.sh&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>테스트 환경이라 할지라도 보안 상 관점으로 EC2 서버에 직접 접근하도록 포트를 오픈하는 것은 권장하지 않는다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;회사 내 QA 엔지니어 퇴사로 인해 수동 배포를 수행해왔던 테스트 환경에 대해 자동화 배포로 변경하고자 학습한 내용이다. 솔루션 형태로 전달되어 고객이 직접 배포를 수행하는 프로젝트로 배포에 대한 과정도 변경사항에 포함될 </summary>
      
    
    
    
    
    <category term="Jenkins" scheme="https://kdevkr.github.io/tags/Jenkins/"/>
    
    <category term="S3" scheme="https://kdevkr.github.io/tags/S3/"/>
    
  </entry>
  
  <entry>
    <title>Amazon Linux 2를 VirtualBox에서 실행하기</title>
    <link href="https://kdevkr.github.io/amazonlinux2-virtualbox/"/>
    <id>https://kdevkr.github.io/amazonlinux2-virtualbox/</id>
    <published>2023-10-04T13:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.011Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/amazon-linux-2-virtual-machine.html">Amazon Linux 2를 온프레미스 가상 머신으로 실행</a> 문서를 참고하여 Amazon Linux 2 가상 머신 이미지를 통해 온프레미스 개발 및 테스트를 위한 환경을 실행할 수 있다. 참고로 AL2을 대체하는 Amazon Linux 2023에 대해서는 <a href="https://github.com/amazonlinux/amazon-linux-2023/issues/102">아직 가상 머신 이미지를 제공하지 않는</a> 것 같다. 그래서 AL2이 2025-06-30 일자로 EOL이 되더라도 VirtualBox에서 Amazon Linux 2를 실행해보고자 한다.</p><h4 id="Amazon-Linux-2-가상-머신-이미지-다운로드"><a href="#Amazon-Linux-2-가상-머신-이미지-다운로드" class="headerlink" title="Amazon Linux 2 가상 머신 이미지 다운로드"></a>Amazon Linux 2 가상 머신 이미지 다운로드</h4><p>우분투와 같이 Amazon Linux 2에 대한 설치 파일을 제공하는 것이 아니므로 부팅을 위한 이미지와 미리 정의된 가상 머신 이미지를 다운받아야 한다.</p><ul><li><a href="https://drive.google.com/file/d/17iBVLBLLJahQDb-3kgsWRCh72hzt1FIp/view?usp=sharing">seed.iso 부팅 이미지</a>  </li><li><a href="https://cdn.amazonlinux.com/os-images/2.0.20230926.0/virtualbox/amzn2-virtualbox-2.0.20230926.0-x86_64.xfs.gpt.vdi">Amazon Linux 2 LTS 2.0.20230926.0 x86_64 VirtualBox image</a></li></ul><h4 id="가상-머신-만들기-및-실행"><a href="#가상-머신-만들기-및-실행" class="headerlink" title="가상 머신 만들기 및 실행"></a>가상 머신 만들기 및 실행</h4><p><img data-src="/images/posts/amazonlinux2-virtualbox/01.png" alt="1. 가상 머신 만들기">  </p><p>새로 만들기 버튼을 눌러 가상 머신을 만듭니다. 리눅스 유형에 대한 운영 체제 종류는 공식 문서에 나와있는대로 Red Hat (64-bit)를 선택하자. 그리고 가상 디스크는 미리 정의된 가상 머신 이미지로 추가해야 한다. 위 스크린샷에 나와있는 듯이 <a href="https://cdn.amazonlinux.com/os-images/latest/">Amazon Linux 2 가상 머신 이미지</a> 페이지에서 다운로드 받은 이미지를 선택하면 된다.</p><p><img data-src="/images/posts/amazonlinux2-virtualbox/02.png" alt="2. 부팅 이미지 디스크 추가">  </p><p>가상 머신을 실행하기 전에 호스트 이름과 사용자 계정 정의를 위한 부팅 이미지를 가상 광학 디스크에 추가해야한다. Amazon Linux 2 가상 머신 이미지 페이지에서 다운받을 수 있는 seed.iso 파일이 <code>VERR_NOT_SUPPORTED</code> 사유로 가상 광학 디스크에 추가할 수 없을 수 있는데 본 글에서 제공하는 seed.iso 부팅 이미지 링크를 통해 <code>기본 사용자(ec2-user:amazon)</code>만 정의된 파일을 다운로드할 수 있으니 참고하도록 하자.</p><p>※ 본 글에서 제공하는 seed.iso 파일은 아래와 같이 정의되어있다.</p><figure class="highlight yaml"><figcaption><span>user-data</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#cloud-config</span></span><br><span class="line"><span class="comment">#vim:syntax=yaml</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"><span class="attr">chpasswd:</span></span><br><span class="line">  <span class="attr">list:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    ec2-user:amazon</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>meta-data</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">local-hostname:</span> <span class="string">amazonlinux</span></span><br></pre></td></tr></table></figure><blockquote><p>부팅 이미지 파일은 MacOS 환경에서 hdiutil 도구를 사용하여 생성하였다.<br>$ hdiutil makehybrid -o seed.iso -hfs -joliet -iso -default-volume-name cidata seedconfig&#x2F;</p></blockquote><p><img data-src="/images/posts/amazonlinux2-virtualbox/03.png" alt="3. 사용자 계정 구성">  </p><p>가상 머신을 실행하고 맨처음 기본 사용자 계정인 ec2-user를 입력하면 사용자 계정에 대한 구성을 수행한다.</p><p><img data-src="/images/posts/amazonlinux2-virtualbox/04.png" alt="4. ec2-user 로그인">  </p><p>다시한번 로그인 화면이 출력되면 ec2-user와 amazon을 입력하면 위와 같이 Amazon Linux 2에 대한 로고를 확인할 수 있다. 처음 로그인에 성공했다면 그 이후에는 부팅 이미지가 필요하지 않다. 가상 머신을 종료하고 부팅 이미지를 가상 광학 디스크에서 제거하자.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/amazon-linux-2-virtual-machine.html&quot;&gt;Amazon Linux 2를 온프레미스 가상 머신으로 실행&lt;</summary>
      
    
    
    
    
    <category term="AL2" scheme="https://kdevkr.github.io/tags/AL2/"/>
    
    <category term="Oracle VirtualBox" scheme="https://kdevkr.github.io/tags/Oracle-VirtualBox/"/>
    
  </entry>
  
  <entry>
    <title>스프링 부트 오류 페이지</title>
    <link href="https://kdevkr.github.io/spring-boot-error-page/"/>
    <id>https://kdevkr.github.io/spring-boot-error-page/</id>
    <published>2023-10-02T03:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.019Z</updated>
    
    <content type="html"><![CDATA[<p>스프링 부트 프로젝트에서는 기본적인 오류 응답에 대한 처리와 화이트라벨 오류 페이지에 대한 자동 구성을 제공한다. 오류 처리에 대한 자동 구성은 ErrorMvcAutoConfiguration를 통해 제공하며 BasicErrorController 와 DefaultErrorViewResolver가 등록된다. </p><h4 id="Whitelabel-Error-Page"><a href="#Whitelabel-Error-Page" class="headerlink" title="Whitelabel Error Page"></a>Whitelabel Error Page</h4><p>스프링 부트의 기본 화이트라벨 오류 페이지는 ErrorMvcAutoConfiguration의 StaticView로 HTML 파일이 아닌 자바 코드로 구현되어있다. 이것은 애플리케이션 프로퍼티로 비활성화할 수 있는데 기본적으로 사용되는 내장 웹 컨테이너인 톰캣의 경우 화이트라벨 오류 페이지를 사용하지 않으면 톰캣의 오류 페이지가 응답되는 것을 확인할 수 있다.</p><blockquote><p>톰캣이 아닌 언더토우를 사용한다면 언더토우가 자체적인 오류 응답 페이지를 제공하지 않는다.  </p></blockquote><h4 id="Error-Templates"><a href="#Error-Templates" class="headerlink" title="Error Templates"></a>Error Templates</h4><p>화이트라벨 오류 페이지의 비활성화 여부와 상관없이 <code>error</code>라는 뷰를 처리하도록 템플릿 파일을 클래스패스에 추가하는 경우에는 FreeMarkerViewResolver 또는 ThymeleafViewResolver 에 의해 처리된다. ErrorTemplate가 존재하는 경우 화이트라벨 오류 페이지에 대한 빈 등록은 자동으로 비활성화된다.</p><blockquote><p>FreeMarkerViewResolver와 ThymeleafViewResolver가 동시에 존재하는 경우 프리마커와 타임리프에 대한 자동 구성 클래스의 구현 상 Order값에 의해 FreeMarkerViewResolver의 처리 순서가 더 높다.</p></blockquote><figure class="highlight plaintext"><figcaption><span>error.ftlh</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;$&#123;.lang&#125;&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Error&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Oops!&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;Error: $&#123;error&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;Path: $&#123;path&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;Status: $&#123;status&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;Timestamp: $&#123;timestamp?datetime?iso_utc&#125;&lt;/div&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Go to main&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="Error-Templates-based-HTTP-Status-Code"><a href="#Error-Templates-based-HTTP-Status-Code" class="headerlink" title="Error Templates based HTTP Status Code"></a>Error Templates based HTTP Status Code</h4><p>에러 페이지를 공통으로 처리할 수도 있고 DefaultErrorViewResolver는 error 디렉토리 하위에 HTTP Status Code 값으로 이루어진 템플릿 파일을 구성하는 경우에 더 상세하게 구분하여 처리할 수 있다. 공통 오류 페이지 내에서 템플릿 문법을 사용해도 무방하지만 명시적으로 나누어서 처리하게 하는 것도 나쁘지 않을 것이다.</p><figure class="highlight plaintext"><figcaption><span>error/404.ftlh</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;$&#123;.lang&#125;&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;404 - Not Found&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Oops! Not Found&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;Error: $&#123;error&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;Path: $&#123;path&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;Status: $&#123;status&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;Timestamp: $&#123;timestamp?datetime?iso_utc&#125;&lt;/div&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Go to main&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;스프링 부트 프로젝트에서는 기본적인 오류 응답에 대한 처리와 화이트라벨 오류 페이지에 대한 자동 구성을 제공한다. 오류 처리에 대한 자동 구성은 ErrorMvcAutoConfiguration를 통해 제공하며 BasicErrorController </summary>
      
    
    
    
    
    <category term="ThymeleafViewResolver" scheme="https://kdevkr.github.io/tags/ThymeleafViewResolver/"/>
    
    <category term="FreeMarkerViewResolver" scheme="https://kdevkr.github.io/tags/FreeMarkerViewResolver/"/>
    
    <category term="DefaultErrorViewResolver" scheme="https://kdevkr.github.io/tags/DefaultErrorViewResolver/"/>
    
    <category term="BasicErrorController" scheme="https://kdevkr.github.io/tags/BasicErrorController/"/>
    
  </entry>
  
  <entry>
    <title>Float32MLE (Byte Order)</title>
    <link href="https://kdevkr.github.io/float32mle/"/>
    <id>https://kdevkr.github.io/float32mle/</id>
    <published>2023-10-01T00:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.tcpschool.com/c/c_refer_endian">바이트 순서(Byte Order)</a>는 오래 전 컴퓨터공학과에서 배웠던 개념이지만 실무에서는 실제로 고려할 필요가 없었다.</p></blockquote><p>컴퓨터에서 데이터를 메모리에 저장할 때의 바이트 순서는 빅 엔디안과 리틀 엔디방 식으로 나누어지는데 이것은 CPU 아키텍처에 따라 나누어진다고 한다. TCP 네트워크 스펙 상에는 패킷의 바이트 순서는 빅 엔디안으로 구성되며 웹 애플리케이션에서 자주 활용되는 언어인 자바도 이를 감안하여 빅 엔디안을 기본적으로 사용한다. CPU 아키텍처와 다르게 빅 엔디안으로 사용되는 이유는 JVM 이라는 별도의 스택을 기반으로 구동되기 때문이라고 한다. 그러나, SCADA 또는 PLC 장비와 같은 일부 시스템에서는 빅 엔디안 방식이 아닌 리틀 엔디안 또는 미드 리틀 엔디안으로 바이트 순서를 구성하고 있는데 이러한 시스템은 C 언어를 기반으로 만들어지기 때문이다.</p><blockquote><p>일반적인 자바 웹 개발자들이 바이트 순서를 고려하여 비트 연산 또는 시프트 연산을 수행할 경우는 많지 않을 것 같다.</p></blockquote><h4 id="Mid-Little-Endian-MLE"><a href="#Mid-Little-Endian-MLE" class="headerlink" title="Mid Little Endian, MLE"></a>Mid Little Endian, MLE</h4><p>빅 엔디안와 리틀 엔디안 뿐만 아니라 바이트 순서를 스왑하는 미드 리틀 엔디안은 <code>AB CD</code>의 바이트 순서가 있을때 <code>CD AB</code>로 표현하는 것을 의미한다. 32비트로 구성되는 Float 형식을 미드 리틀 엔디안 방식으로 구성한 것을 <code>Float32MLE</code> 이라고 표기할 수 있다.</p><p><a href="https://baseconvert.com/ieee-754-floating-point">Base Convert: IEEE 754 Floating Point</a></p><h4 id="Float32MLE-Example"><a href="#Float32MLE-Example" class="headerlink" title="Float32MLE Example"></a>Float32MLE Example</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;Endian Test&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EndianTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;Float32 Mid Little Endian&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">TestFloat32MLE</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hexadecimal</span> <span class="operator">=</span> <span class="string">&quot;00004260&quot;</span>; <span class="comment">// 00 00 42 60</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = HexFormat.of().parseHex(hexadecimal);</span><br><span class="line">        <span class="type">float</span> <span class="variable">originValue</span> <span class="operator">=</span> PooledByteBufAllocator.DEFAULT.buffer()</span><br><span class="line">                .writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;bytes[<span class="number">2</span>], bytes[<span class="number">3</span>]&#125;) <span class="comment">// CD (42 60)</span></span><br><span class="line">                .writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;bytes[<span class="number">0</span>], bytes[<span class="number">1</span>]&#125;) <span class="comment">// AB (00 00)</span></span><br><span class="line">                .readFloat();</span><br><span class="line">        <span class="type">float</span> <span class="variable">value</span> <span class="operator">=</span> BigDecimal.valueOf(originValue)</span><br><span class="line">                .setScale(<span class="number">1</span>, RoundingMode.HALF_UP)</span><br><span class="line">                .floatValue();</span><br><span class="line">        Assertions.assertEquals(<span class="number">56.0f</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty의 ByteBuf 클래스에서는 빅 엔디안 방식의 <code>readFloat</code> 함수와 리틀 엔디안 방식의 <code>readFloatLE</code> 함수를 제공하고 있다. 그러나, 미드 리틀 엔디안 방식의 경우에는 별도로 제공하지 않으므로 위와 같이 버퍼에 <code>CD AB</code> 순으로 쓰고나서 빅 엔디안 방식으로 읽어야한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tcpschool.com/c/c_refer_endian&quot;&gt;바이트 순서(Byte Order)&lt;/a&gt;는 오래 전 컴퓨터공학과에서 배웠던 개념이지만 실무에서는 실제로 고려할 필요가 없었다.&lt;/</summary>
      
    
    
    
    
    <category term="Float32" scheme="https://kdevkr.github.io/tags/Float32/"/>
    
    <category term="IEEE 754" scheme="https://kdevkr.github.io/tags/IEEE-754/"/>
    
    <category term="Byte Order" scheme="https://kdevkr.github.io/tags/Byte-Order/"/>
    
  </entry>
  
  <entry>
    <title>MariaDB Timestamp Y2K38</title>
    <link href="https://kdevkr.github.io/mariadb-timestamp-y2k38/"/>
    <id>https://kdevkr.github.io/mariadb-timestamp-y2k38/</id>
    <published>2023-09-24T05:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<h4 id="What’s-Y2K38"><a href="#What’s-Y2K38" class="headerlink" title="What’s Y2K38 ???"></a>What’s Y2K38 ???</h4><blockquote><p>Timestamps in MariaDB have a maximum value of 2147483647, equivalent to 2038-01-19 05:14:07. This is due to the underlying 32-bit limitation. Using the function on a date beyond this will result in NULL being returned. Use DATETIME as a storage type if you require dates beyond this.</p></blockquote><p>2038년 문제는 시간을 32비트 정수형으로 표현하는 시스템에서 발생하는 문제이다. MariaDB(MySQL)은 시간을 표현하는 경우  문자열로 저장되는 DATETIME과 UTC로 저장되는 TIMESTAMP를 사용할 수 있는데 TIMESTAMP 형식은 4바이트로 저장된다. 따라서, DATETIME을 사용하는 것을 권고하는 편이며 DATETIME은 문자열로 저장되므로 DATETIME을 저장하는 시점에 UTC로 저장될 수 있도록 타임존을 UTC로 설정하는 게 좋다.</p><blockquote><p>MariaDB 타임존을 UTC가 아닌 Aisa&#x2F;Seoul로 설정하는 경우에는 SQL 조회 시 CONVERT_TZ 함수를 매번 사용해야할 필요가 있다.</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%time_zone%&#x27;</span>;</span><br><span class="line"><span class="comment">-- timezone: Asia/Seoul</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">TABLE</span> test</span><br><span class="line">(</span><br><span class="line">    id         <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">    name       <span class="type">VARCHAR</span>(<span class="number">50</span>)           <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Name&#x27;</span>,</span><br><span class="line">    created_at DATETIME              <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> now()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;mambo&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> convert_tz(created_at, <span class="string">&#x27;+09:00&#x27;</span>, <span class="string">&#x27;+00:00&#x27;</span>) <span class="keyword">AS</span> created_at <span class="keyword">FROM</span> test;</span><br><span class="line"><span class="comment">-- created_at,created_at_utc</span></span><br><span class="line"><span class="comment">-- 2023-09-24 16:36:30,2023-09-24 07:36:30</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;What’s-Y2K38&quot;&gt;&lt;a href=&quot;#What’s-Y2K38&quot; class=&quot;headerlink&quot; title=&quot;What’s Y2K38 ???&quot;&gt;&lt;/a&gt;What’s Y2K38 ???&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Timestamp</summary>
      
    
    
    
    
    <category term="MariaDB" scheme="https://kdevkr.github.io/tags/MariaDB/"/>
    
    <category term="Y2K38" scheme="https://kdevkr.github.io/tags/Y2K38/"/>
    
  </entry>
  
  <entry>
    <title>모드버스 TCP</title>
    <link href="https://kdevkr.github.io/modbus-tcp/"/>
    <id>https://kdevkr.github.io/modbus-tcp/</id>
    <published>2023-09-10T12:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<p>모드버스(Modbus) 프로토콜은 PLC와 같은 자동화 제어 설비가 포함되는 산업에서 공식적인 표준은 아니지만 거의 표준처럼 사용되고 있는 통신 프로토콜이다. 모드버스 프로토콜에 대한 스펙은 <a href="https://modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf">Modbus_Messaging_Implementation_Guide_V1_0b.pdf</a>로 공개되어있다. 본인은 에너지 분야 도메인에서 일하고 있는 개발자로 각종 에너지 관련 설비에서도 모드버스 프로토콜을 지원하는 제품을 사용하기 때문에 설비들에서 발생하는 다양한 시계열 데이터들을 수집하기 위하여 모드버스 프로토콜을 사용하고 있다. 자동화 제어의 목적이 아니므로 시리얼 통신이 아닌 SCADA, RTU, PLC와 같은 설비와 TCP&#x2F;IP 방식으로 통신한다.</p><h2 id="Modbus-TCP-IP"><a href="#Modbus-TCP-IP" class="headerlink" title="Modbus TCP&#x2F;IP"></a>Modbus TCP&#x2F;IP</h2><p>모드버스 프로토콜은 자동화 설비 산업에서 사용되기 때문에 일반적인 웹 개발자들이 경험할 수 있거나 알아야할 범용적인 통신 프로토콜은 아니다. 모드버스 TCP에서는 MBAP(MODBUS Application Protocol) 헤더와 Function Code 그리고 데이터 프레임을 하나로 전달하게 되며 일반적인 소켓 통신과 동일하다. 또한, 모드버스 프로토콜은 마스터 • 슬레이브 구조로 동작하며 마스터(클라이언트)는 슬레이브(서버)에서 정의한 메모리 맵 정보를 토대로 메모리에 저장되어있는 데이터를 읽거나 원하는 명령을 수행하도록 메모리 데이터를 변경할 수 있다.</p><h4 id="MBAP-헤더"><a href="#MBAP-헤더" class="headerlink" title="MBAP 헤더"></a>MBAP 헤더</h4><p>MBAP 헤더를 구성하는 Unit Identifier는 모드버스 TCP 에서는 IP 주소로 식별하기 때문에 Unit Identifier는 사용되지 않는 항목이지만 255(0xFF)를 사용하는 것을 추천한다. ※ <a href="https://sol.ls-electric.com/uploads/document/16419540742910/20130809_%EA%B9%80%EC%A7%80%EC%9A%A9D_iS7%20MODBUS-TCP.pdf">LS 산전의 상담품질 향상 교육 문서</a>를 참고해봐도 0xFF로 고정한다고 한다.</p><h4 id="Function-Code"><a href="#Function-Code" class="headerlink" title="Function Code"></a>Function Code</h4><p><img data-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*lOma7y90Hjtdc88d.jpg" alt="Functional codes of Modbus registers"></p><p>일반적인 측정값을 표현하는 <strong>아날로그</strong>와 0과 1로 구성되는 상태값을 표현하는 <strong>디지털</strong>로 나누어서 기능 코드를 사용한다. 주소 범위에 따라 01(0x01, Read Coil)과 02(0x02, Read Discrete Inputs)를 사용하며 아날로그는 주로 03(0x03, Read Holding Registers)를 사용하는 편이다. ※ 기능 코드표를 살펴보면 02(0x02, REad Discrete Inputs)와 04(0x04, Read Input Registers)는 읽기만 수행하는 메모리 범위에서 사용하게 된다는 것을 알아챌 수 있다.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>네티 기반의 <a href="https://github.com/digitalpetri/modbus">digitalpetri&#x2F;modbus</a> 라이브러리가 있으나 <a href="https://github.com/steveohara/j2mod">steveohara&#x2F;j2mod</a>라는 자바 라이브러리를 통해 모드버스 TCP 통신을 구현하는게 간단할 것 같다. 다음의 코드는 간단하게 슬레이브에 모드버스 맵을 이미지로 정의하고 마스터에서 정의된 모드버스 맵에 대해서 읽어보는 샘플이다.</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.ghgande:j2mod:3.1.1&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModbusTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TCP_UNIT_ID</span> <span class="operator">=</span> <span class="number">255</span>; <span class="comment">// 0xFF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultProcessImageFactory</span> <span class="variable">imageFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultProcessImageFactory</span>();</span><br><span class="line">        <span class="type">ProcessImageImplementation</span> <span class="variable">memoryMap</span> <span class="operator">=</span> imageFactory.createProcessImageImplementation();</span><br><span class="line"></span><br><span class="line">        memoryMap.addDigitalOut(imageFactory.createDigitalOut(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ObservableRegister</span> <span class="variable">register</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObservableRegister</span>();</span><br><span class="line">        register.setValue(<span class="number">1024</span>);</span><br><span class="line">        memoryMap.addRegister(register);</span><br><span class="line"></span><br><span class="line">        <span class="type">ModbusSlave</span> <span class="variable">tcpSlave</span> <span class="operator">=</span> ModbusSlaveFactory.createTCPSlave(Modbus.DEFAULT_PORT, <span class="number">5</span>, <span class="literal">false</span>);</span><br><span class="line">        tcpSlave.addProcessImage(TCP_UNIT_ID, memoryMap);</span><br><span class="line">        tcpSlave.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ModbusTCPMaster</span> <span class="variable">modbusTCPMaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModbusTCPMaster</span>(<span class="string">&quot;127.0.0.1&quot;</span>, Modbus.DEFAULT_PORT);</span><br><span class="line">        modbusTCPMaster.connect();</span><br><span class="line">        <span class="keyword">if</span> (modbusTCPMaster.isConnected()) &#123;</span><br><span class="line">            <span class="type">BitVector</span> <span class="variable">bitVector</span> <span class="operator">=</span> modbusTCPMaster.readCoils(TCP_UNIT_ID, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="type">boolean</span>[] bools = <span class="keyword">new</span> <span class="title class_">boolean</span>[bitVector.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bitVector.size(); i++) &#123;</span><br><span class="line">                bools[i] = bitVector.getBit(i);</span><br><span class="line">            &#125;</span><br><span class="line">            Register[] registers = modbusTCPMaster.readMultipleRegisters(TCP_UNIT_ID, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;booleans, &#123;&#125;&quot;</span>, bools);</span><br><span class="line">            log.info(<span class="string">&quot;registers, &#123;&#125;&quot;</span>, registers);</span><br><span class="line">            modbusTCPMaster.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ModbusSlaveFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>슬레이브 이미지 구성 시 10001-20000은 DigitalIn를 사용하며 30001-40000은 InputRegister로 만들 수 있다. 읽기 뿐만 아니라 쓰기도 가능한 DigitalOut과 Register에 대해서는 슬레이브에서 변경에 대해 감지할 수 있는 ObservableDigitalOut과 ObservableRegister를 제공한다.</p></blockquote><h4 id="PLC-Simulator"><a href="#PLC-Simulator" class="headerlink" title="PLC Simulator"></a>PLC Simulator</h4><p><a href="https://sourceforge.net/projects/modrssim2/">ModRSsim2</a> 프로그램을 통해 TCP&#x2F;IP 기반의 PLC 슬레이브에 대한 시뮬레이터를 실행할 수 있다. 위 코드에서 슬레이브 메모리 맵 정보를 만들기보다 시뮬레이터 프로그램으로 메모리 데이터를 쉽게 정의하고 모드버스 마스터인 클라이언트 로직 구현에 집중할 수 있을 것이다. </p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf">MODBUS Messaging on TCP&#x2F;IP Implementation Guide V1.0b</a></li><li><a href="https://www.youtube.com/watch?v=eb8iophBMLs">모드버스 프로토콜 11부 - 모드버스 TCP(더 넓은 세상으로)</a></li><li><a href="https://www.youtube.com/watch?v=ImVbnyqAqX4">[모드버스 핸드북] 09강 모드버스 TCP 통신 예제</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;모드버스(Modbus) 프로토콜은 PLC와 같은 자동화 제어 설비가 포함되는 산업에서 공식적인 표준은 아니지만 거의 표준처럼 사용되고 있는 통신 프로토콜이다. 모드버스 프로토콜에 대한 스펙은 &lt;a href=&quot;https://modbus.org/do</summary>
      
    
    
    
    
    <category term="Modbus" scheme="https://kdevkr.github.io/tags/Modbus/"/>
    
    <category term="TCP/IP" scheme="https://kdevkr.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 3.x Micrometer Tracing</title>
    <link href="https://kdevkr.github.io/spring-boot-3-tracing/"/>
    <id>https://kdevkr.github.io/spring-boot-3-tracing/</id>
    <published>2023-08-27T00:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring Cloud Sleuth will not work with Spring Boot 3.x onward. Please check <a href="https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide">Spring Cloud Sleuth 3.1 Migration Guide</a>.</p></blockquote><p>Spring Cloud Sleuth 프로젝트는 더이상 Spring Boot 3.x 와의 호환성을 지원하지 않는다. 분산 추적 데이터 모델을 적용하기 위한 자동 구성이 Spring Cloud Sleuth 에서 Spring Boot로 이동되어있기 때문이다. Spring Boot 3.x 에서는 더이상 Spring Cloud Sleuth는 필요하지 않으며 <code>Micrometer Tracing</code>에 대한 설정을 수행하면 된다.</p><figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;3.1.3&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.1.3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;io.micrometer:micrometer-tracing-bridge-brave&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;io.zipkin.reporter2:zipkin-reporter-brave&#x27;</span></span><br><span class="line">    developmentOnly <span class="string">&#x27;org.springframework.boot:spring-boot-docker-compose&#x27;</span> <span class="comment">// Optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AutoConfigure-Micrometer-Tracing"><a href="#AutoConfigure-Micrometer-Tracing" class="headerlink" title="AutoConfigure Micrometer Tracing"></a>AutoConfigure Micrometer Tracing</h4><p>스프링 부트 자동 구성에 포함되어 있는 BraveAutoConfiguration과 ZipkinAutoConfiguration가 자동으로 적용되므로 아래와 같이 TracingProperties 속성을 원하는대로 적용하면 된다. 본 글에서는 Zipkin과의 연동을 위해서 기본적으로 사용되는 B3 방식을 지정하였다.</p><figure class="highlight yaml"><figcaption><span>application.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">management.tracing:</span></span><br><span class="line">  <span class="attr">propagation.type:</span> <span class="string">b3</span></span><br><span class="line">  <span class="attr">sampling.probability:</span> <span class="number">1.0</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">logging.pattern.level:</span> <span class="string">&quot;%5p [$&#123;spring.application.name:&#125;,%X&#123;traceId:-&#125;,%X&#123;spanId:-&#125;]&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Automatic-Context-Propagation-for-WebFlux"><a href="#Automatic-Context-Propagation-for-WebFlux" class="headerlink" title="Automatic Context Propagation for WebFlux"></a>Automatic Context Propagation for WebFlux</h4><p>Spring Cloud Gateway와 같이 WebFlux 기반으로 동작하는 애플리케이션에서는 Project Reactor 3의 Context Propagation에 대한 자동 구성을 위해서 아래와 같이 Hooks.enableAutomaticContextPropagation을 메인 함수에서 호출해야한다. 더 자세한 내용은 <a href="https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive">Context Propagation with Project Reactor 3 - Unified Bridging between Reactive and Imperative</a>를 참고하면 된다.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Hooks;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">        Hooks.enableAutomaticContextPropagation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Sleuth will not work with Spring Boot 3.x onward. Please check &lt;a href=&quot;https://github.com/micrometer-metrics/t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>보안 취약점 (Vulnerability)</title>
    <link href="https://kdevkr.github.io/vulnerabilities/"/>
    <id>https://kdevkr.github.io/vulnerabilities/</id>
    <published>2023-08-22T12:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.019Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/advisories?query=type:reviewed+ecosystem:maven">Github Advisory Database</a>에는 Maven에 대해 약 3800개의 취약점 정보가 있다. 회사에서 서비스 모니터링을 위한 시스템이 구축되어있지는 않지만 임시적으로 뉴렐릭을 적용한 환경이 있어 APM &amp; Services의 Vulnerability Management 메뉴에서 보안 취약점 정보를 확인할 수 있었다. 우선 체크된 보안 취약점은 58개로 CRITICAL 6개, HIGH 25개, MEDIUM 21개, LOW 6개 이다.</p><h4 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h4><table><thead><tr><th>name</th><th>severity</th><th>exploitable</th><th>issueId</th></tr></thead><tbody><tr><td>Pivotal Spring Framework contains unsafe Java deserialization methods</td><td>CRITICAL</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-4wrc-f8pq-fpqp">CVE-2016-1000027</a></td></tr><tr><td>Deserialization of Untrusted Data in org.codehaus.jackson:jackson-mapper-asl</td><td>CRITICAL</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-c27h-mcmw-48hv">CVE-2019-10202</a></td></tr><tr><td>Template injection in thymeleaf-spring5</td><td>CRITICAL</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-qcj6-jqrg-4wp2">CVE-2021-43466</a></td></tr><tr><td>Remote Code Execution in Spring Framework</td><td>CRITICAL</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-36p3-wjmg-h94x">CVE-2022-22965</a></td></tr><tr><td>Undertow client not checking server identity presented by server certificate in https connections</td><td>CRITICAL</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-pfcc-3g6r-8rg8">CVE-2022-4492</a></td></tr><tr><td>Spring Boot Security Bypass with Wildcard Pattern Matching on Cloud Foundry</td><td>CRITICAL</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-g5h3-w546-pj7f">CVE-2023-20873</a></td></tr></tbody></table><details><summary>More</summary><table><thead><tr><th>name</th><th>severity</th><th>exploitable</th><th>issueId</th></tr></thead><tbody><tr><td>Pivotal Spring Framework contains unsafe Java deserialization methods</td><td>CRITICAL</td><td>FALSE</td><td>CVE-2016-1000027</td></tr><tr><td>Deserialization of Untrusted Data in org.codehaus.jackson:jackson-mapper-asl</td><td>CRITICAL</td><td>FALSE</td><td>CVE-2019-10202</td></tr><tr><td>Template injection in thymeleaf-spring5</td><td>CRITICAL</td><td>FALSE</td><td>CVE-2021-43466</td></tr><tr><td>Remote Code Execution in Spring Framework</td><td>CRITICAL</td><td>FALSE</td><td>CVE-2022-22965</td></tr><tr><td>Undertow client not checking server identity presented by server certificate in https connections</td><td>CRITICAL</td><td>FALSE</td><td>CVE-2022-4492</td></tr><tr><td>Spring Boot Security Bypass with Wildcard Pattern Matching on Cloud Foundry</td><td>CRITICAL</td><td>FALSE</td><td>CVE-2023-20873</td></tr><tr><td>Arbitrary code execution in Apache Commons BeanUtils</td><td>HIGH</td><td>FALSE</td><td>CVE-2014-0114</td></tr><tr><td>Insecure Deserialization in Apache Commons Beanutils</td><td>HIGH</td><td>FALSE</td><td>CVE-2019-10086</td></tr><tr><td>Improper Restriction of XML External Entity Reference in jackson-mapper-asl</td><td>HIGH</td><td>FALSE</td><td>CVE-2019-10172</td></tr><tr><td>Deeply nested json in jackson-databind</td><td>HIGH</td><td>FALSE</td><td>CVE-2020-36518</td></tr><tr><td>Undertow Uncontrolled Resource Consumption</td><td>HIGH</td><td>FALSE</td><td>CVE-2021-3629</td></tr><tr><td>Uncaught Exception in jsoup</td><td>HIGH</td><td>FALSE</td><td>CVE-2021-37714</td></tr><tr><td>Undertow vulnerable to Denial of Service (DoS) attacks</td><td>HIGH</td><td>FALSE</td><td>CVE-2021-3859</td></tr><tr><td>jackson-databind possible Denial of Service if using JDK serialization to serialize JsonNode</td><td>HIGH</td><td>FALSE</td><td>CVE-2021-46877</td></tr><tr><td>SnakeYaml Constructor Deserialization Remote Code Execution</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-1471</td></tr><tr><td>Undertow vulnerable to Dos via Large AJP request</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-2053</td></tr><tr><td>pgjdbc Does Not Check Class Instantiation when providing Plugin Classes</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-21724</td></tr><tr><td>Improper handling of case sensitivity in Spring Framework</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-22968</td></tr><tr><td>Denial of service in Spring Framework</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-22970</td></tr><tr><td>Deserialization of Untrusted Data in Gson</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-25647</td></tr><tr><td>Uncontrolled Resource Consumption in snakeyaml</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-25857</td></tr><tr><td>Partial Path Traversal in com.amazonaws:aws-java-sdk-s3</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-31159</td></tr><tr><td>PostgreSQL JDBC Driver SQL Injection in ResultSet.refreshRow() with malicious column names</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-31197</td></tr><tr><td>Apache Xalan Java XSLT library integer truncation issue when processing malicious XSLT stylesheets</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-34169</td></tr><tr><td>Denial of Service due to parser crash</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-40153</td></tr><tr><td>Uncontrolled Resource Consumption in Jackson-databind</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-42003</td></tr><tr><td>Uncontrolled Resource Consumption in FasterXML jackson-databind</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-42004</td></tr><tr><td>json stack overflow vulnerability</td><td>HIGH</td><td>FALSE</td><td>CVE-2022-45688</td></tr><tr><td>json-smart Uncontrolled Recursion vulnerabilty</td><td>HIGH</td><td>FALSE</td><td>CVE-2023-1370</td></tr><tr><td>Spring Framework vulnerable to denial of service</td><td>HIGH</td><td>FALSE</td><td>CVE-2023-20863</td></tr><tr><td>Spring Boot Welcome Page Denial of Service</td><td>HIGH</td><td>FALSE</td><td>CVE-2023-20883</td></tr><tr><td>Uncontrolled Resource Consumption in XNIO</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2020-14340</td></tr><tr><td>Improper privilege management in elasticsearch</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2020-7019</td></tr><tr><td>Log entry injection in Spring Framework</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2021-22060</td></tr><tr><td>Improper Output Neutralization for Logs in Spring Framework</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2021-22096</td></tr><tr><td>Exposure of Sensitive Information to an Unauthorized Actor</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2021-22134</td></tr><tr><td>API information disclosure flaw in Elasticsearch</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2021-22135</td></tr><tr><td>Denial of Service in Elasticsearch</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2021-22144</td></tr><tr><td>undertow Race Condition vulnerability</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2021-3597</td></tr><tr><td>Allocation of Resources Without Limits or Throttling in Spring Framework</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-22950</td></tr><tr><td>Allocation of Resources Without Limits or Throttling in Spring Framework</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-22971</td></tr><tr><td>jsoup may not sanitize code injection XSS attempts if SafeList.preserveRelativeLinks is enabled</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-36033</td></tr><tr><td>snakeYAML before 1.31 vulnerable to Denial of Service due to Out-of-bounds Write</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-38749</td></tr><tr><td>snakeYAML before 1.31 vulnerable to Denial of Service due to Out-of-bounds Write</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-38750</td></tr><tr><td>snakeYAML before 1.31 vulnerable to Denial of Service due to Out-of-bounds Write</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-38751</td></tr><tr><td>snakeYAML before 1.32 vulnerable to Denial of Service due to Out-of-bounds Write</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-38752</td></tr><tr><td>Denial of Service due to parser crash</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-40152</td></tr><tr><td>Snakeyaml vulnerable to Stack overflow leading to denial of service</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-41854</td></tr><tr><td>TemporaryFolder on unix-like systems does not limit access to created files</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2022-41946</td></tr><tr><td>Spring Framework vulnerable to denial of service via specially crafted SpEL expression</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2023-20861</td></tr><tr><td>Guava vulnerable to insecure use of temporary directory</td><td>MEDIUM</td><td>FALSE</td><td>CVE-2023-2976</td></tr><tr><td>pgjdbc Arbitrary File Write Vulnerability</td><td>MEDIUM</td><td>FALSE</td><td>GHSA-673j-qm5f-xpv8</td></tr><tr><td>Privilege Context Switching Error in Elasticsearch</td><td>LOW</td><td>FALSE</td><td>CVE-2020-7020</td></tr><tr><td>Information Disclosure in Guava</td><td>LOW</td><td>FALSE</td><td>CVE-2020-8908</td></tr><tr><td>Path traversal in org.postgresql:postgresql</td><td>LOW</td><td>FALSE</td><td>CVE-2022-26520</td></tr><tr><td>Denial of Service via stack overflow</td><td>LOW</td><td>FALSE</td><td>CVE-2022-40154</td></tr><tr><td>Denial of Service via stack overflow</td><td>LOW</td><td>FALSE</td><td>CVE-2022-40155</td></tr><tr><td>Denial of Service due to parser crash</td><td>LOW</td><td>FALSE</td><td>CVE-2022-40156</td></tr></tbody></table></details><h4 id="CRITICAL-Vulnerability"><a href="#CRITICAL-Vulnerability" class="headerlink" title="CRITICAL Vulnerability"></a>CRITICAL Vulnerability</h4><p>위 CRITICAL 레벨의 보안 취약점 중에서 <a href="https://github.com/advisories/GHSA-c27h-mcmw-48hv">CVE-2019-10202</a>를 제외하고는 취약점 대상이 되는 시스템 환경은 아니기 때문에 굳이 애플리케이션에서 사용중인 라이브러리 의존성 버전을 변경할 필요는 없다고 생각된다. CVE-2019-10202에 대해서는 애플리케이션에서 org.codehaus.jackson:jackson-mapper-asl 라이브러리를 사용할 필요가 없음에도 일부 코드가 레거시 프로젝트로부터 복사되었기 때문에 jackson-databind 라이브러리에 포함된 ISO8601Utils를 사용하도록 코드를 변경하고 불필요한 jackson-mapper-asl 의존성을 제거하였다. </p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    set(<span class="string">&#x27;quartz.version&#x27;</span>, <span class="string">&#x27;2.3.2&#x27;</span>) <span class="comment">// CVE-2019-13990</span></span><br><span class="line">    set(<span class="string">&#x27;thymeleaf.version&#x27;</span>, <span class="string">&#x27;3.0.13.RELEASE&#x27;</span>) <span class="comment">// CVE-2021-43466</span></span><br><span class="line">    set(<span class="string">&#x27;spring-framework.version&#x27;</span>, <span class="string">&#x27;5.2.24.RELEASE&#x27;</span>) <span class="comment">// CVE-2022-22965</span></span><br><span class="line">    set(<span class="string">&#x27;undertow.version&#x27;</span>, <span class="string">&#x27;2.2.24.Final&#x27;</span>) <span class="comment">// CVE-2022-4492]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>나머지 CRITICAL 레벨이 아닌 취약점은 굳이 조치할 필요성이 높지는 않아보이나 최대한 취약점을 제거하고자 분석 후 Github Advisory Database를 통해 취약점이 조치된 버전으로 변경하였다.</p><h4 id="Vulnerability-1"><a href="#Vulnerability-1" class="headerlink" title="Vulnerability"></a>Vulnerability</h4><p>취약점 조치 이후에 체크되어 남아있는 취약점은 아래와 같다. </p><table><thead><tr><th>name</th><th>severity</th><th>exploitable</th><th>issueId</th></tr></thead><tbody><tr><td>Pivotal Spring Framework contains unsafe Java deserialization methods</td><td>CRITICAL</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-4wrc-f8pq-fpqp">CVE-2016-1000027</a></td></tr><tr><td>Spring Boot Security Bypass with Wildcard Pattern Matching on Cloud Foundry</td><td>CRITICAL</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-g5h3-w546-pj7f">CVE-2023-20873</a></td></tr><tr><td>SnakeYaml Constructor Deserialization Remote Code Execution</td><td>HIGH</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-mjmj-j48q-9wg2">CVE-2022-1471</a></td></tr><tr><td>Spring Boot Welcome Page Denial of Service</td><td>HIGH</td><td>FALSE</td><td><a href="https://github.com/advisories/GHSA-xf96-w227-r7c4">CVE-2023-20883</a></td></tr></tbody></table><p>CRITICAL 레벨의 CVE-2016-1000027와 CVE-2023-20873 도 취약점 내용을 살펴보면 취약점이 발생할 수 있는 시스템 환경이 아니기 때문에 굳이 조치할 필요가 없다. 더구나 취약점 정보를 제거하기 위해서는 상당히 높은 스프링 부트 3+으로 변경해야하기 때문에 굳이 시도하지 않으려고 한다. </p><p>CVE-2022-1471에 대해서는 스프링 부트 2.5.15 에서 <a href="https://github.com/spring-projects/spring-boot/commit/d1d990acd7a06aa34112896d753bcae679203f35">Improve compatibility with SnakeYAML 2.0</a> 처리가 되었기 때문에 Snakeyaml 라이브러리의 버전만 2.0+로 변경하면 되지만 스프링 부트 2.4+로 변경하는 것도 생각보다 많은 설정들이 변경되어서 쉽지 않다. 만약, 스프링 부트 2.5.15로 변경한다면 <a href="https://github.com/advisories/GHSA-xf96-w227-r7c4">CVE-2023-20883</a>도 함께 조치할 수 있다.</p><p>이렇게 취약점 제거 조치는 수행했으나 실제로 반영하는 것은 조심해야한다. 라이브러리 버전 변경으로 인한 시스템 영향도를 제대로 체크한다는 것을 보장할 순 없기 때문에 한번에 수정하는 것은 지양해야할 수 있다. 앞서, jackson-databind 라이브러리를 2.11.4 에서 상위 버전으로 업그레이드하는 과정에서 아래와 같은 직렬화 이슈가 발생하였다.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Caused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Java 8 date/time type `java.time.Instant` not supported by default: add Module &quot;com.fasterxml.jackson.datatype:jackson-datatype-jsr310&quot; to enable handling (through reference chain: java.util.Collections$UnmodifiableMap[&quot;build&quot;]-&gt;java.util.LinkedHashMap[&quot;time&quot;])</span><br></pre></td></tr></table></figure><p>이와 같은 이슈를 해결하기 위해서 ObjectMapper를 만들어서 사용하는 모든 코드에 JavaTimeModule을 수동으로 등록하도록 변경해야한다.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">objectMapper.registerModule(<span class="keyword">new</span> <span class="title class_">JavaTimeModule</span>());</span><br></pre></td></tr></table></figure><p>인텔리제이를 통해 검색해보니 생각보다 건드려야하는 코드가 많아서 jackson-databind 라이브러리를 상위 버전으로 변경하지 않고 2.11.4를 유지하고자 한다.</p><h4 id="OWASP-Dependency-Check"><a href="#OWASP-Dependency-Check" class="headerlink" title="OWASP Dependency-Check"></a>OWASP Dependency-Check</h4><p><a href="https://owasp.org/www-project-dependency-check/">OWASP Dependency-Check</a>라는 SCA 도구를 사용해서 CPE와 CVE를 검출할 수 있다. 아래와 같이 dependencycheck 그래들 플러그인을 등록하고나서 dependencyCheckAnalyze 태스크를 수행하면 <code>build/reports/dependency-check-report.html</code> 파일이 생성되어 취약점 정보를 확인할 수 있다.</p><figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.owasp.dependencycheck&#x27;</span> version <span class="string">&#x27;8.4.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyCheck &#123;</span><br><span class="line">    <span class="comment">// build/reports/dependency-check-report.html</span></span><br><span class="line">    analyzers &#123;</span><br><span class="line">        nodeEnabled = <span class="literal">false</span></span><br><span class="line">        nodeAudit &#123;</span><br><span class="line">            enabled = <span class="literal">false</span></span><br><span class="line">            yarnEnabled = <span class="literal">false</span></span><br><span class="line">            pnpmEnabled = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://plugins.jenkins.io/dependency-check-jenkins-plugin/">젠킨스 OWASP Dependency-Check 플러그인</a>도 있는데 OWASP Dependency-Check로 체크하는 경우 생각보다 많은 취약점이 확인되어서 최신 라이브러리를 사용하는 프로젝트가 아니라면 좋아보이지는 않는다. 개인적으로 CVE 검출을 위해서 사용하진 않을 것 같다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/advisories?query=type:reviewed+ecosystem:maven&quot;&gt;Github Advisory Database&lt;/a&gt;에는 Maven에 대해 약 3800개의 취약점 정보가 있다.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>기록보다 더 중요한 것</title>
    <link href="https://kdevkr.github.io/more-important-than-blogging/"/>
    <id>https://kdevkr.github.io/more-important-than-blogging/</id>
    <published>2023-08-08T11:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<p>신입 개발자 인터뷰 과정에서 배우게 된 건 <strong>기록보다 중요한 것은 다시 되돌아보는 행위</strong>인 것 같다.</p><p>신입 개발자 이력서를 검토하다보면 경력 개발자와 다르게 기술 블로그를 필수로 첨부하거나 <strong>기억보다 기록을</strong> 어필하는 분들이 상당히 많다고 느낀다. 이렇게 신입 개발자들에게 기술 블로그가 거의 필수가 된 이유는 꾸준하게 블로그에 자신의 생각이나 경험한 것들을 기록하는 유튜브 개발바닥의 향로님의 영향이 클 것 같다고 생각된다.</p><p>아무튼 신입 개발자 인터뷰 과정에서 기술 블로그에 있는 내용을 토대로 물어보게 되면 답변을 못하는 경우가 생각보다 많다. 아무래도 당장 배워야할 것이 많고 잊어버리거나 우선순위에 밀려서 신경쓰지 않던 지식들이기 때문일 것 같다. 국비지원이나 부트캠프에서 많은 걸을 배웠다고 생각하지만 짧은 기간으로 인해 생략하고 넘어간 기본적으로 알아야할 지식들도 많다.</p><p>개인적으로 솔직하게 신입 개발자들에게 물어볼만한 것들은 이미 인터넷에 신입 개발자 질문 리스트라며 문제 은행식으로 꽤나 많이 공유되어 있다. 그래서 지원자마다 다르게 물어보게 되는 건 <strong>블로그에 있는 내용을 토대로 얼마나 더 찾아보고 이해했는가</strong> 이다.</p><p>최소한 면접을 보기 전에 <strong>자신이 작성했던 내용을 다시 살펴보는 게 중요</strong>할 것 같다. 현재 진행하고 있는 채용에서 인터뷰 과정을 되돌아보았을 때 자세히 답변을 하지 못하더라도 지식에 대한 키워드를 들어본 듯한 반응이 있는 것과 전혀 알아채지 못하는 건 확실하게 느낌이 다르다.</p><p>나도 이 블로그에 작성했던 것들을 자주 되돌아보아야 겠다. 🙄</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;신입 개발자 인터뷰 과정에서 배우게 된 건 &lt;strong&gt;기록보다 중요한 것은 다시 되돌아보는 행위&lt;/strong&gt;인 것 같다.&lt;/p&gt;
&lt;p&gt;신입 개발자 이력서를 검토하다보면 경력 개발자와 다르게 기술 블로그를 필수로 첨부하거나 &lt;strong&gt;기</summary>
      
    
    
    
    
    <category term="개발자 인터뷰" scheme="https://kdevkr.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0/"/>
    
    <category term="기술 블로그" scheme="https://kdevkr.github.io/tags/%EA%B8%B0%EC%88%A0-%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
  </entry>
  
  <entry>
    <title>시니어 개발자로 성장하기 위한 역량</title>
    <link href="https://kdevkr.github.io/hexagonal-developer/"/>
    <id>https://kdevkr.github.io/hexagonal-developer/</id>
    <published>2023-08-06T12:00:00.000Z</published>
    <updated>2023-12-02T14:52:11.015Z</updated>
    
    <content type="html"><![CDATA[<p>오늘은 회사에서 구매 신청한 최범균님이 글을 쓰신 <code>육각형 개발자</code>라는 책을 읽어보았다. 이제는 시니어 개발자로서의 역량을 성장시켜야하는 리더로써의 역할을 수행하고 있기 때문에 좋은 시니어 개발자가 가지는 역량에 대해서 스스로 정리해보기 위해서 내 기준에서 어떤 것에 대한 역량을 키워나가야하는지 살펴보고자 한다.</p><h4 id="요구사항-분석-및-설계의-역량"><a href="#요구사항-분석-및-설계의-역량" class="headerlink" title="요구사항 분석 및 설계의 역량"></a>요구사항 분석 및 설계의 역량</h4><p>개발 리더로써 가장 중요한 역량은 개발팀 인원들이 보다 정확하게 혹은 효율적으로 요구사항을 처리할 수 있도록 최대한 자세하세 요구사항과 배경에 대해서 분석하고 작업에 대한 방향성을 설계해야 한다. 요구사항을 전달하는 입장에서 스스로 요약하기 위해서 생략하는 배경으로 인하여 잘못된 방향으로 분석하고 실무자 입장에서는 다시 한번 체크하더라도 거의 완성되고 나서야 다시 작업해야하는 것을 아는 경우도 많을 수 밖에 없다. 비록 그런 사항을 만들지 않는 것이 좋겠지만 최대한 그러지 않도록 요구사항에 대해 의심하고 여러번 체크하는 습관이 필요할 것 같다.</p><h4 id="문서화에-대한-역량"><a href="#문서화에-대한-역량" class="headerlink" title="문서화에 대한 역량"></a>문서화에 대한 역량</h4><p>그동안 문서화에 소홀했던 조직에서 일해왔기 때문에 문서화에 대한 중요성은 알고 있어도 회사의 스타일에 따라 문서화나 작업 내용에 대해 정리하는 것을 생략해왔다. 앞선, 요구사항을 제대로 분석하고 제대로 전달하기 위해서는 문서화에 대한 역량을 키워야만 한다. 평소에 말수가 적어서 말하고자 하는 내용을 전달하기도 어려워하기 때문에 제대로 커뮤니케이션이 되기 위해서는 정확한 문서를 전달할 필요가 있기 때문이다. 문서화에 대한 역량을 더 향상시키기 위해서 개인 블로그에 글을 써서 나의 생각을 정리하는 것을 지속적으로 유지해야할 것 같다.</p><h4 id="기본-지식에-대한-역량"><a href="#기본-지식에-대한-역량" class="headerlink" title="기본 지식에 대한 역량"></a>기본 지식에 대한 역량</h4><p>현재 사용중인 기술에 대해서는 코드를 이해하고 수정할 수 있을 정도의 지식이 필요하고 문제를 해결하기 위한 기술을 선택하기 위해서 조직에서 사용하지 않는 기술이라고 하더라도 평소에 기술 구현에 대해 학습해야한다. 더 나아가서는 해당 기술에서 필요한 기본 지식에 대해서 깊이 살펴보는 것도 필요하다. 현재 기준에서 적합한 더 나은 방법을 찾으려고 노력해야하기 때문이다. </p><h4 id="테스트에-대한-역량"><a href="#테스트에-대한-역량" class="headerlink" title="테스트에 대한 역량"></a>테스트에 대한 역량</h4><p>현재 조직은 전반적인 테스트는 QA 엔지니어의 역할이라고 생각하고 있지만 최소한의 테스트는 개발자에 대한 역량이라고 생각된다. 테스트 코드 작성을 강제하지 않는 조직이기 때문에 테스트에 대한 역량은 개발자 스스로 쌓고 습관화해야만 한다. 또한, 테스트 코드를 작성하다보면 당장 테스트하는 조건을 통과하기 위한 로직에 대해서만 검증하고 넘어가는 경우가 많은 것 같다. 그리고 모든 것에 대해 테스트 코드를 작성하지 않게 되므로 때로는 간단한 수정의 경우 별다른 영향도 체크가 발생하지 않을 것이라 가정하고 반영하게 된다.</p><p>신입 개발자의 인터뷰 과정에서 기본 지식에 대해서 중요하게 생각하여 체크하게 되는 것처럼 주니어 개발자에서 시니어 개발자로 성장하면서 그동안 알고 있던 기본 지식을 더 깊게 되돌아보는 것이 필요하다고 느낀다. 이것은 주니어 개발자들이 작성한 코드를 리뷰하면서 다양한 관점에서 바라보고 의견을 제시하게 되면서 중요하다고 생각하고 있다. 결국 제대로 리뷰할 수 있는 리뷰어가 되기 위해서는 개발 역량 뿐만 아니라 다양한 역량을 채워야하는 것 같다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;오늘은 회사에서 구매 신청한 최범균님이 글을 쓰신 &lt;code&gt;육각형 개발자&lt;/code&gt;라는 책을 읽어보았다. 이제는 시니어 개발자로서의 역량을 성장시켜야하는 리더로써의 역할을 수행하고 있기 때문에 좋은 시니어 개발자가 가지는 역량에 대해서 스스로</summary>
      
    
    
    
    
    <category term="시니어 개발자" scheme="https://kdevkr.github.io/tags/%EC%8B%9C%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90/"/>
    
    <category term="육각형 개발자" scheme="https://kdevkr.github.io/tags/%EC%9C%A1%EA%B0%81%ED%98%95-%EA%B0%9C%EB%B0%9C%EC%9E%90/"/>
    
  </entry>
  
</feed>
