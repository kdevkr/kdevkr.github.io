---
title: KDB+
# date: 2021-09-23
date: 2021-08-28
tags:
- KDB+
- Q
---

> 본 글은 회사에서 15일간 제공하는 학습휴가를 진행하고나서 작성된 것입니다.

안녕하세요 Mambo 입니다.

오늘은 국내 개발자들에게는 생소한 시계열 데이터베이스인 **KDB+** 에 대해 이야기 해보려고 해요. 처음 들어보셨다구요? 네 저도 회사에서 쓰자고 할때까지는 존재조차 모르고 있었습니다. 저와 함께 KDB+에 대해서 알아보시죠.

## KDB+
KDB+는 KX 시스템즈에서 만든 시계열 데이터베이스로 [DB Engins](https://db-engines.com/en/ranking/time+series+dbms)에서 상위에 랭크하고 있습니다. 다만, 오픈 소스 시계열 데이터베이스인 InfluxDB가 있기 때문에 상용 데이터베이스인 KDB+을 굳이 사용할 필요는 없겠죠. 그럼 저희 개발팀에서는 왜 KDB+를 쓰기로 했던걸까요.

가장 큰 이유는 초당 수천만건의 데이터를 처리할 수 있는 가장 빠른 시계열 데이터베이스이기 때문입니다. 그에 반해 오픈 소스 시계열 데이터베이스인 InfluxDB의 성능은 상당히 좋지 않습니다. 

![Kdb+ Transitive Comparisons](../images/posts/kdb+-01.png)

위 벤치마크에서 보여주듯이 KX는 KDB+를 세계에서 가장 빠른 시계열 데이터베이스라고 강조합니다. 개인적으로 InfluxDB를 사용해보진 않았기 때문에 제가 비교할 순 없으니 더 자세한 비교 내용은 [Kdb+ Transitive Comparisons](https://kx.com/wp-content/uploads/2020/11/KdbTransitive-Comparisons-1.pdf)을 참고해주세요.

### 국내에서 쓰고는 있을까?
구글에 KDB+ 관련 글을 찾아보면 그대안의 작은 호수님이 작성하신 [KDB+를 금융업무에 적용해보며 느낀 점](https://smallake.kr/?p=30366)가 있을뿐인데 국내에서 사용하고 있다고 알려진 회사를 찾기엔 힘들 것 같습니다. 

한국어로 작성된 관련 리소스가 전혀 없기 때문에 영어로 된 공식 문서에 의존해야하는데 문법 및 구조가 다른 데이터베이스와 생소하기 때문에 문제가 발생했을 때 원인을 찾고 해결하는 과정이 어렵습니다. 

### KDB 시스템 아키텍처
![What Makes Time-Series Database kdb+ So Fast?](https://kx.com/wp-content/uploads/2020/08/why-fast-blog-diagram-3.png)

위 그림은 KX 블로그에서 소개하는 [KDB+ 시스템의 아키텍처](https://code.kx.com/q/architecture/)입니다. KDB+ 자체는 단일 인스턴스로 구동될 수 있습니다만, 프로덕션 환경에서 KDB 시스템을 사용하는 것은 위와 같은 아키텍처를 따르는게 효율적입니다. 시스템 아키텍처에서 메모리에 저장되는 실시간 데이터를 **RDB(Realtime)** 라고하며 실시간 데이터를 일정 구간으로 나누어서 저장한 것을 **IDB(Intraday)** 그리고 이 구간을 합쳐 일자별로 저장하는 것을 **HDB(Historical)** 라고 합니다. 경우에 따라서는 RDB와 HDB로 구분하기도 합니다. 그리고 RDB와는 다르게 IDB와 HDB는 스토리지에 파일로 저장됩니다. 따라서, KDB 시스템을 효율적으로 사용하기 위해서는 실시간 **데이터의 규모를 유연하게 처리할 수 있는 메모리**를 가져야하며 스토리지의 파일에 빠르게 접근할 수 있는 **I/O 성능**이 중요하다고 할 수 있습니다.

공식 블로그에서는 KDB+가 빠른 이유 3가지를 소개하고 있습니다.

- 벡터 지향형 데이터베이스 쿼리 지원
- 아주 작은 용량(800KB)에 의한 빠른 CPU 처리
- 데이터 저장 최적화

#### 티커플랜트
티커플랜트(Tickerplant)는 데이터가 들어오는 진입점이므로 **제로-레이턴시**를 목표로 해야합니다. 따라서, 티커플랜트 프로세스는 별도의 자체 코어로 할당하여 메모리 할당 및 CPU 활용을 최우선으로 해야합니다.

#### 리얼타임 데이터베이스
리엍타임 데이터베이스는 티커플랜트에 연결되어 데이터를 구독합니다. 데이터는 메모리에 저장되므로 테이블 스키마 및 데이터 규모를 계산하여 여유로운 메모리를 가지도록 시스템 자원을 설정해야합니다. 리얼타임 데이터베이스는 주기적인 인터벌에 의해 하루 또는 시간별로 데이터를 파일로 저장합니다.

#### 히스토리컬 데이터베이스
히스토리컬 데이터베이스는 리얼타임 데이터베이스에 의해 파일로 저장된 데이터를 가지는 인스턴스를 말합니다. 시간 또는 일자별 폴더를 파티션이라고하며 각 파티션에 테이블의 컬럼별로 파일이 저장되어있습니다. 히스토리컬 데이터베이스의 경우 파일에 접근해야하므로 디스크 I/O 성능이 중요하며 집계 시 접근해야하는 파티션이 많아지면 병목 현상이 발생할 수 있으니 **파티션별 데이터 규모에 따른 압축 및 조각 모음**이 필요할 수 있습니다.

### 성능 및 쿼리 최적화
KDB를 사용할 때 가장 주의해야될 점은 동기 작업으로 수행된다는 점 입니다. 쿼리가 실행되고있으면 다음 쿼리는 대기해야하므로 병목 현상이 발생하지 않도록 쿼리에 대한 최적화를 최대한 수행해야합니다. 예를 들어, 히스토리컬 데이터베이스가 시간별로 파티션되어있다면 한달 기간의 범위를 집계하기위해서 모든 시간 파티션을 조회해야하므로 I/O에 대한 병목 현상이 발생하여 쿼리 실행시간이 엄청 길어질 수 있습니다. 이는 제가 실제로 회사에서 KDB를 사용할 때 경험하고 있는 현상입니다. 

#### CPU Affinity
KDB 인스턴스가 메모리 및 CPU을 최대한 효율적으로 사용할 수 있도록 프로세스에 대한 CPU Affinity을 지정하는게 좋습니다. 리눅스의 경우 taskset 명령어를 사용해서 프로세스가 특정 CPU에 의해 동작되도록 제한할 수 있습니다.

#### 병렬 처리
히스토리컬 데이터베이스의 경우 [다중 스레드](https://code.kx.com/q/wp/multi-thread/)를 통한 병렬 처리로 더 좋은 성능을 보여줄 수 있습니다. 간단한 연산의 경우 병렬 처리보다는 메인 스레드에서 수행하는 것이 더 호율적일 수 있습니다. 단 파일 I/O는 동기로 수행되기때문에 보조 스레드로 실행하더라도 성능 상 이점을 보여주진 않습니다.

#### 쿼리 스케일링
[쿼리 스케일링](https://code.kx.com/q/wp/query-scaling/)은 대규모 데이터에 대해서 쿼리를 수행할 때 가장 효율적인 성능을 가지는 쿼리를 구성하는 방법을 소개합니다. 예를 들어, **`g# attribute**를 지정하면 좀 더 많은 메모리 공간을 사용하지만 쿼리 성능을 높일 수 있는 좋은 옵션입니다. 

### 알아두면 좋은 정보

```q KDB/q
# 인스턴스 실행 명령어
nohup taskset -c 0,1 -s 8 /opt/kx/q/l64/q tick.q sym /data/sym -p 5010 < /dev/null > logs/tick.log 2>&1&

# 부동소수점 제한해제
\P 0

# 쿼리 수행 시간 제한(초)
\T 60

# 기본 웹 서버 종료
.z.ph:{.h.hn["404";`txt;""]}

```

## 참고

- [What Makes Time-Series Database kdb+ So Fast?](https://kx.com/blog/what-makes-time-series-database-kdb-so-fast/)
- [CPU affinity](https://code.kx.com/q/kb/cpu-affinity/)




