<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>스프링 부트에서 모든 메시지 코드 가져오기</title>
    <url>/all-message-codes-in-spring-boot/</url>
    <content><![CDATA[<h2 id="ResourceBundleMessageSource"><a href="#ResourceBundleMessageSource" class="headerlink" title="ResourceBundleMessageSource"></a>ResourceBundleMessageSource</h2><p>스프링 부트에서 기본적으로 제공하는 <code>ResourceBundleMessageSource</code>는 메시지에 대한 모든 코드를 가져올 수 있는 기능이 존재하지 않습니다. 예외적으로 ReloadableResourceBundleMessageSource이라는 메시지 소스는 <code>getMergedProperties(Locale locale)</code> 함수를 통해 로케일에 대한 메시지 프로퍼티를 가져올 수 있습니다.</p>
<h2 id="ReloadableResourceBundleMessageSource"><a href="#ReloadableResourceBundleMessageSource" class="headerlink" title="ReloadableResourceBundleMessageSource"></a>ReloadableResourceBundleMessageSource</h2><p>하지만, getMergedProperties 함수는 접근제어자가 protected이므로 <code>ReloadableResourceBundleMessageSource</code>를 확장하는 클래스를 만들어야합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendReloadableResourceBundleMessageSource</span> <span class="keyword">extends</span> <span class="title">ReloadableResourceBundleMessageSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getMessages</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMergedProperties(locale).getProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MessageSource-Configuration"><a href="#MessageSource-Configuration" class="headerlink" title="MessageSource Configuration"></a>MessageSource Configuration</h2><p>구성 메타 클래스를 만들어 ExtendReloadableResourceBundleMessageSource를 메시지 소스로 등록합니다. 애플리케이션 컨텍스트에 <code>messageSource</code> 빈이 존재하는 경우 <code>MessageSourceAutoConfiguration</code>은 적용되지 않습니다.</p>
<p>따라서, 다음과 같이 <code>MessageSourceProperties</code>도 등록되도록 합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.messages&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageSourceProperties <span class="title">properties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">(MessageSourceProperties properties)</span> </span>&#123;</span><br><span class="line">        ExtendReloadableResourceBundleMessageSource messageSource = <span class="keyword">new</span> ExtendReloadableResourceBundleMessageSource();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(properties.getBasename())) &#123;</span><br><span class="line">            messageSource.setBasenames(StringUtils</span><br><span class="line">                    .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (properties.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageSource.setDefaultEncoding(properties.getEncoding().name());</span><br><span class="line">        &#125;</span><br><span class="line">        messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());</span><br><span class="line">        Duration cacheDuration = properties.getCacheDuration();</span><br><span class="line">        <span class="keyword">if</span> (cacheDuration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageSource.setCacheMillis(cacheDuration.toMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());</span><br><span class="line">        messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());</span><br><span class="line">        <span class="keyword">return</span> messageSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="spring-messages-basename"><a href="#spring-messages-basename" class="headerlink" title="spring.messages.basename"></a>spring.messages.basename</h3><p>ReloadableResourceBundleMessageSource를 확장하는 클래스를 만들었지만 스프링 부트의 기본 <code>spring.messages.basename</code> 값인 <code>messages</code>으로 메시지 프로퍼티를 가져올 수 없습니다.</p>
<p>ReloadableResourceBundleMessageSource에서 사용중인 ResourceLoader가 DefaultResourceLoader이므로 클래스패스에 위치한 <code>messages.properties</code>을 리소스로 가져오지 못합니다.</p>
<p>따라서, spring.messages.basename에 클래스패스를 포함하여 명시합니다.</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.messages.basename</span>=<span class="string">classpath:/messages</span></span><br></pre></td></tr></table></figure>

<h2 id="Messages-API"><a href="#Messages-API" class="headerlink" title="Messages API"></a>Messages API</h2><p>이제 ExtendReloadableResourceBundleMessageSource를 통해 메시지 정보를 가져올 수 있게 되고 API로도 제공하여 프론트엔드 클라이언트에서도 동일한 메시지 코드를 활용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/messages&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">messages</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">    ExtendReloadableResourceBundleMessageSource messageSource = (ExtendReloadableResourceBundleMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">    Map&lt;String, Object&gt; messages = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Properties allMessages = messageSource.getMessages(locale);</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entries = allMessages.entrySet();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Object, Object&gt; entry : entries) &#123;</span><br><span class="line">        Object key = entry.getKey();</span><br><span class="line">        Object value = entry.getValue();</span><br><span class="line"></span><br><span class="line">        messages.put((String) key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(messages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Message Source</tag>
      </tags>
  </entry>
  <entry>
    <title>EC2 인스턴스 연결(콘솔) 허용하기</title>
    <url>/allow-ec2-instance-connect/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘 알아볼 내용은 EC2 인스턴스 연결(EC2 Instance Connect) 기능입니다. 일반적으로 EC2 인스턴스에 접속하기 위해서는 SSH 클라이언트를 사용합니다. 아마존 EC2 콘솔은 SSH 클라이언트를 사용하지 않고도 EC2 인스턴스에 연결할 수 있는 기능을 제공하고 있습니다. 어떻게 해야 EC2 콘솔을 통해 EC2 인스턴스에 연결할 수 있는지 알아봅시다.</p>
<h2 id="EC2-인스턴스-연결"><a href="#EC2-인스턴스-연결" class="headerlink" title="EC2 인스턴스 연결"></a>EC2 인스턴스 연결</h2><p><strong>EC2 인스턴스 연결</strong>은 아마존 EC2 콘솔을 통해 퍼블릭 IPv4 주소가 할당된 인스턴스에 연결할 수 있는 기능입니다. EC2 인스턴스 연결에 대한 자세한 내용은 <a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ec2-instance-connect-methods.html#ec2-instance-connect-connecting-console">EC2 Instance Connect를 사용한 연결</a> 문서에서 확인할 수 있습니다.</p>
<p>퍼블릭 IPv4 주소가 할당된 Amazon Linux 2 또는 Ubuntu 16.04 이상의 인스턴스라면 아마존 EC2 콘솔에서 제공하는 EC2 인스턴스 연결 기능을 사용하여 인스턴스에 접속할 수 있습니다.</p>
<h3 id="인바운드-SSH-트래픽-허용"><a href="#인바운드-SSH-트래픽-허용" class="headerlink" title="인바운드 SSH 트래픽 허용"></a>인바운드 SSH 트래픽 허용</h3><p>기본으로 제공하는 보안 그룹에는 SSH 트래픽을 수신하는 것을 허용하지 않습니다. EC2 인스턴스 연결을 사용하기 위해서는 <strong>EC2_INSTANCE_CONNECT라는 서비스가 사용하는 IP 대역에 대하여 SSH 트래픽을 수신하도록 허용</strong>해야합니다.</p>
<p>EC2_INSTANCE_CONNECT 서비스가 사용하는 IP 대역은 <a href="https://ip-ranges.amazonaws.com/ip-ranges.json">AWSIP 주소 범위</a>에서 EC2_INSTANCE_CONNECT 서비스와 VPC가 생성된 region에 대하여 필터링을 해야합니다.</p>
<p><img data-src="/images/posts/allow-ec2-instance-connect/ec2-instance-connect-01.png"></p>
<p>다행히도 다른 서비스와 다르게 EC2_INSTANCE_CONNECT는 리전별로 하나이므로 <strong>13.209.1.56/29</strong> IP 대역을 SSH 트래픽으로 수신하도록 허용하면 됩니다.</p>
<p>회사에서 지급받은 구형 맥북에서 <a href="https://aws.amazon.com/ko/premiumsupport/knowledge-center/ec2-instance-connect-troubleshooting/">AWS 문서에서 알려주는 다음의 명령어</a>를 쳐봐도 하나만 나옵니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -s https://ip-ranges.amazonaws.com/ip-ranges.json| jq -r <span class="string">&#x27;.prefixes[] | select(.region==&quot;us-east-1&quot;) | select(.service==&quot;EC2_INSTANCE_CONNECT&quot;) | .ip_prefix&#x27;</span></span><br><span class="line">13.209.1.56/29</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/allow-ec2-instance-connect/ec2-instance-connect-02.png"></p>
<p>위와 같이 13.209.1.56/29 대역에 대한 SSH 트래픽을 수신할 수 있도록 허용하였으니 이제 이 보안그룹을 인스턴스에 추가하면 됩니다.</p>
<h3 id="샘플-인스턴스-생성"><a href="#샘플-인스턴스-생성" class="headerlink" title="샘플 인스턴스 생성"></a>샘플 인스턴스 생성</h3><p><img data-src="/images/posts/allow-ec2-instance-connect/ec2-instance-connect-03.png"></p>
<p>샘플 인스턴스는 기본으로 제공하는 보안 그룹을 지정하였습니다. 따라서 SSH 트래픽에 대해서 허용하지 않은 상태이므로 다음과 같이 EC2 인스턴스 연결을 시도하면 실패하게 됩니다.</p>
<p><img data-src="/images/posts/allow-ec2-instance-connect/ec2-instance-connect-04.png"></p>
<p>이제 샘플 인스턴스에 ec2-instance-connect 보안그룹을 추가하겠습니다.</p>
<p><img data-src="/images/posts/allow-ec2-instance-connect/ec2-instance-connect-05.png"></p>
<p>다시 아마존 EC2 콘솔의 EC2 인스턴스 연결으로 샘플 인스턴스에 접속해보겠습니다.</p>
<p><img data-src="/images/posts/allow-ec2-instance-connect/ec2-instance-connect-06.png"></p>
<p>EC2_INSTANCE_CONNECT 서비스의 IP 대역을 허용하였기 때문에 정상적으로 접속되었습니다.</p>
<p><img data-src="/images/posts/allow-ec2-instance-connect/complete.gif"></p>
<p>보안을 중요시하는 회사라면 모든 IP 대역에 대하여 SSH 접속을 허용하지 않고 <strong>EC2_INSTANCE_CONNECT 서비스와 회사에서 사용되는 IP 대역을 허용하시는 것을 권장</strong>합니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>AWS</tag>
        <tag>EC2</tag>
      </tags>
  </entry>
  <entry>
    <title>Base64</title>
    <url>/base64/</url>
    <content><![CDATA[<p><img data-src="/images/posts/base64/base64-01.png"></p>
<p>위와 같이 어떤 서비스에 대한 회원가입을 수행하거나 비밀번호 찾기와 같은 기능을 수행했을경우 인증 관련 메일이 발송되는 것을 자주 확인할 수 있습니다. 그러나 위와 같이 인증확인 버튼을 클릭했을때 어떠한 동작을 하는지 궁금하시지 않으신가요? 위와 같은 인증 버튼은 링크 엘리먼트로 되어있으며 일반적인 GET 요청입니다. 그리고 그 URI에는 다음과 같은 어떠한 형태의 문자열이 포함되게 됩니다.</p>
<blockquote>
<p>a2RldmtyQGdtYWlsLmNvbTp5Rm5iTUtrblZrRW85ckdxTVlmTGtWNE03UUtMTldXWg==</p>
</blockquote>
<p>위와 같이 구성된 문자열은 Base64로 인코딩된 데이터이며 크롬 개발자도구의 콘솔을 통해 이 아스키 문자열을 디코딩하면 다음과 같은 문자열 데이터를 확인할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">atob(<span class="string">&quot;a2RldmtyQGdtYWlsLmNvbTp5Rm5iTUtrblZrRW85ckdxTVlmTGtWNE03UUtMTldXWg==&quot;</span>)</span><br><span class="line"><span class="string">&#x27;kdevkr@gmail.com:yFnbMKknVkEo9rGqMYfLkV4M7QKLNWWZ&#x27;</span></span><br></pre></td></tr></table></figure>

<p>제 이메일 주소와 함께 어떠한 문자열을 포함하고 있습니다. 아마도 저 알수없는 문자열은 암호화된 인증 정보일 것입니다. 인증 정보와 GET 요청에 포함된 이메일 주소가 동일한지를 내부적으로 검증하겠죠. 이러한 인증 정보를 왜 Base64로 인코딩하여 전송하게 되는 것일까요? <strong>안전한 형태로 데이터를 전달하고자하는 목적</strong>에 있습니다.</p>
<h2 id="아스키-코드"><a href="#아스키-코드" class="headerlink" title="아스키 코드"></a>아스키 코드</h2><p>사람들은 수 많은 문자의 형태를 읽고 구분할 수 있지만 0과 1로 이루어진 컴퓨터 시스템은 시스템에 따라 0과 1을 읽고 구분하는 방식이 다를 수 있습니다. 시스템의 발전에 따라 아스키 코드부터 유니코드 그리고 여러가지 문자 조합이 확장되고 있습니다. 대부분의 문자 형식은 아스키 코드를 기초로 만들어지기 때문에 아스키 코드 중 일부 문자 집합은 거의 모든 시스템에서 공통으로 사용되는 문자입니다. 그러한 문자들을 모아 만들어지는게 Base64 인코딩입니다.</p>
<h3 id="Base64-이미지"><a href="#Base64-이미지" class="headerlink" title="Base64 이미지"></a>Base64 이미지</h3><p>브라우저에서는 바이너리 데이터 뿐만 아니라 Base64로 이루어진 이미지 데이터를 표현할 수 있습니다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAA+VJREFUeF7tnclu4zAUBEf//9EeYG6SAhUKTdJUpnMV1663kbKd4/P5fP70bxsFjgLZhsW/hRTIXjwKZDMeBVIguymw2XqaQwpkMwU2Ww56yHEcS5d8PRZd56djU9p+9mZx/XQOKZCxiAoELiK+bXBX3A1ZXw7JMRByOevgFPNTC6b10vx2PzeBL8BxPTaH0IB2AyRIgVwUJcEsAGtBBVIgqY2d+luD1kmdzgm0G+pPIdF6jB2P1jd9f2kOSQXSFiSrogIBEyILtAJai52dw+L91UPOV0MkqDUAHQHeBsRaOAlIgi0PyQVSD4nKwnoIHP1Xu3SBfBkIxfgUEI2/2uC2PxiSYAVyeb8w24IKRN5lFchZMDrH4ME3LXupzqfn5AH2+XU+FEC+r6D9xCG0QJ7PIRZAgcBlYz1EmpQNSRSj/7uQJfXWzUnw2c/1gmUH9FibQ+T8uvlswWl8vWDZoUAG3zRI/W/NC+S3AUktIu1PST8tM9P1je6Pd1mjJ7TjFYhVbHL7ApkssB2+QOBykQTFKkKerNPLS8oxtJ/0oKn7jz6HFMjzF5xQnwJxPoKCyghw8+ACeTkQunqwFmTHG53kR49HOQv1sR5iBbQLJIHo+ej57Hhx+wJxL6hGG0ScQ+ohkwFaD6G62p4baDxKuWSxuz+PPYQELJDz78GRQRQIfK7MhmQSnJ4XyNuBUBlnQxjV4TZnUPt0Ptr/8PEpqdOCCmTsb4jqF1SUtG0MJgu3BkEGYuej+eshg7+FawHZJK3Hp5A1egGph5EH0Pir+1sPwpBVIM82PjpEF8ji77tQCCuQtwEhorOfz84JFOPT+a0+6CF2wNHtU0Gof4FIYiRoWjUVSIE8KoAhy1qo1PvWPLXYtAxN9xvPbw+GqeDUv0BAgdRiCADlALpLov72YJvutx5yIRILIu/KhhuEDVkUUqxHkAXTc/KgFNDy8QvEvc8gA6HnZLC6yqqHuB88s3oViPyvgeQB9Hy6h9iqZHVMtzkABQu/REoeE3tIgTx/DouqsJvBpEm9QArkZFQ2Ztv2NuSRgf66kDVaUAopJDDlHALw+pBVIGFVYS2QLKpACoSi0uNzMrDXhSyK4bRh8igaP6LxQ2dc7+5lLwmGGxzs4SkgXG+BfPc/mTZkhZ/D2t5D0gXaGD/6LowOfrQ/CkHUf7iH2AlJACs4AbXro5xFZbydr0BAsQKRVZD1IGuxrwNiN2jbW8GtgGnIsSFSt7dlrxXYti+QzT+XRRZWD7EmL9vXQ0YX0hJAm58VwHfqFWytAgWyVm+crUBQorUNCmSt3jhbgaBEaxsUyFq9cbYCQYnWNvgLqC4vPjN7siAAAAAASUVORK5CYII=&quot;</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAA+VJREFUeF7tnclu4zAUBEf//9EeYG6SAhUKTdJUpnMV1663kbKd4/P5fP70bxsFjgLZhsW/hRTIXjwKZDMeBVIguymw2XqaQwpkMwU2Ww56yHEcS5d8PRZd56djU9p+9mZx/XQOKZCxiAoELiK+bXBX3A1ZXw7JMRByOevgFPNTC6b10vx2PzeBL8BxPTaH0IB2AyRIgVwUJcEsAGtBBVIgqY2d+luD1kmdzgm0G+pPIdF6jB2P1jd9f2kOSQXSFiSrogIBEyILtAJai52dw+L91UPOV0MkqDUAHQHeBsRaOAlIgi0PyQVSD4nKwnoIHP1Xu3SBfBkIxfgUEI2/2uC2PxiSYAVyeb8w24IKRN5lFchZMDrH4ME3LXupzqfn5AH2+XU+FEC+r6D9xCG0QJ7PIRZAgcBlYz1EmpQNSRSj/7uQJfXWzUnw2c/1gmUH9FibQ+T8uvlswWl8vWDZoUAG3zRI/W/NC+S3AUktIu1PST8tM9P1je6Pd1mjJ7TjFYhVbHL7ApkssB2+QOBykQTFKkKerNPLS8oxtJ/0oKn7jz6HFMjzF5xQnwJxPoKCyghw8+ACeTkQunqwFmTHG53kR49HOQv1sR5iBbQLJIHo+ej57Hhx+wJxL6hGG0ScQ+ohkwFaD6G62p4baDxKuWSxuz+PPYQELJDz78GRQRQIfK7MhmQSnJ4XyNuBUBlnQxjV4TZnUPt0Ptr/8PEpqdOCCmTsb4jqF1SUtG0MJgu3BkEGYuej+eshg7+FawHZJK3Hp5A1egGph5EH0Pir+1sPwpBVIM82PjpEF8ji77tQCCuQtwEhorOfz84JFOPT+a0+6CF2wNHtU0Gof4FIYiRoWjUVSIE8KoAhy1qo1PvWPLXYtAxN9xvPbw+GqeDUv0BAgdRiCADlALpLov72YJvutx5yIRILIu/KhhuEDVkUUqxHkAXTc/KgFNDy8QvEvc8gA6HnZLC6yqqHuB88s3oViPyvgeQB9Hy6h9iqZHVMtzkABQu/REoeE3tIgTx/DouqsJvBpEm9QArkZFQ2Ztv2NuSRgf66kDVaUAopJDDlHALw+pBVIGFVYS2QLKpACoSi0uNzMrDXhSyK4bRh8igaP6LxQ2dc7+5lLwmGGxzs4SkgXG+BfPc/mTZkhZ/D2t5D0gXaGD/6LowOfrQ/CkHUf7iH2AlJACs4AbXro5xFZbydr0BAsQKRVZD1IGuxrwNiN2jbW8GtgGnIsSFSt7dlrxXYti+QzT+XRRZWD7EmL9vXQ0YX0hJAm58VwHfqFWytAgWyVm+crUBQorUNCmSt3jhbgaBEaxsUyFq9cbYCQYnWNvgLqC4vPjN7siAAAAAASUVORK5CYII=&quot;</span> <span class="attr">data-loaded</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAA+VJREFUeF7tnclu4zAUBEf//9EeYG6SAhUKTdJUpnMV1663kbKd4/P5fP70bxsFjgLZhsW/hRTIXjwKZDMeBVIguymw2XqaQwpkMwU2Ww56yHEcS5d8PRZd56djU9p+9mZx/XQOKZCxiAoELiK+bXBX3A1ZXw7JMRByOevgFPNTC6b10vx2PzeBL8BxPTaH0IB2AyRIgVwUJcEsAGtBBVIgqY2d+luD1kmdzgm0G+pPIdF6jB2P1jd9f2kOSQXSFiSrogIBEyILtAJai52dw+L91UPOV0MkqDUAHQHeBsRaOAlIgi0PyQVSD4nKwnoIHP1Xu3SBfBkIxfgUEI2/2uC2PxiSYAVyeb8w24IKRN5lFchZMDrH4ME3LXupzqfn5AH2+XU+FEC+r6D9xCG0QJ7PIRZAgcBlYz1EmpQNSRSj/7uQJfXWzUnw2c/1gmUH9FibQ+T8uvlswWl8vWDZoUAG3zRI/W/NC+S3AUktIu1PST8tM9P1je6Pd1mjJ7TjFYhVbHL7ApkssB2+QOBykQTFKkKerNPLS8oxtJ/0oKn7jz6HFMjzF5xQnwJxPoKCyghw8+ACeTkQunqwFmTHG53kR49HOQv1sR5iBbQLJIHo+ej57Hhx+wJxL6hGG0ScQ+ohkwFaD6G62p4baDxKuWSxuz+PPYQELJDz78GRQRQIfK7MhmQSnJ4XyNuBUBlnQxjV4TZnUPt0Ptr/8PEpqdOCCmTsb4jqF1SUtG0MJgu3BkEGYuej+eshg7+FawHZJK3Hp5A1egGph5EH0Pir+1sPwpBVIM82PjpEF8ji77tQCCuQtwEhorOfz84JFOPT+a0+6CF2wNHtU0Gof4FIYiRoWjUVSIE8KoAhy1qo1PvWPLXYtAxN9xvPbw+GqeDUv0BAgdRiCADlALpLov72YJvutx5yIRILIu/KhhuEDVkUUqxHkAXTc/KgFNDy8QvEvc8gA6HnZLC6yqqHuB88s3oViPyvgeQB9Hy6h9iqZHVMtzkABQu/REoeE3tIgTx/DouqsJvBpEm9QArkZFQ2Ztv2NuSRgf66kDVaUAopJDDlHALw+pBVIGFVYS2QLKpACoSi0uNzMrDXhSyK4bRh8igaP6LxQ2dc7+5lLwmGGxzs4SkgXG+BfPc/mTZkhZ/D2t5D0gXaGD/6LowOfrQ/CkHUf7iH2AlJACs4AbXro5xFZbydr0BAsQKRVZD1IGuxrwNiN2jbW8GtgGnIsSFSt7dlrxXYti+QzT+XRRZWD7EmL9vXQ0YX0hJAm58VwHfqFWytAgWyVm+crUBQorUNCmSt3jhbgaBEaxsUyFq9cbYCQYnWNvgLqC4vPjN7siAAAAAASUVORK5CYII=" alt="Base64로 표시된 QR코드 이미지"></p>
<blockquote>
<p>웹팩의 <a href="https://v4.webpack.js.org/loaders/url-loader/">url-loader</a>는 위와 같은 Base64 형식의 URI로 변환합니다. </p>
</blockquote>
<h3 id="HTTP-기본-인증"><a href="#HTTP-기본-인증" class="headerlink" title="HTTP 기본 인증"></a>HTTP 기본 인증</h3><p>사용자 이름과 비밀번호를 Authorization 헤더에 포함하여 전달하는 HTTP 기본 인증의 경우에도 Base64 인코딩을 사용합니다. 이는 HTTP 헤더의 값이 <strong>아스키 코드</strong>로 인코딩되어야하기 때문입니다. 따라서, 아스키 코드로 표현할 수 없는 데이터도 전달할 수 있도록 Base64 인코딩을 사용하는 것입니다.</p>
<blockquote>
<p>Authorization: Basic bWFtYm86cGFzc3dvcmQ=</p>
</blockquote>
<h3 id="JWT-Base64Url"><a href="#JWT-Base64Url" class="headerlink" title="JWT Base64Url"></a>JWT Base64Url</h3><p>최근 사용자 인증을 위해 많이 도입하는 JWT(JSON Web Token)는 페이로드와 시그니처 부분을 <strong>Base64Url(URL Safe Base64)</strong> 로 인코딩합니다. JWT를 Base64로 인코딩하는 이유는 토큰이 URL 파라미터로 전송될 수 있기 때문입니다. </p>
<h2 id="끝마치며"><a href="#끝마치며" class="headerlink" title="끝마치며"></a>끝마치며</h2><p>Base64를 사용하는 이유에 대해서 간단하게 알아보았습니다. 초보 개발자분들 뿐만 아니라 저처럼 Base64에 대해서 인지하고 있었던 분들에게도 도움이 되었으면 합니다. 감사합니다.</p>
<blockquote>
<p>Base64에 대해서 자세한 내용을 알고 싶다면 <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC4648</a>을 참고하세요.</p>
</blockquote>
]]></content>
      <tags>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS SSM 에이전트로 프라이빗 EC2 인스턴스에 연결하기</title>
    <url>/connect-private-ec2-instance-using-ssm-agent/</url>
    <content><![CDATA[<p><code>2021년 9월 28일에 부족한 정보를 추가 및 보완하였습니다.</code></p>
<p>안녕하세요 Mambo입니다. </p>
<p>오늘은 아마존 웹 서비스의 SSM(System Session Manager)를 사용하여 프라이빗 서브넷에서 구동되고 있는 EC2 인스턴스에 연결하는 방법에 대해서 알아보고자 합니다.</p>
<p>일반적으로 로컬 환경과 같은 외부 호스트에서 서버 인스턴스에 접근하기 위해서 <code>SSH(Secure Shell)</code>을 사용합니다. 그러나 SSH 클라이언트를 사용하여 EC2 인스턴스에 접근하기 위해서는 <strong>퍼블릭 DNS 또는 퍼블릭 IP 주소를 가지는</strong> 퍼블릭 인스턴스이어야 합니다. 인터넷과 연결되지 않는 프라이빗 서브넷에 위치하는 프라이빗 EC2 인스턴스에 접근하기 위해서는 퍼블릭 IP가 할당된 퍼블릭 인스턴스를 <code>배스천(Bastion) 호스트</code>로써 사용하여 경유해야합니다. 이렇게 배스천 호스트를 구성하는 것은 불필요하게 인스턴스를 유지하는 문제도 있으며 SSH 접속을 위한 개인키가 인터넷과 연결된 퍼블릭 EC2 인스턴스에 위치하게 되는 단점을 보유하게 됩니다.</p>
<p>아마존 웹 서비스에서는 배스천 호스트를 담당하도록 구성하는 퍼블릭 인스턴스의 단점을 보완하기 위하여 SSH와 개인키를 사용하지 않고도 HTTPS를 사용하여 인터넷과 연결되지 않은 프라이빗 서브넷에 접근할 수 있도록 <strong>AWS Systems Manager</strong>를 제공합니다. AWS Systems Manager가 <a href="https://docs.aws.amazon.com/ko_kr/systems-manager/latest/userguide/sysman-install-ssm-agent.html">SSM 에이전트</a>가 설치된 EC2 인스턴스를 관리형 인스턴스로 등록함으로써 IAM과 SSM 에이전트를 사용하여 관리형 인스턴스로 접속할 수 있습니다.</p>
<h2 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h2><p>AWS Systems Manager가 EC2 인스턴스를 관리형 인스턴스로 등록하도록 구성하기 위해서는 몇가지 설정을 해야합니다.</p>
<h3 id="호스트-관리-기능-활성화"><a href="#호스트-관리-기능-활성화" class="headerlink" title="호스트 관리 기능 활성화"></a>호스트 관리 기능 활성화</h3><p>AWS Systems Manager의 빠른 설정을 통해 Host Management 구성을 사용하여 EC2 인스턴스를 관리형 인스턴스로 등록하기 위한 작업을 활성화 할 수 있습니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-quick-setup.png"></p>
<h3 id="SSM-에이전트를-위한-VPC-엔드포인트-구성"><a href="#SSM-에이전트를-위한-VPC-엔드포인트-구성" class="headerlink" title="SSM 에이전트를 위한 VPC 엔드포인트 구성"></a>SSM 에이전트를 위한 VPC 엔드포인트 구성</h3><p>호스트 관리 구성을 통해 활성화된 SSM 서비스가 VPC 내 프라이빗 서브넷에 접근할 수 있도록 AWS PrivateLink로 구동되는 <a href="https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints.html">VPC 인터페이스 엔드포인트</a>를 구성해야합니다.</p>
<h4 id="VPC-DNS-호스트-이름-활성화"><a href="#VPC-DNS-호스트-이름-활성화" class="headerlink" title="VPC DNS 호스트 이름 활성화"></a>VPC DNS 호스트 이름 활성화</h4><p>VPC 엔드포인트를 생성하기 위해서는 VPC 속성 중 <strong>DNS 호스트 이름을 활성화</strong>해야합니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-enable-dns-name.png"></p>
<h4 id="VPC-엔드포인트-생성"><a href="#VPC-엔드포인트-생성" class="headerlink" title="VPC 엔드포인트 생성"></a>VPC 엔드포인트 생성</h4><p>EC2와 SSM 서비스에 대한 VPC 엔드포인트를 생성합니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-vpc-endpoints.png"></p>
<h3 id="EC2-인스턴스-프로파일-지정"><a href="#EC2-인스턴스-프로파일-지정" class="headerlink" title="EC2 인스턴스 프로파일 지정"></a>EC2 인스턴스 프로파일 지정</h3><p>빠른 설정을 통해 호스트 관리 기능을 활성화하면 <strong>AmazonSSMRoleForInstancesQuickSetup</strong>이라는 IAM 역할이 생성됩니다. EC2 인스턴스에 대해 AmazonSSMRoleForInstancesQuickSetup IAM 역할을 지정하면 AWS Systems Manager가 SSM 에이전트와 통신하여 관리형 인스턴스로 등록됩니다.</p>
<p>만약, AmazonSSMRoleForInstancesQuickSetup이 자동으로 생성되지 않는다면 AmazonSSMManagedInstanceCore 정책을 지정한 IAM 역할을 직접 생성하시면 됩니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-managed-instance-core-policy.png"></p>
<h4 id="IAM-역할"><a href="#IAM-역할" class="headerlink" title="IAM 역할"></a>IAM 역할</h4><p>IAM 역할이 지정되지 않은 인스턴스는 다음과 같이 SSM 에이전트를 통해 연결할 수 없습니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-connect-instance-console-failed.png" alt="IAM 역할이 지정되지 않은 인스턴스"></p>
<p>AmazonSSMRoleForInstancesQuickSetup 역할을 지정해봅니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-set-iam-role.png"></p>
<h4 id="HTTPS-인바운드-트래픽-허용"><a href="#HTTPS-인바운드-트래픽-허용" class="headerlink" title="HTTPS 인바운드 트래픽 허용"></a>HTTPS 인바운드 트래픽 허용</h4><p>AmazonSSMRoleForInstancesQuickSetup 역할을 지정하더라도 VPC를 구성하는 프라이빗 네트워크 주소 범위에 대하여 HTTPS 트래픽을 허용해야합니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-https-inbound-trafic.png"></p>
<h4 id="Session-Manager-활성화"><a href="#Session-Manager-활성화" class="headerlink" title="Session Manager 활성화"></a>Session Manager 활성화</h4><p>SSM 에이전트 통신이 성공적으로 이루어진 경우 EC2 콘솔을 통해 Session Manager를 사용하여 프라이빗 인스턴스에 연결할 수 있습니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-connect-instance-console.png"></p>
<h3 id="관리형-인스턴스-검토"><a href="#관리형-인스턴스-검토" class="headerlink" title="관리형 인스턴스 검토"></a>관리형 인스턴스 검토</h3><p>관리형 인스턴스는 Systems Manager와 함께 사용하도록 구성된 EC2 인스턴스입니다. EC2 인스턴스를 관리형 인스턴스로 등록하기 위해서는 다음의 조건이 충족되어야 합니다. </p>
<ul>
<li>SSM 에이전트 설치 : EC2 인스턴스에 SSM 에이전트가 설치되어있어야 합니다.</li>
<li>SSM 엔드포인트 연결 : SSM 서비스가 SSM 에이전트로 통신할 수 있어야 합니다.</li>
<li>SSM IAM 역할 연결 : AmazonSSMManagedInstanceCore 정책을 포함하는 IAM 역할을 연결해야합니다.</li>
</ul>
<h2 id="AWS-SSM-CLI"><a href="#AWS-SSM-CLI" class="headerlink" title="AWS SSM CLI"></a>AWS SSM CLI</h2><p>로컬 호스트에서 SSM 에이전트가 설치된 EC2 인스턴스에 접근하기 위해서 AWS CLI의 SSM 명령어를 사용할 수 있습니다.</p>
<h3 id="AWS-CLI-설치"><a href="#AWS-CLI-설치" class="headerlink" title="AWS CLI 설치"></a>AWS CLI 설치</h3><p>각 환경에 맞는 AWS CLI 인스톨러를 실행하여 AWS CLI를 설치합니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-install-aws-cli-2-for-windows.png"></p>
<h3 id="크레덴셜-프로파일-설정"><a href="#크레덴셜-프로파일-설정" class="headerlink" title="크레덴셜 프로파일 설정"></a>크레덴셜 프로파일 설정</h3><p>AWS CLI을 사용하기 위하여 <code>AmazonSSMManagedInstanceCore</code> 정책이 부여된 크레덴셜을 프로파일로 등록합니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-configure-aws-cli-profile.png"></p>
<h3 id="SSM-세션-시작하기"><a href="#SSM-세션-시작하기" class="headerlink" title="SSM 세션 시작하기"></a>SSM 세션 시작하기</h3><p>AWS SSM CLI의 <code>start-session</code> 명령어로 관리형 인스턴스에 대한 세션을 시작할 수 있습니다.</p>
<p><img data-src="/images/posts/connect-private-ec2-instance/aws-ssm-cli-start-session.png"></p>
<h4 id="SSM-포트-포워딩"><a href="#SSM-포트-포워딩" class="headerlink" title="SSM 포트 포워딩"></a>SSM 포트 포워딩</h4><p>세션을 시작할 때 포트 번호를 파라미터로 제공하여 SSH에서 처럼 포트 포워딩을 수행할 수 있습니다. 이때 파라미터 중 <code>portNumber</code>는 관리형 인스턴스의 포트이고 <code>localPortNumber</code>는 현재 로컬 호스트의 포트임을 감안하시기 바랍니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">aws ssm start-session \</span><br><span class="line">--profile mambo \ </span><br><span class="line">--target <span class="variable">$instance_id</span> \</span><br><span class="line">--document-name AWS-StartPortForwardingSession \</span><br><span class="line">--parameters <span class="string">&#x27;&#123;&quot;portNumber&quot;:[&quot;8080&quot;], &quot;localPortNumber&quot;:[&quot;5000&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">Starting session with SessionId: <span class="variable">$session_id</span></span><br><span class="line">Port 5000 opened <span class="keyword">for</span> sessionId <span class="variable">$session_id</span></span><br><span class="line">Waiting <span class="keyword">for</span> connections...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>윈도우 터미널에서는 “를 \“로 문자 처리해야해요.</p>
</blockquote>
<h2 id="SSM-CLI-고급-기능"><a href="#SSM-CLI-고급-기능" class="headerlink" title="SSM CLI 고급 기능"></a>SSM CLI 고급 기능</h2><p>SSM 에이전트를 통해 연결되는 세션은 SSH를 활용하는 것이 아니므로 EC2 인스턴스의 22번 포트에 정의된 보안 그룹이 무시됩니다. 또한, <a href="https://docs.aws.amazon.com/ko_kr/systems-manager/latest/userguide/session-manager-getting-started-enable-ssh-connections.html">SSH 연결 활성화</a>를 통해 세션 매니저가 SSH 연결을 수행할 수 있습니다. </p>
<p>세션 매니저를 통해 SSH 연결을 수행하는 경우 22번 포트가 인바운드 규칙에 없더라도 SSH 또는 SCP를 사용할 수 있습니다. PEM 파일이 누군가에 의해 탈취되었더라도 SSM 관리형 인스턴스 역할이 부여된 크레덴셜이 없으면 관리형 인스턴스에 접근할 수 없습니다.</p>
<blockquote>
<p>SSM CLI로 SSH 연결을 수행하는 예제는 <a href="https://musma.github.io/2019/11/29/about-aws-ssm.html">AWS SSM으로 EC2 인스턴스에 접근하기</a>를 참고하세요.</p>
</blockquote>
<h3 id="Gossm"><a href="#Gossm" class="headerlink" title="Gossm"></a>Gossm</h3><p><a href="https://medium.com/@gjbae1212/aws-ssm-%EC%9D%B4%EC%9A%A9%ED%95%B4-ec2-%EC%A0%91%EC%86%8D%ED%95%98%EB%8A%94-cli-%EA%B0%9C%EB%B0%9C-62c2f7357fb8">AWS SSM 이용해 EC2 접속하는 CLI 개발</a>에서 소개하는 <a href="https://github.com/gjbae1212/gossm">gossm</a>은 AWS SSM CLI을 좀 더 편하게 사용할 수 있도록 지원하니 활용하시면 좋습니다.</p>
<p>본 글에서 진행한 AWS 콘솔 화면은 회사에서 사용중인 계정을 통해 알아보았기 때문에 주요 정보는 전부 마스킹 처리되었습니다. 프라이빗 EC2 인스턴스에 대한 접근을 위해 배스천 호스트 대신에 SSM 에이전트를 사용해보세요.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>AWS</tag>
        <tag>SSM Agent</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS IoT Device SDK Java로 MQTT 연결하기</title>
    <url>/connecting-with-mqtt-using-aws-iot-device-sdk/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다. 오늘은 AWS IoT Core의 MQTT 클라이언트로 MQTT 브로커에 연결하여 메시지를 게시하고 수신해보는 방법에 대해서 알아봅니다.</p>
<h2 id="AWS-IoT-Core"><a href="#AWS-IoT-Core" class="headerlink" title="AWS IoT Core"></a>AWS IoT Core</h2><p><img data-src="https://docs.aws.amazon.com/iot/latest/developerguide/images/what-is-aws-iot.png"></p>
<p>AWS IoT Core는 클라우드 환경에 디바이스를 연결하고 연결된 디바이스간 통신을 제공하는 관리형 클라우드 플랫폼입니다. 그리고 AWS IoT Core를 사용하는 디바이스들이 다음의 표준 통신 프로토콜을 사용하여 서로 상호작용을 할 수 있도록 지원합니다.</p>
<ul>
<li><a href="https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html">MQTT (Message Queuing and Telemetry Transport)</a></li>
<li><a href="https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html">MQTT over WSS (Websockets Secure)</a></li>
<li><a href="https://docs.aws.amazon.com/iot/latest/developerguide/http.html">HTTPS (Hypertext Transfer Protocol - Secure)</a></li>
<li><a href="https://docs.aws.amazon.com/iot/latest/developerguide/connect-iot-lorawan.html">LoRaWAN (Long Range Wide Area Network)</a></li>
</ul>
<p>이 글에서는 두번째 방식인 <strong>MQTT over WebSocket</strong> 방식으로 AWS IoT Core 서비스에 연결하는 것을 알아봅니다.</p>
<h3 id="MQTT-3-1-1"><a href="#MQTT-3-1-1" class="headerlink" title="MQTT 3.1.1"></a>MQTT 3.1.1</h3><p>AWS IoT Core의 MQTT 메시지 브로커는 <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">MQTT v3.1.1 specification</a>을 기반으로 구현되어있습니다. 그러나 몇가지 부분에 대해서 약간 다르다고 하는데 주요 사항은 다음과 같습니다.</p>
<ul>
<li>QoS(Quality of Service)는 0 또는 1 지원</li>
<li>클라이언트 ID 유일성</li>
<li>보관된 메시지 미지원</li>
</ul>
<blockquote>
<p>더 자세한 내용은 <a href="https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html#mqtt-differences">AWS IoT differences from MQTT version 3.1.1 specification</a>을 참고하세요.</p>
</blockquote>
<h3 id="AWS-IoT-Device-SDK-for-Java"><a href="#AWS-IoT-Device-SDK-for-Java" class="headerlink" title="AWS IoT Device SDK for Java"></a>AWS IoT Device SDK for Java</h3><p>AWS IoT 서비스에 연결하기위해서는 AWS CLI, AWS IoT API, AWS IoT Device SDK를 사용해야합니다. 여러 언어로 구현된 AWS IoT Device SDK 중에서 안타깝게 Go로 작성된 SDK는 없으므로 <strong>AWS IoT Device SDK for Java</strong> 를 사용합니다.</p>
<p>AWS IoT Device SDK는 버전 1과 버전 2가 있습니다. 회사에서는 버전 1을 사용하고 있지만 이 글에서는 <strong>AWS IoT Device SDK for Java v2</strong> 를 사용하여 AWS IoT 서비스에 연결해보도록 하겠습니다.</p>
<table>
<thead>
<tr>
<th>Version 1</th>
<th>Version 2</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/aws/aws-sdk-java">AWS SDK for Java</a></td>
<td><a href="https://github.com/aws/aws-sdk-java-v2">AWS SDK for Java 2.0</a></td>
</tr>
<tr>
<td><a href="https://github.com/aws/aws-iot-device-sdk-java">AWS IoT Device SDK for Java</a></td>
<td><a href="https://github.com/aws/aws-iot-device-sdk-java-v2">AWS IoT Device SDK for Java v2</a></td>
</tr>
</tbody></table>
<blockquote>
<p>기존 SDK를 기준으로 사용하기 쉽도록 새로 작성한 SDK이기 때문에 더 편리합니다.</p>
</blockquote>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation platform(<span class="string">&#x27;software.amazon.awssdk:bom:2.17.13&#x27;</span>)</span><br><span class="line">    implementation <span class="string">&#x27;software.amazon.awssdk:cognitoidentity&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;software.amazon.awssdk:lambda&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;software.amazon.awssdk.iotdevicesdk:aws-iot-device-sdk:1.4.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>회사에서는 모든 모듈을 포함하는 SDK를 사용하는데 필요한 SDK 모듈만 추가해서 사용하는게 좋아보입니다.<br><a href="https://search.maven.org/search?q=g:software.amazon.awssdk">SDK 모듈 목록</a>을 보면 이 글을 쓰는 기준으로 무려 <strong>352개</strong>가 포함됩니다.</p>
</blockquote>
<h2 id="MQTT-with-AWS-IoT-Core"><a href="#MQTT-with-AWS-IoT-Core" class="headerlink" title="MQTT with AWS IoT Core"></a>MQTT with AWS IoT Core</h2><p>AWS Iot Core의 MQTT 클라이언트는 연결 방식에 따라 다음의 두가지 방식으로 나누어집니다.</p>
<table>
<thead>
<tr>
<th>방식</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>MQTT</td>
<td>X.509 인증서 기반 인증</td>
</tr>
<tr>
<td>MQTT over WebSocket</td>
<td><a href="https://docs.aws.amazon.com/ko_kr/general/latest/gr/signature-version-4.html">서명 버전 4 (SIGv4)</a> 자격 증명을 사용하여 인증</td>
</tr>
</tbody></table>
<p>회사에서는 서버 애플리케이션의 경우 텔레노어 커넥션(Telenor Connexion) 서비스에서 제공하는 자격 증명을 통해 <strong>MQTT over WebSocket</strong> 으로 연결하고 있으며 데이터를 수집하는 디바이스에서는 자격 증명을 외부로 공개할 수 없으므로 <strong>X.509 인증서</strong> 를 기반으로 연결합니다. </p>
<h3 id="Amazon-Cognito-IdP"><a href="#Amazon-Cognito-IdP" class="headerlink" title="Amazon Cognito IdP"></a>Amazon Cognito IdP</h3><p>본 학습에서는 AWS IoT 서비스(MQTT 메시지 브로커)에 연결하기 위하여 <strong>Amazon Cognito의 자격 증명 공급자(IdP)</strong> 를 통해 AWS 서비스에 대해 인증합니다. 저는 텔레노어 커넥션에서 지원하는 플랫폼 서비스를 통해 <strong>사용자 풀 아이디(User Pool ID)</strong> 와 <strong>자격 증명 풀 아이디(Identity Pool ID)</strong> 를 제공받기 때문에 이 부분에 대해서는 다루지 않습니다.</p>
<blockquote>
<p>추후에 Amazon Cognito를 직접 다루게된다면 사용자 풀과 자격 증명 풀 아이디를 발급하는 부분에 대해서 추가하겠습니다.</p>
</blockquote>
<p>Amazon Cognito를 활용하여 <strong>AWS 서비스에 인증하는 순서</strong>는 다음과 같습니다.</p>
<ol>
<li>발급받은 자격 증명 풀 아이디로 Cogntio 자격 증명 풀에 인증하여 임시 자격 증명 발급</li>
<li>등록된 사용자 풀 아이디로 Cognito 사용자 풀에 인증하여 JWT 토큰 발급</li>
<li>Cogntio 자격 증명 공급자에 인증된 사용자의 JWT 토큰을 로그인 맵에 설정</li>
<li>인증된 사용자의 자격 증명 발급</li>
<li>Cognito 임시 자격 증명을 사용하여 AWS IoT 서비스에 연결</li>
</ol>
<h4 id="Identity-Pool-Credentials"><a href="#Identity-Pool-Credentials" class="headerlink" title="Identity Pool Credentials"></a>Identity Pool Credentials</h4><p>먼저, CognitoIdentityClient로 자격 증명 풀 아이디와 리전에 대한 자격 증명 풀 크레덴셜을 발급합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AwsSessionCredentials <span class="title">baseCredentials</span><span class="params">(String identityPoolId, Region region)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (CognitoIdentityClient cognitoIdentityClient = CognitoIdentityClient.builder()</span><br><span class="line">            .credentialsProvider(AnonymousCredentialsProvider.create())</span><br><span class="line">            .region(region)</span><br><span class="line">            .build()) &#123;</span><br><span class="line"></span><br><span class="line">        GetIdRequest getIdRequest = GetIdRequest.builder()</span><br><span class="line">                .identityPoolId(identityPoolId)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        String identityId = cognitoIdentityClient.getId(getIdRequest).identityId();</span><br><span class="line">        GetCredentialsForIdentityRequest getCredentialsForIdentityRequest = GetCredentialsForIdentityRequest.builder()</span><br><span class="line">                .identityId(identityId)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        Credentials credentials = cognitoIdentityClient.getCredentialsForIdentity(getCredentialsForIdentityRequest).credentials();</span><br><span class="line">        <span class="keyword">return</span> AwsSessionCredentials.create(credentials.accessKeyId(), credentials.secretKey(), credentials.sessionToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="User-Pool-JWT-Token"><a href="#User-Pool-JWT-Token" class="headerlink" title="User Pool JWT Token"></a>User Pool JWT Token</h4><p>발급된 크레덴셜으로 사용자 풀에 등록되어있는 사용자의 JWT 토큰을 조회하기 위하여 Lambda 함수를 호출합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">jwt</span><span class="params">(AwsSessionCredentials awsSessionCredentials, Region region)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// https://docs.aws.amazon.com/code-samples/latest/catalog/javav2-lambda-src-main-java-com-example-lambda-LambdaInvoke.java.html</span></span><br><span class="line">    <span class="keyword">try</span> (LambdaClient lambdaClient = LambdaClient.builder()</span><br><span class="line">            .credentialsProvider(StaticCredentialsProvider.create(awsSessionCredentials))</span><br><span class="line">            .region(region)</span><br><span class="line">            .build()) &#123;</span><br><span class="line"></span><br><span class="line">        InvokeRequest invokeRequest = InvokeRequest.builder()</span><br><span class="line">                .functionName(authLambda)</span><br><span class="line">                .payload(SdkBytes.fromString(gson.toJson(authLambdaPayload), StandardCharsets.UTF_8))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        InvokeResponse invokeResponse = lambdaClient.invoke(invokeRequest);</span><br><span class="line">        Map&lt;String, Object&gt; responsePayload = gson.fromJson(<span class="keyword">new</span> String(invokeResponse.payload().asByteArray(), StandardCharsets.UTF_8),</span><br><span class="line">                <span class="keyword">new</span> TypeToken&lt;HashMap&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">                &#125;.getType());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (String) ((Map&lt;String, Object&gt;) responsePayload.get(<span class="string">&quot;credentials&quot;</span>)).get(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Identity-Provider-with-Logins"><a href="#Identity-Provider-with-Logins" class="headerlink" title="Identity Provider with Logins"></a>Identity Provider with Logins</h4><p>인증된 사용자의 JWT 토큰을 Cognito 자격 증명 공급자의 <strong>Logins</strong> 맵에 부여하여 크레덴셜을 발급합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COGNITO_IDENTITY_PROVIDER_URL = <span class="string">&quot;cognito-idp.%s.amazonaws.com/%s&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Credentials <span class="title">loginsCredentials</span><span class="params">(String identityPoolId, Region region, String userPoolId, String accessToken)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; logins = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    logins.put(String.format(COGNITO_IDENTITY_PROVIDER_URL, region.id(), userPoolId), accessToken);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (CognitoIdentityClient cognitoIdentityClient = CognitoIdentityClient.builder()</span><br><span class="line">            .credentialsProvider(AnonymousCredentialsProvider.create())</span><br><span class="line">            .region(region)</span><br><span class="line">            .build()) &#123;</span><br><span class="line"></span><br><span class="line">        GetIdRequest getIdRequest = GetIdRequest.builder()</span><br><span class="line">                .identityPoolId(identityPoolId)</span><br><span class="line">                .logins(logins)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        String identityId = cognitoIdentityClient.getId(getIdRequest).identityId();</span><br><span class="line">        GetCredentialsForIdentityRequest getCredentialsForIdentityRequest = GetCredentialsForIdentityRequest.builder()</span><br><span class="line">                .identityId(identityId)</span><br><span class="line">                .logins(logins)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cognitoIdentityClient.getCredentialsForIdentity(getCredentialsForIdentityRequest).credentials();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-integrating-user-pools-with-identity-pools.html#amazon-cognito-integrating-user-pools-with-identity-pools-using">Integrating a User Pool with an Identity Pool</a></p>
</blockquote>
<h3 id="Connenction-using-MqttClient"><a href="#Connenction-using-MqttClient" class="headerlink" title="Connenction using MqttClient"></a>Connenction using MqttClient</h3><p>Amazon Cognito를 사용하여 AWS 서비스에 인증할 수 있는 크레덴셜을 발급했습니다. 이제 이 크레덴셜을 사용하여 MQTT 클라이언트로 AWS IoT의 MQTT 메시지 브로커에 연결할 수 있습니다. AWS IoT Device SDK에서는 AWSIotMqttClient로 연결할 수 있지만 <strong>AWS IoT Device SDK v2</strong>에서는 MqttClientConnection로 연결할 수 있습니다.</p>
<blockquote>
<p>SDK V2들은 C로 작성된 <a href="https://docs.aws.amazon.com/sdkref/latest/guide/common-runtime.html">AWS Common Runtime</a> 기반하에 동작하게 됩니다.</p>
</blockquote>
<p>MqttClientConnection는 자바 8의 CompletableFuture을 통해 비동기로 수행되어 다음과 같이 사용할 수 있습니다.</p>
<p>먼저, AwsIotMqttConnectionBuilder를 사용하여 크레덴셜을 기반으로 MqttClientConnection를 생성합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> MqttClientConnection <span class="title">build</span><span class="params">(String clientEndpoint, String clientId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        String accessKeyId, String secretKey, String sessionToken, String region)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (EventLoopGroup eventLoopGroup = <span class="keyword">new</span> EventLoopGroup(<span class="number">1</span>);</span><br><span class="line">            HostResolver resolver = <span class="keyword">new</span> HostResolver(eventLoopGroup);</span><br><span class="line">            ClientBootstrap clientBootstrap = <span class="keyword">new</span> ClientBootstrap(eventLoopGroup, resolver);</span><br><span class="line">            AwsIotMqttConnectionBuilder builder = AwsIotMqttConnectionBuilder.newDefaultBuilder()) &#123;</span><br><span class="line"></span><br><span class="line">        StaticCredentialsProvider credentialsProvider =</span><br><span class="line">                <span class="keyword">new</span> StaticCredentialsProvider.StaticCredentialsProviderBuilder()</span><br><span class="line">                        .withAccessKeyId(accessKeyId.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                        .withSecretAccessKey(secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                        .withSessionToken(sessionToken.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .withEndpoint(clientEndpoint)</span><br><span class="line">                .withClientId(clientId)</span><br><span class="line">                .withBootstrap(clientBootstrap)</span><br><span class="line">                .withSocketOptions(<span class="keyword">new</span> SocketOptions())</span><br><span class="line">                .withWebsockets(<span class="keyword">true</span>)</span><br><span class="line">                .withWebsocketCredentialsProvider(credentialsProvider)</span><br><span class="line">                .withWebsocketSigningRegion(region)</span><br><span class="line">                .withConnectionEventCallbacks(clientConnectionEvents())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만들어진 MqttClientConnection는 자바 8의 CompletableFuture로 동작하므로 다음과 같이 비동기로 수행할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;squid:S3740&quot;, &quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Credentials credentials)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MqttClientConnection connection = build(clientEndpoint, clientId,</span><br><span class="line">                credentials.accessKeyId(), credentials.secretKey(), credentials.sessionToken(), region.id());</span><br><span class="line">        CompletableFuture&lt;Boolean&gt; connectFuture = connection.connect();</span><br><span class="line">        connectFuture.get();</span><br><span class="line"></span><br><span class="line">        ListenableFutureTask futureTask = <span class="keyword">new</span> ListenableFutureTask(() -&gt;</span><br><span class="line">                connection.subscribe(<span class="string">&quot;thing-update/#&quot;</span>, QualityOfService.AT_MOST_ONCE, handler -&gt; &#123;</span><br><span class="line">                    String payload = <span class="keyword">new</span> String(handler.getPayload(), StandardCharsets.UTF_8);</span><br><span class="line">                    log.info(<span class="string">&quot;topic:&#123;&#125;, qos: &#123;&#125;&quot;</span>, handler.getTopic(), handler.getQos());</span><br><span class="line">                    log.trace(<span class="string">&quot;===&gt; &#123;&#125;&quot;</span>, payload);</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">        futureTask.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException | ExecutionException e) &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ListenableFutureTask는 스프링에서 지원하는 클래스입니다.</p>
</blockquote>
<h4 id="AWS-IoT-Client-Endpoint"><a href="#AWS-IoT-Client-Endpoint" class="headerlink" title="AWS IoT Client Endpoint"></a>AWS IoT Client Endpoint</h4><p>AWS IoT 엔드포인트는 <a href="distrust-symantec-ca-in-jdk">시만텍 CA 인증서를 신뢰하지 않음</a> 문제가 발생하지 않도록 <strong>ATS CA 인증서</strong> 에서 서명한 인증서를 제공하는 ATS 엔드포인트로 설정합니다.</p>
<figure class="highlight properties"><figcaption><span>application.properties</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">aws-iot.client.endpoint</span>=<span class="string">&#123;ACCOUNT_SPECIFIC_PREFIX&#125;-ats.iot.&#123;REGION_ID&#125;.amazonaws.com</span></span><br><span class="line"><span class="meta">aws-iot.client.id</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>클라이언트 엔드포인트에 접근할 수 있는 인증된 사용자의 크레덴셜의 정보라면 메시지 페이로드가 구독된 것을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/aws-iot-mqtt-subscribe.png"></p>
<p>이상으로 AWS IoT Device SDK Java로 MQTT 연결하기를 마칩니다. 감사합니다.</p>
]]></content>
      <tags>
        <tag>AWS</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>시만텍 CA 인증서를 신뢰하지 않음</title>
    <url>/distrust-symantec-ca-in-jdk/</url>
    <content><![CDATA[<p>안녕하세요. Mambo 입니다. </p>
<p>이번에 공유할 내용은 OpenJDK에서 Symantec에서 발급된 TLS 인증서를 JDK에서 신뢰하지 않는 문제를 경험하고 이에 대한 문제를 임시조치하고 해결책을 찾아본 이야기입니다. </p>
<h2 id="어떤-문제가-발생했나요"><a href="#어떤-문제가-발생했나요" class="headerlink" title="어떤 문제가 발생했나요?"></a>어떤 문제가 발생했나요?</h2><p>현재 일하고 있는 회사에서 개발중인 프로젝트에서는 업무 협약으로 <a href="https://www.telenorconnexion.com/ko/">텔레노어 커넥션(Telenor Connecxion)</a>에서 제공하는 <a href="https://docs.telenorconnexion.com/mic/thing-api/">Thing API</a>를 사용하여 MQTT 기능을 접목하였습니다. 텔레노어 커넥션에서 제공하는 Thing API는 <a href="https://aws.amazon.com/iot/">AWS IoT</a>를 사용하여 MQTT version 3.1.1 기반의 브로커 서비스를 제공합니다. </p>
<p>그런데 얼마전 텔레노어 커넥션의 Managed IoT Cloud에 MQTT 클라이언트를 연결하려고 시도하였으나 다음과 같은 오류가 발생하였습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: </span><br><span class="line">TLS Server certificate issued after 2019-04-16 and anchored by a distrusted legacy Symantec root CA</span><br></pre></td></tr></table></figure>

<p>위 오류는 JDK에서 TLS 연결 시 시만텍 CA 인증서를 신뢰하지 않으므로 오류를 발생한 내용입니다. 왜 신뢰하지 않고 왜 갑자기 이런 오류가 뜨는걸까요?</p>
<h3 id="OpenJDK-Distrust-Symantec-CA"><a href="#OpenJDK-Distrust-Symantec-CA" class="headerlink" title="OpenJDK Distrust Symantec CA"></a>OpenJDK Distrust Symantec CA</h3><p><a href="https://zdnet.co.kr/view/?no=20170331133307">구글의 ‘시만텍 불신’ 빌미 된 한국 파트너</a>라는 기사에서 구글이 시만텍에서 발급된 인증서를 신뢰하지 않기로 했다는 내용을 확인하였고 더 찾아보니 <a href="https://security.googleblog.com/2017/09/chromes-plan-to-distrust-symantec.html">Chrome’s Plan to Distrust Symantec Certificates</a>와 에서 구글 뿐만 아니라 모질라, 애플, 마이크로소프트에서 조차 시만텍에서 서명한 인증서를 신뢰하지 않겠다고 발표함으로써 오라클에서도 JDK에서 <strong>2019년 4월 16일 이후에 서명된 시만텍 인증서</strong>를 신뢰하지 않기로 조치하였습니다.</p>
<ul>
<li><a href="https://blogs.oracle.com/java-platform-group/jdk-distrusting-symantec-tls-certificates">Oracle’s Plan for Distrusting Symantec TLS Certificates in the JDK</a></li>
<li><a href="https://bugs.openjdk.java.net/browse/JDK-8215012">Release Note: Distrust TLS Server Certificates Anchored by Symantec Root CAs</a></li>
</ul>
<h2 id="어떻게-조치하셨나요"><a href="#어떻게-조치하셨나요" class="headerlink" title="어떻게 조치하셨나요?"></a>어떻게 조치하셨나요?</h2><h3 id="임시조치"><a href="#임시조치" class="headerlink" title="임시조치"></a>임시조치</h3><p><a href="https://blogs.oracle.com/java-platform-group/jdk-distrusting-symantec-tls-certificates">Oracle’s Plan for Distrusting Symantec TLS Certificates in the JDK</a>에서 시만텍 인증서를 신뢰하지 않도록 처리되는 내용과 함께 <code>jdk.security.caDistrustPolicies</code> 옵션을 수정하여 SYMANTEC_TLS에 대한 신뢰하지 않는 것을 무시하도록 설정할 수 있음을 알려주고 있습니다.</p>
<p>또한, 스택오버플로우에서 <a href="https://stackoverflow.com/questions/58437531/how-to-fix-javax-net-ssl-sslhandshakeexception-tls-server-certificate-issued-a">동일한 문제</a>에 대한 답변으로 위 속성을 주석처리하라는 것을 확인하였으며 이에 따라 임사로 Dockerfile로 도커 이미지를 구성할 때와 Beanstalk 자바 플랫폼 환경을 확장하는 파일에 다음과 같이 변경하여 조치하였습니다.</p>
<p><strong>에이전트 실행 환경 이미지</strong>  </p>
<figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> amazoncorretto:<span class="number">11</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i.old <span class="string">&#x27;s/^jdk\.security\.caDistrustPolicies=SYMANTEC_TLS$/#&amp;/g&#x27;</span> /usr/lib/jvm/java-11-amazon-corretto/conf/security/java.security</span></span><br></pre></td></tr></table></figure>

<p><strong>AWS Beanstalk 구성 확장</strong>  </p>
<figure class="highlight plaintext"><figcaption><span>.ebextensions/00-java-ca-distrust-policies.config</span></figcaption><table><tr><td class="code"><pre><span class="line">files:</span><br><span class="line">  &quot;/tmp/set_symantec_tls.sh&quot;:</span><br><span class="line">    mode: &quot;000755&quot;</span><br><span class="line">    owner: root</span><br><span class="line">    group: root</span><br><span class="line">    content: |</span><br><span class="line">      #!/bin/bash</span><br><span class="line">      sed -i.old &#x27;s/^jdk\.security\.caDistrustPolicies=SYMANTEC_TLS$/#&amp;/g&#x27; /usr/lib/jvm/java-11-amazon-corretto.x86_64/conf/security/java.security</span><br><span class="line"></span><br><span class="line">commands:</span><br><span class="line">  00-set_symantec_tls:</span><br><span class="line">    command: /tmp/set_symantec_tls.sh</span><br></pre></td></tr></table></figure>

<p>위 작업 후 시만텍 인증서를 신뢰하지 않는 정책에 대한 옵션이 적용되지 않아 JDK에서 정상적으로 TLS 연결을 수행하는 것을 확인할 수 있었습니다. 이제 이것이 임시로 조치된 작업인 이유를 알아보도록 하겠습니다.</p>
<h3 id="근본적인-해결책"><a href="#근본적인-해결책" class="headerlink" title="근본적인 해결책"></a>근본적인 해결책</h3><p>앞서 AWS IoT의 엔드포인트는 레거시와 ATS를 지원한다고 하였는데요. 이 부분에서 이상함을 느끼고 관련 문서들을 찾아보기 시작했습니다. </p>
<p>AWS IoT는 TLS와 X.509 인증서를 사용하여 <a href="https://docs.aws.amazon.com/ko_kr/iot/latest/developerguide/server-authentication.html">인증</a>을 수행해야합니다. 그리고 Aws IoT Core는 VeriSign에서 서명한 인증서를 제공하는 레거시 엔드포인트와 ATS(Amazon Trust Services) CA에서 서명한 인증서를 제공하는 ATS 엔드포인트를 지원합니다. AWS IoT에서는 시만텍 인증서를 더이상 사용하지 않는다며 레거시 엔드포인트가 아닌 ATS를 사용하는 것을 권장하고 있었습니다.</p>
<p><img data-src="/images/posts/distrust-symantec-ca-in-jdk/distrust-symantec-ca-in-jdk-01.png"></p>
<p>음… 그러면 텔레노어의 Thing API가 레거시 엔드포인트만 지원하는 걸까?</p>
<p><img data-src="/images/posts/distrust-symantec-ca-in-jdk/distrust-symantec-ca-in-jdk-02.png" alt="Telenor Connexion Thing API"></p>
<p>텔레노어의 Managed IoT Cloud도 AWS IoT 플랫폼을 사용하므로 동일하게 레거시 엔드포인트를 사용할 수는 있었고 텔레노어 측 문서에서조차 ATS 엔드포인트를 언급하고 있었습니다. 사실 텔레노어 API 연동 작업을 제가 적용했던 것은 아니고 이 부분을 진행하셨던 분이 퇴사하신 상황이었습니다. 그리고 얼마전 개발자 한분이 텔레노어 관련 코드를 수정하면서 시만텍 인증서를 신뢰하지 않는다는 오류가 발생한 상황입니다.</p>
<p>그럼 수정한 내역 중에서 이 문제가 발생한 근본적인 원인이 있을테니 이를 검토해보았습니다. 프로젝트는 Git으로 소스코드에 대한 변경사항을 버저닝하므로 변경 내역을 트래킹할 수 있어 깃허브에 들어가 관련 커밋을 찾아보았습니다.</p>
<p><img data-src="/images/posts/distrust-symantec-ca-in-jdk/distrust-symantec-ca-in-jdk-03.png" alt="깃허브 이슈 번호 기반 트래킹"></p>
<p>저희는 커밋 메시지에 관련된 이슈(작업) 번호를 명시하도록 하였기에 쉽게 해당 이슈와 관련된 커밋들을 추적할 수 있었습니다. </p>
<p><img data-src="/images/posts/distrust-symantec-ca-in-jdk/distrust-symantec-ca-in-jdk-04.png"></p>
<p>회사 코드이므로 주요 정보는 마스킹 처리했으며 잘 살펴보니 뭔가 다르게 변경된 내용이 있었습니다.</p>
<p><img data-src="/images/posts/distrust-symantec-ca-in-jdk/distrust-symantec-ca-in-jdk-05.png" alt="앗. 엔드포인트??"></p>
<p>엔드포인트?! 기존에 사용하던 엔드포인트 주소는 -ats가 붙어있지만 변경된 엔드포인트는 ats가 없었습니다. ATS 엔드포인트 유형의 형태는 어떻게 되는지 찾아보았는데요.</p>
<p><strong><a href="https://aws.amazon.com/ko/blogs/iot/aws-iot-core-ats-endpoints/">How AWS IoT Core is Helping Customers Navigate the Upcoming Distrust of Symantec Certificate Authorities</a></strong><br><img data-src="/images/posts/distrust-symantec-ca-in-jdk/distrust-symantec-ca-in-jdk-06.png"></p>
<p><strong><a href="https://docs.aws.amazon.com/ko_kr/iot/latest/developerguide/connect-to-iot.html#iot-device-endpoint-intro">AWS IoT device endpoints</a></strong><br><img data-src="/images/posts/distrust-symantec-ca-in-jdk/distrust-symantec-ca-in-jdk-07.png"></p>
<p>ATS 엔드포인트 형태는 <strong>prefix-ats.iot.region.amazonaws.com</strong>가 된다고 합니다. 그러니까 결국 ATS 엔드포인트로 제대로 사용하고 있던 기존 설정을 레거시 엔드포인트로 변경해버려서 발생한 오류였습니다. 텔레노어 계정을 변경하기 위하여 다시 발급하면서 엔드포인트를 변경해버렸고 시만텍 인증서를 제공하는 엔드포인트이므로 JDK에서 신뢰하지 못하는 것으로 처리된 것이었습니다.</p>
<h2 id="끝마치며"><a href="#끝마치며" class="headerlink" title="끝마치며"></a>끝마치며</h2><p>알고보니 <code>개발자의 사소한 실수(?)</code>로 발생한 문제였으나 JDK에서 신뢰하지 못하도록 하는 정책 옵션이 있다는 것도 알게되었고 시만텍에서 서명한 인증서를 신뢰하지 못하게 된 사건도 알게되는 꽤 유익한 트러블이었던 것 같습니다. </p>
<p>다음의 JDK 버전은 시만텍에서 서명한 인증서를 신뢰하지 못하도록 처리되었으니 참고하시기 바랍니다.</p>
<ul>
<li>JDK 7u221 이상 </li>
<li>JDK 8u212 이상</li>
<li>JKD 11.0.3 이상</li>
</ul>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Symantec Root CA</tag>
        <tag>Distrust</tag>
      </tags>
  </entry>
  <entry>
    <title>EC2 인스턴스에서 S3 버킷 액세스하기</title>
    <url>/ec2-instance-access-s3-bucket/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 EC2 인스턴스에서 S3 버킷에 액세스할 수 있도록 구성하는 방법에 대해 알아봅니다.</p>
<p>최근 회사에서 진행하고 있는 프로젝트 중에는 보안 정책에 의해 고객이 구성한 EC2 인스턴스에 대한 접근 정보만을 제공받아 애플리케이션 실행해야하는 요구사항이 생겼습니다. 현재 애플리케이션에서 사용중인 데이터베이스 중에는 EC2 인스턴스에 직접 설치하여 사용하고 있는 상용 시계열 데이터베이스가 있습니다. 이 데이터베이스의 데이터를 주기적으로 백업하기 위하여 매일 1시에 파일로 저장된 데이터를 압축하여 S3로 저장하는 스크립트를 수행하고 있습니다. 고객이 보유한 EC2 인스턴스에서 이 데이터베이스의 백업 파일을 저장하기 위한 S3 버킷에 대한 권한을 지정해주도록 유도할 예정입니다.</p>
<h2 id="S3-버킷-정책"><a href="#S3-버킷-정책" class="headerlink" title="S3 버킷 정책"></a>S3 버킷 정책</h2><p>S3에서 버킷을 만들면 기본적으로 <strong>모든 퍼블릭 액세스 차단</strong>됩니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-01.png"></p>
<p>그리고 <strong>버킷 정책</strong>을 통해 버킷 또는 버킷에 저장된 오브젝트에 대한 액세스 권한을 부여할 수 있습니다. </p>
<h3 id="버킷-정책-생성"><a href="#버킷-정책-생성" class="headerlink" title="버킷 정책 생성"></a>버킷 정책 생성</h3><p>버킷 정책을 생성할 때는 아마존 웹 서비스에서 제공하는 <a href="http://awspolicygen.s3.amazonaws.com/policygen.html">AWS Policy Generator</a>를 사용하는 것이 좋습니다.</p>
<p>다음은 특정 IP에 대해서 버킷에 대한 조회, 읽기, 쓰기 권한을 부여하는 정책을 생성한 예시입니다.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Principal&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Action&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;s3:ListBucket&quot;</span>,</span><br><span class="line">                <span class="string">&quot;s3:GetObject&quot;</span>,</span><br><span class="line">                <span class="string">&quot;s3:PutObject&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::mambo.kr&quot;</span>,</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::mambo.kr/*&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Condition&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;IpAddress&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;aws:SourceIp&quot;</span>: <span class="string">&quot;218.156.190.x/32&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>버킷 정책을 정의하는 JSON의 크기는 20kB로 제한됩니다.</p>
</blockquote>
<p>버킷 정책에 대한 더 자세한 내용은 <a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/example-bucket-policies.html">버킷 정책 예제</a> 문서를 참고하세요.</p>
<h2 id="EC2-인스턴스"><a href="#EC2-인스턴스" class="headerlink" title="EC2 인스턴스"></a>EC2 인스턴스</h2><p>아마존 리눅스 AMI로 EC2 인스턴스를 실행하면 AWS CLI가 기본으로 설치되어있습니다. 따라서, AWS CLI를 사용해서 S3 서비스에 작업을 수행할 수 있습니다.</p>
<h3 id="IAM-역할-생성"><a href="#IAM-역할-생성" class="headerlink" title="IAM 역할 생성"></a>IAM 역할 생성</h3><p>S3 버킷 권한 설정에서 버킷 정책을 설정할 수 있으나 IAM 역할을 만들고 인라인 정책으로 적용할 수도 있습니다. 우리는 EC2 인스턴스에서 접근해야하므로 EC2 서비스에 대한 IAM 역할을 만들어서 인스턴스 프로파일로 등록하겠습니다.</p>
<p>먼저, EC2 인스턴스에서 AWS CLI로 버킷을 조회해보겠습니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-02.png"></p>
<p>현재 EC2 인스턴스에는 IAM 인스턴스 프로파일이 지정되어있지 않기 때문에 오류가 발생합니다.</p>
<p>IAM 메뉴에서 신규로 역할을 생성합니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-03.png"></p>
<p>S3 버킷에 대한 권한을 인라인 정책으로 정의할 것이므로 관리형 정책은 설정하지않습니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-04.png"></p>
<p>생성한 IAM 역할을 EC2 인스턴스 프로파일로 지정합니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-05.png"></p>
<p>IAM 역할에 어떠한 정책을 적용하지 않고 버킷을 조회해보겠습니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-06.png"></p>
<p>IAM 역할을 지정하였기에 AWS CLI를 사용할 수 있게 되었지만 mambo.kr 이라는 버킷에 대한 ListObjectsV2 작업은 Access Denied 오류가 발생했습니다.</p>
<h3 id="인라인-정책"><a href="#인라인-정책" class="headerlink" title="인라인 정책"></a>인라인 정책</h3><p>우리가 생성한 IAM 역할에는 어떠한 정책도 연결하지 않았기 때문에 접근 권한을 가지지 않는게 당연합니다. 다시 IAM 메뉴로 돌아가서 <strong>인라인 정책 추가</strong>를 선택합니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-07.png"></p>
<p>버킷 정책 예제를 참고해서 다음과 같이 JSON 형식으로 버킷 정책을 정의합니다.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Sid&quot;</span>: <span class="string">&quot;Mannual&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Action&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;s3:ListBucket&quot;</span>,</span><br><span class="line">                <span class="string">&quot;s3:GetObject&quot;</span>,</span><br><span class="line">                <span class="string">&quot;s3:PutObject&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::mambo.kr&quot;</span>,</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::mambo.kr/*&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-08.png"></p>
<h3 id="버킷-조회"><a href="#버킷-조회" class="headerlink" title="버킷 조회"></a>버킷 조회</h3><p>S3 버킷에 대한 정책이 IAM 인라인 정책으로 연결되었으니 버킷에 대한 접근 권한이 가지게 되었는지 확인합니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-09.png"></p>
<p>EC2 인스턴스에서 사용자 계정의 보유한 S3 버킷에 대한 목록은 권한이 없어서 조회할 수 없으나 인라인 정책으로 정의된 mambo.kr 버킷에 대해서는 조회되었습니다.</p>
<p>만약, S3 버킷 목록을 조회하고 싶다면 다음과 같이 Statement를 추가하시면 됩니다.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Sid&quot;</span>: <span class="string">&quot;Mannual&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Action&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;s3:ListBucket&quot;</span>,</span><br><span class="line">                <span class="string">&quot;s3:GetObject&quot;</span>,</span><br><span class="line">                <span class="string">&quot;s3:PutObject&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::mambo.kr&quot;</span>,</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::mambo.kr/*&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Sid&quot;</span>: <span class="string">&quot;Mannual-2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Action&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;s3:ListBucket&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::*/*&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>빈 텍스트 파일을 만들어서 버킷에 업로드하고 가져올 수 있는지 확인해보겠습니다.</p>
<p><img data-src="/images/posts/ec2-instance-access-s3-bucket/s3-bucket-10.png"></p>
<p>S3에 저장할 수 있는 크기에 대한 제한은 없으나 PUT 요청으로 업로드 가능한 크기는 최대 5GB입니다. AWS CLI의 S3 명령어를 사용하는 경우 일정 크기 이상이라면 멀티파트 업로드를 수행하므로 알고 계시고 신경쓰지 않아도 됩니다.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>퍼블릭 IP가 할당되지 않는 EC2 인스턴스라면 AWS PrivateLink로 구성되는 VPC 인터페이스 엔드포인트를 사용하여 <a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/privatelink-interface-endpoints.html">S3 서비스와 통신할 수 있도록 설정</a>해야합니다. 그리고 다른 사용자 계정의 ARN을 제공받아서 접근할 수 있게 구성할 수도 있으니 공식 문서에서 제공하는 다양한 정책 예제를 참고해봅시다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>EC2</tag>
        <tag>S3</tag>
      </tags>
  </entry>
  <entry>
    <title>ED25519</title>
    <url>/ed25519/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 보안 관련 기술인 타원곡선 암호 알고리즘을 기반으로 하는 <strong>ED25519</strong>라는 것에 대해 알아보려고 합니다. </p>
<p>아마존 웹 서비스에서는 2021년 8월 17일부터 EC2 인스턴스 접근을 위해 <a href="https://aws.amazon.com/about-aws/whats-new/2021/08/amazon-ec2-customers-ed25519-keys-authentication/">ED25519 형식의 키로 SSH 연결을 수행할 수 있도록 지원</a>하였으며 2021년 9월 1일에는 깃허브에서도 DSA 형식의 키를 제거하고 <a href="https://github.blog/2021-09-01-improving-git-protocol-security-github/">ECDSA와 ED25519 형식의 키를 추가</a>하기로 결정하였습니다. </p>
<p>공통으로 언급되고 있는 ED25519라는 것을 모르시는 분이라면 저와 함께 알아보도록 합시다. </p>
<p><img data-src="/images/posts/ed25519/ed25519-00.gif"></p>
<h2 id="ED25519"><a href="#ED25519" class="headerlink" title="ED25519"></a>ED25519</h2><p>ED25519(Ed25519)는 ECC(Elliptic Curve Cryptography) 알고리즘으로 수행하도록 구현된 전자서명입니다. 타원곡선 암호 알고리즘을 사용하는 공개키 암호화 방식은 <strong>기존의 RSA와 비교해서 동일한 안정성을 가지면서도 상대적으로 더 적은 길이의 키</strong>를 가진다고 합니다. 컴퓨터 연산 속도가 발전함에 따라 일반적으로 사용되는 RSA의 권장되는 키 길이가 길어짐으로 인하여 일반 컴퓨터 또는 디바이스에서는 연산 속도가 느려지는 단점을 가지게 되고 상대적으로 작은 키 길이를 사용할 수 있으면서 동일한 안정성을 보여주므로 권장되는 공개키 암호화 방식이라고 할 수 있습니다.</p>
<blockquote>
<p>RSA와 비교해서 보안적으로 우수하다고 볼 순 없지만 상대적으로 비교하여 효율적이라는 것을 이해하셔야합니다.</p>
</blockquote>
<h3 id="타원-곡선"><a href="#타원-곡선" class="headerlink" title="타원 곡선"></a>타원 곡선</h3><p>ED25519는 어떤 타원 곡선을 사용하여 구현된 전자서명일지 궁금해집니다. 다음은 암호화에 적합하다고 판단되어 표준으로 정의된 타원 곡선들입니다.</p>
<ul>
<li>secp256k1</li>
<li>secp256r1</li>
<li>prime256v1</li>
<li>Curve25519</li>
</ul>
<p>미국 국립표준연구소(NIST) 또는 <a href="https://www.secg.org/">표준 암호화 그룹(SECG)</a>에서는 효율적인 타원 곡선들에 이름을 부여했습니다. 예를 들어, ECC NIST P-256은 SECG에서 정의한 secp256r1과 prime256v1를 지칭한 것과 같습니다. </p>
<p>표준으로 정의된 다양한 타원 곡선들에 대한 자세한 내용은 다음의 두 문서를 통해 확인할 수 있습니다.</p>
<ul>
<li><a href="https://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a></li>
<li><a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">Digital Signature Standard (DSS)</a></li>
</ul>
<p>저로서는 이해하기 힘든 부분이라고 생각하여 설명은 생략하며 간단하게 말해서 여러가지 타원 곡선 형태를 <strong>도메인 파라미터로 정의</strong>하여 이름을 부여한 것 입니다. NIST P-256은 NIST에서 정의한 소수 기반의 타원 곡선 방정식을 말하며 <a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a>는 SECG에서 정의한 Koblitz curve 기반의 타원 곡선 방정식을 말합니다. </p>
<blockquote>
<p>비트코인과 이더리움에서도 secp256k1 라는 타원곡선을 사용한다고…</p>
</blockquote>
<h3 id="키-교환과-전자-서명"><a href="#키-교환과-전자-서명" class="headerlink" title="키 교환과 전자 서명"></a>키 교환과 전자 서명</h3><p>타원 곡선을 사용하여 디피-헬먼 키 교환을 구현한 알고리즘을 ECDH라고 하며 타원 곡선 암호를 사용해서 <a href="https://ko.wikipedia.org/wiki/%EB%94%94%EC%A7%80%ED%84%B8_%EC%84%9C%EB%AA%85_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">전자서명 알고리즘(DSA)</a>를 구현한 것을 <strong>ECDSA</strong>라고 합니다. ECDSA는 지난 <a href="../ssl-certificate">SSL 인증서</a> 글에서 TLS 핸드쉐이크 과정에서 ECDHE_ECDSA와 같은 타원 곡선 암호 방식을 사용하는 것을 통해 이미 확인한 개념인데 기억하시는 분이 계실지 모르겠습니다.</p>
<p>타원 곡선 기반의 전자 서명 알고리즘에는 <a href="https://en.wikipedia.org/wiki/EdDSA">EdDSA</a>도 있으며 <strong>Twisted Edwards curve</strong>와 <strong>Schnorr 서명 방식</strong>을 사용하도록 구현된 DSA 입니다.</p>
<h3 id="X25519-그리고-Ed25519"><a href="#X25519-그리고-Ed25519" class="headerlink" title="X25519 그리고 Ed25519"></a>X25519 그리고 Ed25519</h3><p>앞서 언급된 타원 곡선 중 Curve25519는 키 교환 알고리즘인 디피-헬먼과 같이 사용하도록 고안된 타원 곡선입니다. Curve25519를 기반으로하여 ECDH로 키 교환을 수행하는 것을 X25519라고 하게 됩니다. 그리고 Curve25519과 함께 SHA-512와 같은 <strong>해시 함수</strong>를 사용하는 구현된 EdDSA를 <strong>Ed25519</strong>라는 이름으로 부르게 됩니다. </p>
<ul>
<li>ECDSA : 타원 곡선 기반의 전자 서명 알고리즘</li>
<li>X25519 : Curve25519를 사용하는 타원 곡선 키 교환 알고리즘</li>
<li>Ed25519 : Curve25519를 사용하는 타원 곡선 전자 서명 알고리즘 </li>
</ul>
<p><img data-src="/images/posts/ed25519/ed25519-04.gif" alt="머리속에 정리가 잘 되셨나요?"></p>
<h3 id="ED25519-키-페어"><a href="#ED25519-키-페어" class="headerlink" title="ED25519 키 페어"></a>ED25519 키 페어</h3><p>지금부터는 ED25519 형식의 키 페어를 만들고 EC2 인스턴스에 접근해보는 것을 따라해보겠습니다. </p>
<h4 id="키-페어-생성하기"><a href="#키-페어-생성하기" class="headerlink" title="키 페어 생성하기"></a>키 페어 생성하기</h4><p>먼저, ED25519 형식의 키 페어는 OpenSSH를 통해 만들 수도 있고 아마존 웹 서비스를 통해 ED25519 형식의 키 페어를 생성할 수 있습니다. </p>
<p><img data-src="/images/posts/ed25519/ed25519-01.png"></p>
<blockquote>
<p>2021년 8월 17일 부터는 콘솔을 통해 ED25119 키 페어를 사용하여 EC2 인스턴스 연결이 가능하다고 했는데 우측 제약사항에는 아직 업데이트되지 않은 듯 합니다.</p>
</blockquote>
<p>아래와 같이 AWS CLI의 create-key-pair 명령어를 통해서도 ED25519 키 페어를 생성할 수 있습니다.</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">aws ec2 create<span class="literal">-key</span><span class="literal">-pair</span> -<span class="literal">-key</span><span class="literal">-name</span> mambo -<span class="literal">-key</span><span class="literal">-type</span> ed25519 -<span class="literal">-query</span> <span class="string">&quot;KeyMaterial&quot;</span> -<span class="literal">-output</span> text &gt; aws<span class="literal">-mambo</span>.pem</span><br><span class="line">aws ec2 describe<span class="literal">-key</span><span class="literal">-pairs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;KeyPairs&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;KeyPairId&quot;</span>: <span class="string">&quot;###&quot;</span>,</span><br><span class="line">            <span class="string">&quot;KeyFingerprint&quot;</span>: <span class="string">&quot;###&quot;</span>,</span><br><span class="line">            <span class="string">&quot;KeyName&quot;</span>: <span class="string">&quot;mambo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;KeyType&quot;</span>: <span class="string">&quot;ed25519&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Tags&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>아마존 웹 서비스에 키 페어가 생성되었으면 VPC에 EC2 인스턴스를 시작할 때 SSH 접속 시 사용될 ED25519 키 페어를 선택할 수 있습니다. </p>
<p><img data-src="/images/posts/ed25519/ed25519-02.png"></p>
<p>EC2 인스턴스가 실행되었으면 아마존 웹 서비스 콘솔의 EC2 인스턴스 연결 기능을 통해 인스턴스에 접속해보겠습니다.</p>
<p><img data-src="/images/posts/ed25519/ed25519-03.png"></p>
<p>ED25519 키 페어를 사용해서 EC2 인스턴스 연결에 성공하였습니다. 그런데 말이죠, 아마존 웹 서비스에서 생성된 ED25519 키 페어를 윈도우 10에서 지원하는 SSH 클라이언트에서 사용해보면 잘못된 형식이라고 로그가 출력되고 EC2 인스턴스에 연결할 수 없음을 확인했습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -i &quot;aws-mambo.pem&quot; ec2-user@ec2-3-36-96-111.ap-northeast-2.compute.amazonaws.com</span><br><span class="line"></span><br><span class="line">The authenticity of host &#x27;ec2-3-36-96-111.ap-northeast-2.compute.amazonaws.com (3.36.96.111)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:gvSJ/qfnIlB8bkTE78QY65HO4px3YpoYvsyAv90LsTE.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;ec2-3-36-96-111.ap-northeast-2.compute.amazonaws.com,3.36.96.111&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line">Load key &quot;aws-mambo.pem&quot;: invalid format</span><br><span class="line">ec2-user@ec2-3-36-96-111.ap-northeast-2.compute.amazonaws.com: Permission denied (publickey,gssapi-keyex,gssapi-with-mic).</span><br></pre></td></tr></table></figure>

<p>아마존 웹 서비스가 만들어주는 ED25519 형식의 키 페어를 사용하지 않고 직접 윈도우 10에서 ssh-keygen을 통해 ED25519 형식의 키 페어를 생성하고 아마존 웹 서비스에 퍼블릭 키를 추가하면 정상적으로 EC2 인스턴스 연결할 수 있습니다. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -m PEM -f ./mambo.pem</span><br></pre></td></tr></table></figure>

<p>이처럼 아마존 웹 서비스에서 만들어주는 ED25519 형식의 키 페어는 윈도우에서 사용할 수 없기 때문에 주의해야할 것 같습니다.</p>
<p>타원곡선 암호에 대해서 더 자세히 알고 싶다면 다음의 글들을 참고해보시기를 추천드립니다.</p>
<ul>
<li><a href="https://medium.com/humanscape-tech/blockchain-elliptic-curve-cryptography-ecc-49e6d7d9a50a">[Blockchain] Elliptic Curve Cryptography(ECC)</a></li>
<li><a href="https://naleejang.tistory.com/218">보안 그리고 암호화 알고리즘</a></li>
</ul>
<p>감사합니다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc4492">Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc7748">Elliptic Curves for Security</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a></li>
<li><a href="https://ed25519.cr.yp.to/">Ed25519: high-speed high-security signatures</a></li>
</ul>
]]></content>
      <tags>
        <tag>ECC</tag>
        <tag>Ed25519</tag>
      </tags>
  </entry>
  <entry>
    <title>Elastic Beanstalk Docker Platform</title>
    <url>/elastic-beanstalk-docker-with-python/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 아마존 웹 서비스의 <strong>Elastic Beanstalk에서 지원하는 도커 컨테이너 환경을 통해 애플리케이션을 배포하는 방법</strong>에 대하여 알아봅니다. 이 글에서는 애플리케이션을 도커 이미지화하고 사설 도커 레지스트리 서버에 저장된 도커 이미지를 기반으로 Elastic Beanstalk 환경에서 도커 컴포즈를 활용해 애플리케이션을 실행하는 것을 설명합니다.</p>
<h2 id="도커-플랫폼"><a href="#도커-플랫폼" class="headerlink" title="도커 플랫폼"></a>도커 플랫폼</h2><p>Elastic Beanstalk의 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/docker.html">도커 플랫폼</a>은 도커 컨테이너 환경에서 애플리케이션을 실행하는 기능을 지원합니다. 도커 플랫폼을 사용해 애플리케이션을 배포하기 위해서는 도커 컨테이너와 Elastic Beanstalk에 대한 이해가 필요합니다. 도커 플랫폼에서는 Dockerfile을 사용하여 직접 도커 이미지를 빌드하여 도커 컨테이너를 실행하거나 <strong>Dockerrun.aws.json</strong> 파일로 컨테이너 환경을 정의할 수 있도록 지원합니다. 또한, <a href="https://docs.docker.com/registry/deploying/">도커 레지스트리 서버</a>에 저장된 이미지를 기반으로 컨테이너를 구성할 수 있는 <strong>도커 컴포즈</strong> 방식도 사용할 수 있습니다.</p>
<p>도커 플랫폼에서 도커 이미지화된 애플리케이션을 도커 컴포즈로 배포하기 위해서는 다음의 항목들을 작성해야합니다.</p>
<ul>
<li>애플리케이션 도커 이미지</li>
<li>플랫폼 확장 및 환경 구성 파일</li>
<li>도커 컴포즈 문서</li>
<li>도커 레지스트리 서버 인증 파일</li>
<li>도커 구성 파일</li>
</ul>
<blockquote>
<p>이 글에서는 도커 레지스트리 서버가 구축되어있다고 가정합니다.</p>
</blockquote>
<h3 id="애플리케이션-도커-이미지"><a href="#애플리케이션-도커-이미지" class="headerlink" title="애플리케이션 도커 이미지"></a>애플리케이션 도커 이미지</h3><p>Python으로 작성된 간단한 Flask 웹 애플리케이션을 작성하고 도커 이미지로 빌드하기 위한 <strong>Dockerfile</strong> 파일을 정의합니다. </p>
<figure class="highlight python"><figcaption><span>application.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># print a nice greeting.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">username = <span class="string">&quot;World&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;p&gt;Hello %s!&lt;/p&gt;\n&#x27;</span> % username</span><br><span class="line"></span><br><span class="line"><span class="comment"># EB looks for an &#x27;application&#x27; callable by default.</span></span><br><span class="line">application = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add a rule for the index page.</span></span><br><span class="line">application.add_url_rule(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, (<span class="keyword">lambda</span>: say_hello()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># run the app.</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Setting debug to True enables debug output. This line should be</span></span><br><span class="line">    <span class="comment"># removed before deploying a production app.</span></span><br><span class="line">    application.debug = <span class="literal">True</span></span><br><span class="line">    application.run()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>저는 파이썬을 다루지 않는 개발자이므로 파이썬을 설치하고 가상 환경을 시작하는 것은 생략하겠습니다.</p>
</blockquote>
<p>PIP 명령어를 사용하여 Python 애플리케이션에서 사용하는 패키지를 설치하기 위한 <strong>requirements.txt</strong>을 준비합니다.</p>
<figure class="highlight plaintext"><figcaption><span>requirements.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">click==8.0.1</span><br><span class="line">Flask==1.1.2</span><br><span class="line">itsdangerous==2.0.1</span><br><span class="line">Jinja2==3.0.1</span><br><span class="line">MarkupSafe==2.0.1</span><br><span class="line">Werkzeug==2.0.1</span><br></pre></td></tr></table></figure>

<p>그리고 도커 허브에 등록된 Python 이미지를 기반으로 requirements.txt을 기준의 패키지를 설치하는 <strong>Dockerfile</strong>을 정의합니다. </p>
<figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> PORT=<span class="number">8000</span></span><br><span class="line"><span class="keyword">ARG</span> MAIN=application</span><br><span class="line"><span class="keyword">ARG</span> MAIN_APP=application</span><br><span class="line"><span class="keyword">ARG</span> WORKERS=application</span><br><span class="line"><span class="keyword">ARG</span> WORKERS=<span class="number">2</span></span><br><span class="line"><span class="keyword">ARG</span> WORKERCLASS=gevent</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PORT $&#123;PORT&#125;</span><br><span class="line"><span class="keyword">ENV</span> MAIN $&#123;MAIN&#125;</span><br><span class="line"><span class="keyword">ENV</span> MAIN_APP $&#123;MAIN_APP&#125;</span><br><span class="line"><span class="keyword">ENV</span> WORKERS $&#123;WORKERS&#125;</span><br><span class="line"><span class="keyword">ENV</span> WORKERCLASS $&#123;WORKERCLASS&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install gunicorn</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> $&#123;PORT&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;chmod&quot;</span>, <span class="string">&quot;+x&quot;</span>, <span class="string">&quot;./entrypoint.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="string">&quot;./entrypoint.sh&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>마지막으로 <a href="https://docs.gunicorn.org/en/stable/">Gunicorn WSGI 서버</a>를 사용하여 Flask 웹 애플리케이션을 실행하는 <strong>엔트리포인트</strong>를 작성합니다.</p>
<figure class="highlight sh"><figcaption><span>entrypoint.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br><span class="line">gunicorn <span class="variable">$&#123;MAIN&#125;</span>:<span class="variable">$&#123;MAIN_APP&#125;</span> -b 0.0.0.0:<span class="variable">$&#123;PORT&#125;</span> -w <span class="variable">$&#123;WORKERS&#125;</span></span><br></pre></td></tr></table></figure>

<p>Dockerfile을 기반으로 애플리케이션을 도커 이미지로 생성하고 도커 레지스트리 서버에 빌드된 이미지를 저장합니다.</p>
<figure class="highlight zsh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">docker login https://registry.mambo.kr:5000</span><br><span class="line">Username: mambo</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br><span class="line">docker build -t registry.mambo.kr:5000/mambo-py:<span class="built_in">test</span></span><br><span class="line">docker push registry.mambo.kr:5000/mambo-py:<span class="built_in">test</span></span><br><span class="line">docker <span class="built_in">logout</span> registry.mambo.kr:5000/mambo-py:<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h3 id="플랫폼-확장-구성-파일"><a href="#플랫폼-확장-구성-파일" class="headerlink" title="플랫폼 확장 구성 파일"></a>플랫폼 확장 구성 파일</h3><p>Elastic Beanstalk에서도 Nginx 프록시 옵션을 설정할 수 있지만 도커 컴포즈를 사용하여 도커 컨테이너 환경을 구성하는 경우 Nginx 프록시 옵션을 활성화되어 있더라도 무시됩니다. Nginx 프록시 옵션을 무시한다는 의미는 애플리케이션 소스 번들에 도커 컴포즈 문서와 함께 <strong>.platform 폴더를 포함시키더라도 Nginx 구성 파일로 복사하여 확장하지 않는다</strong>는 이야기입니다.</p>
<p>하지만 애플리케이션 소스 번들에 포함시킨 <strong>.platform 폴더는 /var/app/current에 추출</strong>되므로 도커 컴포즈 문서에 도커 컨테이너에 볼륨을 지정하여 전달할 수 있습니다.</p>
<figure class="highlight nginx"><figcaption><span>docker-nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>                    nginx;</span><br><span class="line"><span class="attribute">error_log</span>               /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>                     /var/run/nginx.pid;</span><br><span class="line"><span class="attribute">worker_processes</span>        auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span>    <span class="number">32768</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span>  <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>         /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>    application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>      main    <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                            <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                            <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">map</span> $http_upgrade $connection_upgrade &#123;</span><br><span class="line">      <span class="attribute">default</span>     <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">      <span class="attribute">listen</span>                <span class="number">80</span> default_server;</span><br><span class="line">      <span class="attribute">access_log</span>            /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">client_header_timeout</span> <span class="number">60</span>;</span><br><span class="line">      <span class="attribute">client_body_timeout</span>   <span class="number">60</span>;</span><br><span class="line">      <span class="attribute">keepalive_timeout</span>     <span class="number">60</span>;</span><br><span class="line">      <span class="attribute">gzip</span>                  <span class="literal">off</span>;</span><br><span class="line">      <span class="attribute">gzip_comp_level</span>       <span class="number">4</span>;</span><br><span class="line">      <span class="attribute">gzip_types</span>            text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Include the Elastic Beanstalk generated locations</span></span><br><span class="line">      <span class="attribute">include</span> conf.d/elasticbeanstalk/<span class="regexp">*.conf</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">           <span class="attribute">listen</span>                   <span class="number">443</span> ssl default_server;</span><br><span class="line">           <span class="attribute">server_name</span>              mambo.kr;</span><br><span class="line">           <span class="attribute">ssl_certificate</span>          /etc/nginx/cert/server-ca-bundle.pem;</span><br><span class="line">           <span class="attribute">ssl_certificate_key</span>      /etc/nginx/cert/server.key;</span><br><span class="line">           <span class="attribute">ssl_protocols</span>            TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">           <span class="attribute">ssl_ciphers</span>              HIGH:!aNULL:!MD5;</span><br><span class="line">           <span class="attribute">ssl_verify_client</span>        optional_no_ca;</span><br><span class="line"></span><br><span class="line">           <span class="attribute">location</span> / &#123;</span><br><span class="line">               <span class="attribute">proxy_pass</span>          http://app:8000;</span><br><span class="line">               <span class="attribute">proxy_http_version</span>  <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">               <span class="attribute">proxy_set_header</span>    Connection          $connection_upgrade;</span><br><span class="line">               <span class="attribute">proxy_set_header</span>    Upgrade             $http_upgrade;</span><br><span class="line">               <span class="attribute">proxy_set_header</span>    Host                $host;</span><br><span class="line">               <span class="attribute">proxy_set_header</span>    X-Real-IP           $remote_addr;</span><br><span class="line">               <span class="attribute">proxy_set_header</span>    X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">               <span class="attribute">proxy_set_header</span>    X-SSL-CERT          $ssl_client_escaped_cert;</span><br><span class="line">               <span class="attribute">proxy_buffering</span>     <span class="literal">off</span>;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>단일 컨테이너를 구성하고 ELB로 전달되는 트래픽을 애플리케이션 컨테이너에 직접 전달할 수 있지만 도커 컴포즈를 사용하여 컨테이너 구성하더라도 직접 Nginx 컨테이너를 함께 구성할 수 있음을 보여줍니다. 위 Nginx 구성 파일은 일반적인 Elastic Beanstalk의 다양한 언어로 지원하는 플랫폼에서 제공하는 Nginx 확장 구성 파일과 동일하지만 <strong>애플리케이션과 Nginx가 별도의 독립적인 컨테이너로 실행되므로 호스트 이름으로 접근해야함</strong>을 보여줍니다.</p>
<h3 id="도커-컴포즈-문서"><a href="#도커-컴포즈-문서" class="headerlink" title="도커 컴포즈 문서"></a>도커 컴포즈 문서</h3><p>애플리케이션과 Nginx 컨테이너를 구성하는 도커 컴포즈 문서를 정의합니다. </p>
<figure class="highlight yaml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.21.1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.env</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.platform/nginx/conf.d/elasticbeanstalk:/etc/nginx/conf.d/elasticbeanstalk</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.platform/nginx/docker-nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/nginx/cert:/etc/nginx/cert</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$&#123;EB_LOG_BASE_DIR&#125;/nginx:/var/log/nginx&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;443:443&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx_app</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.mambo.kr:5000/mambo-py:test</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.env</span></span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx_app</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">nginx_app:</span></span><br></pre></td></tr></table></figure>

<p>Elastic Beanstalk 환경 구성 파일에 의해 가져온 Nginx 인증서와 애플리케이션 소스 번들에 포함된 플랫폼 확장 파일을 Nginx 컨테이너 볼륨에 연결합니다. 그리고 애플리케이션 로드 밸런서 또는 네트워크 로드 밸런서에서 전달되는 트래픽은 Nginx 컨테이너로 경유하여 애플리케이션 컨테이너로 전달되므로 애플리케이션에 대한 포트는 호스트로 노출하지 않도록 하여 직접 접근이 불가능하도록 합니다.</p>
<h4 id="컨테이너-환경-변수"><a href="#컨테이너-환경-변수" class="headerlink" title="컨테이너 환경 변수"></a>컨테이너 환경 변수</h4><p>Beanstalk 콘솔에서 설정하는 환경 변수는 애플리케이션 소스 번들이 추출되는 /var/app/current 경로에 .env 파일에 환경 변수가 정의됩니다. 그리고 이 파일을 도커 컨테이너의 환경 변수 참조 파일로 추가할 수 있습니다.</p>
<blockquote>
<p>도커 컴포즈 문서에 정의한 환경 변수가 우선 순위를 갖습니다. 도커 컴포즈 문서에 설정된 환경 변수를 Beanstalk 환경 변수로 설정하더라도 무시되니 주의하셔야합니다.</p>
</blockquote>
<h3 id="도커-레지스트리-서버-인증-파일"><a href="#도커-레지스트리-서버-인증-파일" class="headerlink" title="도커 레지스트리 서버 인증 파일"></a>도커 레지스트리 서버 인증 파일</h3><p>도커 레지스트리 서버에서 도커 이미지를 받아오기 위해서는 레지스트리 서버에 대한 인증 파일이 필요합니다. 만약, 기본 도커 레지스트리 서버인 도커 허브를 사용하는 것이 아니라 직접 구축한 도커 레지스트리 서버과 통신해야한다면 <strong>TLS 통신을 위한 인증서 파일이 필요</strong>합니다.</p>
<p>예를 들어, 도커 레지스트리 서버에 대한 인증서는 다음과 같이 참조하게 됩니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/etc/docker/certs.d/         &lt;-- Certificate directory</span><br><span class="line">└── registry.mambo.kr:5000   &lt;-- Hostname:port</span><br><span class="line">    ├── client.cert          &lt;-- Client certificate</span><br><span class="line">    ├── client.key           &lt;-- Client key</span><br><span class="line">    └── ca.crt               &lt;-- Certificate authority that signed the registry certificate</span><br></pre></td></tr></table></figure>

<blockquote>
<p>윈도우와 MacOS 에서는 $USER/.docker/certs.d 입니다.</p>
</blockquote>
<p>도커 레지스트리 서버에 로그인하면 <strong>.dockercfg</strong> 파일에 크레덴셜 정보가 저장됩니다.</p>
<figure class="highlight json"><figcaption><span>.dockercfg</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;https://registry.mambo.kr:5000&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;auth&quot;</span>: <span class="string">&quot;[Base64]username:password&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>윈도우 또는 Mac OS에서는 <strong>윈도우 자격 증명 관리자</strong> 또는 <strong>OSX Keychain</strong>에 크레덴셜을 저장할 수 있는데요. 이 경우에는 <strong>.dockercfg 또는 config.json</strong> 파일을 살펴보더라도 크레덴셜을 확인할 수 없습니다. 도커 로그인 시 사용되는 크레덴셜은 사용자 이름과 패스워드(username:password)를 <a href="https://codebeautify.org/base64-encode">Base64로 인코딩</a>한 값이기 때문에 <strong>직접 Base64로 인코딩</strong>하고 위와 같이 <strong>도커 레지스트리 서버에 대한 .dockercfg를 정의</strong>하시기 바랍니다.</p>
<h3 id="환경-구성-파일"><a href="#환경-구성-파일" class="headerlink" title="환경 구성 파일"></a>환경 구성 파일</h3><p>도커 레지스트리 서버에 대한 인증서 파일들을 S3 버킷에서 가져오는 구성 파일을 정의합니다. 지난 <a href="../elastic-beanstalk-s3-auth">Elastic Beanstalk S3 Authentication</a>를 참고하여 다음과 같이 작성하였습니다.</p>
<figure class="highlight yaml"><figcaption><span>.ebextensions/registry-cert.config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">Resources:</span></span><br><span class="line">    <span class="attr">AWSEBAutoScalingGroup:</span></span><br><span class="line">        <span class="attr">Metadata:</span></span><br><span class="line">            <span class="attr">AWS::CloudFormation::Authentication:</span></span><br><span class="line">                <span class="attr">S3Auth:</span></span><br><span class="line">                    <span class="attr">type:</span> <span class="string">S3</span></span><br><span class="line">                    <span class="attr">buckets:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">mambo-cert</span></span><br><span class="line">                    <span class="attr">roleName:</span></span><br><span class="line">                        <span class="attr">Fn::GetOptionSetting:</span></span><br><span class="line">                            <span class="attr">Namespace:</span> <span class="string">aws:autoscaling:launchconfiguration</span></span><br><span class="line">                            <span class="attr">OptionName:</span> <span class="string">IamInstanceProfile</span></span><br><span class="line">                            <span class="attr">DefaultValue:</span> <span class="string">aws-elasticbeanstalk-ec2-role</span></span><br><span class="line"><span class="attr">files:</span></span><br><span class="line">    <span class="string">&quot;/etc/docker/certs.d/registry.mambo.kr:5000/client.cert&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">https://mambo-cert.s3.ap-northeast-2.amazonaws.com/registry/client.cert</span></span><br><span class="line">        <span class="attr">authentication:</span> <span class="string">S3Auth</span></span><br><span class="line">    <span class="string">&quot;/etc/docker/certs.d/registry.mambo.kr:5000/client.key&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">https://mambo-cert.s3.ap-northeast-2.amazonaws.com/registry/client.key</span></span><br><span class="line">        <span class="attr">authentication:</span> <span class="string">S3Auth</span></span><br><span class="line">    <span class="string">&quot;/etc/docker/certs.d/registry.mambo.kr:5000/ca.crt&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">https://mambo-cert.s3.ap-northeast-2.amazonaws.com/registry/ca.crt</span></span><br><span class="line">        <span class="attr">authentication:</span> <span class="string">S3Auth</span></span><br><span class="line"></span><br><span class="line"><span class="attr">commands:</span></span><br><span class="line">    <span class="attr">99-remove-bak:</span></span><br><span class="line">        <span class="attr">cwd:</span> <span class="string">/etc/docker/certs.d/registry.mambo.kr:5000</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">*.bak</span></span><br></pre></td></tr></table></figure>

<h3 id="도커-구성-파일"><a href="#도커-구성-파일" class="headerlink" title="도커 구성 파일"></a>도커 구성 파일</h3><p>로컬 환경에서는 도커의 로그인 명령어를 사용하여 도커 레지스트리 서버에 인증하고 이미지를 등록하거나 가져올 수 있습니다. 그러나 Elastic Beanstalk 환경에서는 직접 로그인 명령어를 사용하는 것이 아니므로 도커에서 도커 레지스트리 서버에 대한 인증 파일을 사용할 수 있도록 앞서 알아본 <strong>.dockercfg</strong> 파일을 가져와야 합니다.</p>
<figure class="highlight json"><figcaption><span>Dockerrun.aws.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;AWSEBDockerrunVersion&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Authentication&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bucket&quot;</span>: <span class="string">&quot;mambo-cert&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;registry/.dockercfg&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>도커 컴포즈 문서와 함께 애플리케이션 소스 번들에 포함되는 위 도커 구성 파일은 Dockerrun.aws.json v3을 사용하며 <strong>mambo-cert/registry/.dockercfg</strong> 파일을 <strong>/root/.docker/config.json</strong>에 크레덴셜 정보를 복사합니다.</p>
<blockquote>
<p>EC2 인스턴스의 IAM Role이 S3 버킷에 대한 읽기 권한을 가져야합니다.</p>
</blockquote>
<h3 id="애플리케이션-소스-번들"><a href="#애플리케이션-소스-번들" class="headerlink" title="애플리케이션 소스 번들"></a>애플리케이션 소스 번들</h3><p>Elastic Beanstalk의 도커 플랫폼 환경에 배포할 애플리케이션 소스 번들에는 다음과 같은 파일들이 포함됩니다. </p>
<ul>
<li>docker-compose.yml</li>
<li>Dockerrun.aws.json</li>
<li>.platform</li>
<li>.ebextensions</li>
</ul>
<p>위 파일들을 <strong>zip 명령어로 애플리케이션 소스 번들 파일을 생성</strong>합니다.</p>
<figure class="highlight sh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">zip app-bundle.zip -r docker-compose.yml Dockerrun.aws.json .platform .ebextensions</span><br></pre></td></tr></table></figure>

<p>이제 애플리케이션 소스 번들 파일을 업로드하면 다음과 같이 Hello World가 표시되는 것을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/beanstalk-docker-platform/web.png"></p>
<p>이렇게해서 애플리케이션을 도커 이미지로 만들고 사설로 구축한 도커 레지스트리 서버에 등록된 이미지를 통해 Elastic Beanstalk의 도커 플랫폼을 활용하여 애플리케이션을 배포해보았습니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Beanstalk</tag>
        <tag>Docker</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Elastic Beanstalk S3 Authentication</title>
    <url>/elastic-beanstalk-s3-auth/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 Elastic Beanstalk 구성 시 S3 프라이빗 저장소에서 파일을 받아오는 것을 알아보고자 합니다. 지난 <a href="../tls-offload">TLS 오프로드</a>에서 Nginx 에서 사용할 SSL 인증서를 Beanstalk 환경 구성 파일의 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/customize-containers-ec2.html#linux-files">파일 키</a>를 사용하여 생성했었습니다. 하지만, 보안을 중요시하는 회사라면 애플리케이션 소스 번들에 인증서와 개인키를 포함시키는 것을 허용하지 않을 수 있습니다. 그렇기 때문에 애플리케이션 소스 번들에 인증서를 포함하지 않고 애플리케이션 배포 단계에서 가져올 수 있는 방안을 마련해야합니다.</p>
<h2 id="Beanstalk-S3-Auth"><a href="#Beanstalk-S3-Auth" class="headerlink" title="Beanstalk S3 Auth"></a>Beanstalk S3 Auth</h2><p>Beanstalk 확장 구성 파일에서 CloudFormation의 <a href="https://docs.aws.amazon.com/ko_kr/AWSCloudFormation/latest/UserGuide/aws-resource-authentication.html">AWS::CloudFormation::Authentication</a> 리소스를 사용하여 S3 버킷에 대한 자격 증명을 지정할 수 있고 인증을 수행하여 S3 저장소에 등록되어있는 인증서를 가져올 수 있습니다. <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/https-storingprivatekeys.html">프라이빗 키를 Amazon S3에 안전하게 저장</a>에서 알려주는 대로 Beanstalk 구성 시 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/ebextensions-functions.html#ebextensions-functions-getoptionsetting">Fn::GetOptionSetting</a> 함수를 활용하면 됩니다.</p>
<h3 id="S3-Bucket-Policy"><a href="#S3-Bucket-Policy" class="headerlink" title="S3 Bucket Policy"></a>S3 Bucket Policy</h3><p>먼저, <strong>AWS::CloudFormation::Authentication</strong> 리소스로 S3 버킷에 대한 자격 증명을 가질 수 있도록 S3 버킷에 보안 정책을 설정해야 합니다. 일반적으로 Beanstalk으로 애플리케이션을 배포하는 경우 <strong>aws-elasticbeanstalk-ec2-role</strong>을 인스턴스 프로파일로 가지게 됩니다. 인증서 파일이 저장된 S3 버킷은 퍼블릭 액세스가 차단되어있으므로 EC2 인스턴스가 <a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/add-bucket-policy.html">버킷에 대한 권한을 가지도록 정책을 추가</a>합니다.</p>
<p><img data-src="/images/posts/elastic-beanstalk-s3-auth-01.png"></p>
<h3 id="Extend-Nginx"><a href="#Extend-Nginx" class="headerlink" title="Extend Nginx"></a>Extend Nginx</h3><p>이제 이전에 작성하였던 SSL 인증서를 만들어내는 구성 파일을 S3에서 받아오도록 작성해야합니다. files 키의 <strong>content</strong> 항목을 제거하고 다음의 항목을 추가합니다.</p>
<ul>
<li>source : S3 인증서 오브젝트 URL</li>
<li>authentication : 인증 속성 이름</li>
</ul>
<figure class="highlight yaml"><figcaption><span>.ebextensions/nginx-cert.config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">Resources:</span></span><br><span class="line">    <span class="attr">AWSEBAutoScalingGroup:</span></span><br><span class="line">        <span class="attr">Metadata:</span></span><br><span class="line">            <span class="attr">AWS::CloudFormation::Authentication:</span></span><br><span class="line">                <span class="attr">S3Auth:</span></span><br><span class="line">                    <span class="attr">type:</span> <span class="string">S3</span></span><br><span class="line">                    <span class="attr">buckets:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">mambo-cert</span></span><br><span class="line">                    <span class="attr">roleName:</span></span><br><span class="line">                        <span class="attr">Fn::GetOptionSetting:</span></span><br><span class="line">                            <span class="attr">Namespace:</span> <span class="string">aws:autoscaling:launchconfiguration</span></span><br><span class="line">                            <span class="attr">OptionName:</span> <span class="string">IamInstanceProfile</span></span><br><span class="line">                            <span class="attr">DefaultValue:</span> <span class="string">aws-elasticbeanstalk-ec2-role</span></span><br><span class="line"><span class="attr">files:</span></span><br><span class="line">    <span class="string">&quot;/etc/nginx/cert/server.crt&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">https://mambo-cert.s3.ap-northeast-2.amazonaws.com/server.crt</span></span><br><span class="line">        <span class="attr">authentication:</span> <span class="string">S3Auth</span></span><br><span class="line">    <span class="string">&quot;/etc/nginx/cert/server.key&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">https://mambo-cert.s3.ap-northeast-2.amazonaws.com/server.key</span></span><br><span class="line">        <span class="attr">authentication:</span> <span class="string">S3Auth</span></span><br><span class="line">    <span class="string">&quot;/etc/nginx/cert/server.ca-bundle&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">https://mambo-cert.s3.ap-northeast-2.amazonaws.com/server-ca-bundle</span></span><br><span class="line">        <span class="attr">authentication:</span> <span class="string">S3Auth</span></span><br><span class="line"></span><br><span class="line"><span class="attr">commands:</span></span><br><span class="line">    <span class="attr">00-chain-ca-bundle:</span></span><br><span class="line">        <span class="attr">cwd:</span> <span class="string">/etc/nginx/cert</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            cat server.crt server.ca-bundle &gt; server-ca.pem</span></span><br><span class="line"><span class="string">            chown nginx:nginx server-ca.pem</span></span><br><span class="line"><span class="string">            chmod 400 server-ca.pem</span></span><br><span class="line"><span class="string"></span>    <span class="attr">99-remove-bak:</span></span><br><span class="line">        <span class="attr">cwd:</span> <span class="string">/etc/nginx/cert</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">*.bak</span></span><br></pre></td></tr></table></figure>

<h3 id="Beanstalk-Resources"><a href="#Beanstalk-Resources" class="headerlink" title="Beanstalk Resources"></a>Beanstalk Resources</h3><p>아마존 웹 서비스의 리소스들은 CloudFormation으로 만들어지며 Elastic Beanstalk 환경도 <strong>CloudFormation 스택을 구성</strong>하여 만들어지게 됩니다.</p>
<figure class="highlight yaml"><figcaption><span>.ebextensions/nginx-cert.config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">Resources:</span></span><br><span class="line">    <span class="attr">AWSEBAutoScalingGroup:</span></span><br><span class="line">        <span class="attr">Metadata:</span></span><br><span class="line">            <span class="attr">AWS::CloudFormation::Authentication:</span></span><br><span class="line">                <span class="attr">S3Auth:</span></span><br><span class="line">                    <span class="attr">type:</span> <span class="string">S3</span></span><br><span class="line">                    <span class="attr">buckets:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">mambo-cert</span></span><br><span class="line">                    <span class="attr">roleName:</span></span><br><span class="line">                        <span class="attr">Fn::GetOptionSetting:</span></span><br><span class="line">                            <span class="attr">Namespace:</span> <span class="string">aws:autoscaling:launchconfiguration</span></span><br><span class="line">                            <span class="attr">OptionName:</span> <span class="string">IamInstanceProfile</span></span><br><span class="line">                            <span class="attr">DefaultValue:</span> <span class="string">aws-elasticbeanstalk-ec2-role</span></span><br></pre></td></tr></table></figure>

<p>그래서 구성 파일의 리소스 키를 정의하는 것은 CloudFormation 템플릿에 리소스를 추가하는 것과 같습니다. 위 예시에서는 Beanstalk 환경 시작 시 만들어지는 CloudFormation 스택에 미리 정의된 웹 서버 환경의 리소스 항목인 <a href="https://docs.aws.amazon.com/ko_kr/AWSCloudFormation/latest/UserGuide/aws-properties-as-group.html">AWSEBAutoScalingGroup</a>을 사용했습니다. </p>
<p>그리고 AWSEBAutoScalingGroup에는 <a href="https://docs.aws.amazon.com/ko_kr/AWSCloudFormation/latest/UserGuide/aws-properties-as-launchconfig.html">LaunchConfiguration(AWS::AutoScaling::LaunchConfiguration)</a>라는 EC2 인스턴스에 대한 시작 구성을 정의하는 항목이 있으며 시작 구성에 정의된 내용 중에는 <a href="https://docs.aws.amazon.com/ko_kr/AWSCloudFormation/latest/UserGuide/aws-properties-as-launchconfig.html#cfn-as-launchconfig-iaminstanceprofile">IamInstanceProfile</a> 속성이 있습니다. IamInstanceProfile 속성은 EC2 인스턴스에 대한 인스턴스 프로파일로 지정된 <strong>IAM Role</strong>에 대한 이름을 제공합니다.</p>
<p>따라서, Beanstalk 환경 구성 시 선택한 IAM Role을 가져와서 <strong>AWS::CloudFormation::Authentication</strong> 리소스를 활용해 S3 버킷에 대한 자격 증명을 지정한 것입니다. 우리는 앞서 aws-elasticbeanstalk-ec2-role이라는 IAM Role이 인증서가 저장된 S3 버킷에 읽기 권한을 부여했기 때문에 파일 키에 정의된 파일을 생성할 때 외부 소스(S3 저장소)에서 가져올 수 있게된 것입니다. 이렇게 해서 우리는 애플리케이션 소스 번들에 인증서를 포함시키지 않고 EC2 인스턴스에서만 접근할 수 있는 S3 버킷에 인증서를 저장하고 사용할 수 있는 구성을 할 수 있게 되었습니다.</p>
<p>이 글을 보시는 분들이 인증서의 개인키와 같은 민감한 파일들을 애플리케이션 소스 번들에 포함하고 있다면 프라이빗 S3 저장소에 저장하여 더 안전한 방식으로 애플리케이션을 배포하는 것을 고려해보시기 바랍니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>S3</tag>
        <tag>Beanstalk</tag>
      </tags>
  </entry>
  <entry>
    <title>그래들 빌드 라이프사이클</title>
    <url>/gradle-build-lifecycle/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘 알아볼 내용은 그래들 빌드의 라이프사이클입니다. </p>
<p>얼마전에 단일 애플리케이션 프로젝트에서 다양한 배포 환경에 대한 기능을 별도로 지원해야하는 요구사항으로 인하여 그래들 멀티 모듈 프로젝트로 전환하게 되면서 배포 과정에서 문제가 발생하였었는데요. 그 문제는 크리티컬한 이슈는 아니지만 태스크 수행 후 만들어진 압축 파일에 프로젝트 버전이 포함되지 않는 상황이었습니다. 이러한 문제가 발생한 이유는 그래들 태스크를 정의할 때 <strong>그래들 빌드 라이프사이클</strong>을 고려하지 않았기 때문입니다.</p>
<h2 id="그래들-태스크"><a href="#그래들-태스크" class="headerlink" title="그래들 태스크"></a>그래들 태스크</h2><p>먼저 기존에 정의된 태스크는 <a href="https://github.com/kdevkr/beanstalk-deploy-sample/blob/main/build.gradle">beanstalk-deploy-sample의 build.gradle에 정의된 zipBeanstalk 태스크</a>와 같이 Zip 유형의 태스크로 작성되어있습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task zipBeanstalk(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> <span class="string">&#x27;procfile&#x27;</span>) &#123;</span><br><span class="line">    from (<span class="string">&#x27;.ebextensions&#x27;</span>) &#123; into <span class="string">&#x27;.ebextensions&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;.platform&#x27;</span>) &#123; into <span class="string">&#x27;.platform&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        println bootWar.archiveName</span><br><span class="line">        include(bootWar.archiveName)</span><br><span class="line">        include(<span class="string">&quot;Procfile&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    baseName = <span class="string">&#x27;beanstalk&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 샘플 태스크처럼 단일 애플리케이션 프로젝트에서 정의된 태스크는 문제가 발생할 가능성이 적습니다. 그 이유는 배포를 위해서 여러가지 태스크를 정의하지 않기 때문인데요. 그러면 위 태스크를 수행하면 어떤 결과를 제공하는지 한번 확인해볼까요?</p>
<h3 id="태스크-결과"><a href="#태스크-결과" class="headerlink" title="태스크 결과"></a>태스크 결과</h3><p>프로젝트 폴더에 있는 Gradle Wrapper를 사용하여 zipBeanstalk 태스크를 수행하면서 프로젝트 버전을 명시해보겠습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./gradlew clean zipBeanstalk -x <span class="built_in">test</span> -Pversion=1.0.0-hotfix.11</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/gradle-build-lifecycle/gradle-01.png"></p>
<p>패키징된 WAR 파일과 zipBeanstalk 태스크에 의해 만들어지는 아카이브 파일에 프로젝트 버전이 포함됨을 확인할 수 있습니다.</p>
<h3 id="수동-배포-환경을-위한-태스크"><a href="#수동-배포-환경을-위한-태스크" class="headerlink" title="수동 배포 환경을 위한 태스크"></a>수동 배포 환경을 위한 태스크</h3><p>사실 zipBeanstalk 태스크는 아마존 웹 서비스의 빈스톡 환경으로 배포하기 위한 애플리케이션 번들 파일을 만드는 태스크입니다. 만약, 수동으로 배포하여야하는 환경이 추가된다면 빈스톡 환경에서 사용하는 Procfile과 환경 구성 파일들은 포함할 필요가 없으며 특정 환경을 위한 프로퍼티 파일만 별도로 추가하면 됩니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task zipManually(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> <span class="string">&#x27;bootWar&#x27;</span>) &#123;</span><br><span class="line">    println <span class="string">&#x27;Build Version: &#x27;</span> + project.version</span><br><span class="line"></span><br><span class="line">    from (<span class="string">&#x27;.conf&#x27;</span>) &#123; into <span class="string">&#x27;application-prod.yml&#x27;</span>&#125;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        include(bootWar.archiveName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    baseName = <span class="string">&#x27;app-bundle&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zipManually 태스크에는 application-prod.yml을 패키징된 애플리케이션 WAR 파일과 함께 포함시키도록 정의했습니다. 아시는 분들도 있겠지만 스프링 부트 애플리케이션은 <strong>WAR 파일과 동일한 위치에 있는 애플리케이션 프로퍼티 파일</strong>을 읽을 수 있습니다. 만약, 모르시는 분들이라면 프로퍼티 구성 우선 순위에 대한 문서를 확인하시기 바랍니다.</p>
<p>동일하게 zipManually 태스크를 실행해보도록 하겠습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./gradlew clean zipManually -x <span class="built_in">test</span> -Pversion=1.0.0-hotfix.11</span><br><span class="line"></span><br><span class="line">&gt; Configure project :</span><br><span class="line">JDK info: 11</span><br><span class="line">Build Version: 1.0.0-hotfix.11</span><br><span class="line">Build Version: 1.0.0-hotfix.11</span><br><span class="line"></span><br><span class="line">&gt; Task :bootBuildInfo</span><br><span class="line">&gt; Task :compileJava UP-TO-DATE</span><br><span class="line">&gt; Task :processResources UP-TO-DATE</span><br><span class="line">&gt; Task :classes</span><br><span class="line">&gt; Task :bootWarMainClassName</span><br><span class="line">&gt; Task :bootWar</span><br><span class="line">&gt; Task :procfile</span><br><span class="line">&gt; Task :zipManually</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/gradle-build-lifecycle/gradle-02.png"></p>
<p>zipManually 태스크 결과는 정상으로 보입니다만… 이상한 부분을 눈치채신분들이 있으시겠죠? <strong>바로 Build Version이 두번 출력되었다는 점</strong>인데요. 우리는 분명히 별도의 태스크로 정의하고 태스크 블록 내에서 현재 Build Version을 출력하도록 작성했습니다. 이렇게 Build Version 버전이 두번 출력되는 이유는 이 글의 주요 내용인 그래들 빌드 라이프사이클에 대한 개념과 관련이 있습니다.</p>
<h2 id="그래들-빌드-라이프사이클"><a href="#그래들-빌드-라이프사이클" class="headerlink" title="그래들 빌드 라이프사이클"></a>그래들 빌드 라이프사이클</h2><p>사실 상 이러한 문제를 경험하는 이유는 그래들의 빌드 라이프사이클에 대한 개념을 모르기 때문인데요. 20년차이신 팀장님 조차도 잘 모르는 부분이었다고 할 수 있습니다. 빌드 라이프사이클 존재를 모르는 상황이었기에 이렇게 되는 이유를 검색하고 팀장님께서 <a href="https://stackoverflow.com/a/23485085">Gradle executes all tasks?</a>이라는 스택오버플로우 질문을 공유해주셨습니다.</p>
<p>이 질문에 대한 답변에서는 그래들에는 configuration 단계와 execution 단계가 있고 이것은 중요한 개념이라고 설명하고 있었습니다. 그러면 그래들 공식 문서에 있는 <a href="https://docs.gradle.org/current/userguide/build_lifecycle.html">Build Lifecycle</a>를 살펴보도록 하겠습니다.</p>
<blockquote>
<p>Gradle builds the complete dependency graph before any task is executed.<br>… Your build scripts configure this dependency graph.</p>
</blockquote>
<p>그래들은 태스크를 수행하기 전에 의존성 그래프를 빌드하고 빌드 스크립트는 의존성 그래프를 구성한다고 설명하며 빌드 단계에 대해서 설명합니다.</p>
<h3 id="빌드-단계"><a href="#빌드-단계" class="headerlink" title="빌드 단계"></a>빌드 단계</h3><p>그래들의 빌드 단계는 3가지로 구분된다고 하며 초기화(Initialization), 구성(Configuration), 수행(Execution)입니다. </p>
<blockquote>
<p><strong>Initialization</strong><br>Gradle supports single and multi-project builds. During the initialization phase, Gradle determines which projects are going to take part in the build, and creates a Project instance for each of these projects.</p>
<p><strong>Configuration</strong><br>During this phase the project objects are configured. The build scripts of all projects which are part of the build are executed.</p>
<p><strong>Execution</strong><br>Gradle determines the subset of the tasks, created and configured during the configuration phase, to be executed. The subset is determined by the task name arguments passed to the gradle command and the current directory. Gradle then executes each of the selected tasks.</p>
</blockquote>
<p>세가지의 단계 중 구성 단계에서는 모든 프로젝트의 빌드 스크립트가 실행된다는 설명이 있습니다. 이 부분이 제가 경험한 문제의 원인이라고 할 수 있는데 태스크 내에서 작성하는 코드는 구성 단계에 포함되며 doFirst와 doLast 블록이 수행 단계에 포함되기 때문입니다.</p>
<p>저도 모르는 부분이었고 생각보다 많은 블로그에서는 그래들 태스크 정의를 설명할 때 구성 단계에 해당되는 곳에 println을 작성하는 예시를 보여주는데요. 생각보다 많은 분들이 이 개념에 대해서 모른다고 할 수 있습니다. 물론 단일 애플리케이션 프로젝트에서는 몰라도 상관없다고 할 수 있겠네요.</p>
<h3 id="테스트를-위한-태스크"><a href="#테스트를-위한-태스크" class="headerlink" title="테스트를 위한 태스크"></a>테스트를 위한 태스크</h3><p>그러면 어떻게 하였기에 프로젝트 버전이 포함되지 않았을 지 다음의 태스크를 살펴보도록 하겠습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task zipBeanstalk(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> <span class="string">&#x27;procfile&#x27;</span>) &#123;&#125;</span><br><span class="line">task zipManually(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> <span class="string">&#x27;bootWar&#x27;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">task k8sbuild(<span class="attr">dependsOn:</span> bootWar) &#123;</span><br><span class="line">    project.version <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>추가한 k8sbuild 태스크는 쿠버네티스 배포 환경 테스트를 위해 패키징된 애플리케이션 WAR 파일에 포함되는 프로젝트 버전을 생략하기 위해서 project.version을 빈 값으로 설정하도록 작성한게 화근이었습니다. 이 상태로 zipManually 태스크를 다시 한번 수행하면 어떻게 되는지 확인해봅시다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./gradlew clean zipManually -x <span class="built_in">test</span> -Pversion=1.0.0-hotfix.11</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/gradle-build-lifecycle/gradle-03.png"></p>
<p>k8sbuild 태스크에 작성된 project.version을 설정하는 행위는 구성 단계에 해당하기 때문에 모든 태스크를 수행하기 이전에 적용되어 zipManually 태스크를 수행했음에도 불구하고 프로젝트 버전이 포함되지 않았음을 보여줍니다.</p>
<h3 id="해결방안"><a href="#해결방안" class="headerlink" title="해결방안"></a>해결방안</h3><p>그러면 어떻게 해결하는게 좋을지 방안을 찾아보도록 하겠습니다. </p>
<h4 id="프로젝트-버전-재정의하는-경우"><a href="#프로젝트-버전-재정의하는-경우" class="headerlink" title="프로젝트 버전 재정의하는 경우"></a>프로젝트 버전 재정의하는 경우</h4><p>k8sbuild 태스크처럼 특정 태스크에서 프로젝트 버전을 재정의 하고싶은 경우에는 doFirst와 같은 클로저를 활용해야합니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task k8sbuild(<span class="attr">dependsOn:</span> bootWar) &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        project.version <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="프로젝트-버전을-확인하고-싶은-경우"><a href="#프로젝트-버전을-확인하고-싶은-경우" class="headerlink" title="프로젝트 버전을 확인하고 싶은 경우"></a>프로젝트 버전을 확인하고 싶은 경우</h4><p>zipBeanstalk와 zipManually 태스크처럼 애플리케이션을 WAR로 패키징하는 경우 현재 프로젝트 버전을 출력하고 싶은 경우 gradle.taskGraph.whenReady를 활용함으로써 해결할 수 있습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task zipBeanstalk(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> <span class="string">&#x27;procfile&#x27;</span>) &#123;</span><br><span class="line">    from (<span class="string">&#x27;.ebextensions&#x27;</span>) &#123; into <span class="string">&#x27;.ebextensions&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;.platform&#x27;</span>) &#123; into <span class="string">&#x27;.platform&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        include(bootWar.archiveName)</span><br><span class="line">        include(<span class="string">&quot;Procfile&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    baseName = <span class="string">&#x27;beanstalk&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task zipManually(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> <span class="string">&#x27;bootWar&#x27;</span>) &#123;</span><br><span class="line">    from (<span class="string">&#x27;.conf&#x27;</span>) &#123; into <span class="string">&#x27;application-prod.yml&#x27;</span>&#125;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        include(bootWar.archiveName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    baseName = <span class="string">&#x27;app-bundle&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.taskGraph.whenReady &#123; graph -&gt;</span><br><span class="line">    <span class="keyword">if</span> (graph.hasTask(bootWar)) &#123;</span><br><span class="line">        println <span class="string">&#x27;Build Version: &#x27;</span> + project.version</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="불필요한-파일을-제거해야하는-경우"><a href="#불필요한-파일을-제거해야하는-경우" class="headerlink" title="불필요한 파일을 제거해야하는 경우"></a>불필요한 파일을 제거해야하는 경우</h4><p>경우에 따라서는 프로젝트 빌드 시 패키징된 애플리케이션 WAR 파일에 포함되지 않도록 해야할 수 있습니다. 예를 들어, 로컬 환경에서 사용하는 애플리케이션 프로퍼티 파일이나 특정 도메인에 대한 인증서 또는 인증키를 포함하지않도록 제외해야할 수 있습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.taskGraph.whenReady &#123; graph -&gt;</span><br><span class="line">    <span class="keyword">if</span> (graph.hasTask(build_for_customer)) &#123;</span><br><span class="line">        processResources &#123;</span><br><span class="line">            exclude(<span class="string">&#x27;**/config/**.yml&#x27;</span>)</span><br><span class="line">            exclude(<span class="string">&#x27;**/certs/**&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예시는 구성 단계에서 의존성 그래프 구성이 완료된 이후에 build_for_customer 태스크가 수행되는 경우에 고객 환경으로 배포하는 애플리케이션 WAR 파일에 자체적으로 사용하는 애플리케이션 프로퍼티 파일들과 인증서를 포함하지 않도록 processResources를 재정의함을 보여줍니다.</p>
<p>그래들 빌드 라이프사이클 개념과 함께 경험하였던 문제에 대하여 어떻게 해결할 수 있는지 알아보았습니다. 어떤 기술을 사용함에 있어서 주요 개념을 이해하고 있는 것이 중요함을 다시한번 깨닫게 되는 좋은 경험이었습니다. 여러분의 그래들 빌드 스크립트에서도 수행 단계에서 수행되어야할 코드를 구성 단계에서 동작하도록 작성되지 않았는지 검토해보시기를 바랍니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Gradle</tag>
        <tag>Lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>그래들 멀티 모듈 프로젝트</title>
    <url>/gradle-multi-module-project/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 그래들 멀티 모듈 프로젝트의 디펜던시 공유에 대하여 이야기 해보려고 합니다. </p>
<h2 id="그래들-멀티-모듈"><a href="#그래들-멀티-모듈" class="headerlink" title="그래들 멀티 모듈"></a>그래들 멀티 모듈</h2><p>서비스의 규모가 어느정도 커지게되면 모놀리식 아키텍처로써 서비스에 대한 모든 기능이 하나의 애플리케이션에 구현하는 것을 마이크로서비스 아키텍처를 참고하여 일부 기능을 수행하는 별도의 애플리케이션로 독립시키기도 합니다. 현재 다니고 있는 회사에서는 모놀리식 아키텍처로 개발하고 있는 애플리케이션을 여러 고객들의 환경에 맞는 배포 또는 별도의 커스텀 기능을 지원하기 위하여 <strong>그래들 멀티 모듈 프로젝트</strong>로 전환하였습니다.</p>
<h3 id="Java-라이브러리-플러그인"><a href="#Java-라이브러리-플러그인" class="headerlink" title="Java 라이브러리 플러그인"></a>Java 라이브러리 플러그인</h3><p>공용 모듈에서 사용하는 디펜던시를 상위 모듈에서도 사용하기 위해서는 자바 플러그인 대신 자바 라이브러리 플러그인을 적용하고 <code>api</code>를 사용하여 지정된 디펜던시를 외부 모듈의 컴파일 클래스패스에 노출시켜야합니다. Gradle 7 부터는 <code>compile</code>을 지원하지 않으며 <code>implementation</code>은 지정한 디펜던시를 외부 모듈에 노출시키지 않습니다.</p>
<blockquote>
<p>The compile and runtime configurations have been removed with Gradle 7.0. Please refer to the upgrade guide how to migrate to implementation and api configurations`.</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module-common/build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java-library&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api <span class="string">&#x27;com.google.code.gson:gson&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>common 모듈의 gson 라이브러리는 api를 통해 상위 모듈의 클래스패스에 노출되어 상위 모듈에서도 사용이 가능해집니다. 기본적으로 implementation을 사용하는 경우 외부 모듈 클래스패스에 노출시키지 않는 이유는 빠른 컴파일과 클래스패스 사이즈를 줄이기 위함이며 api 보다는 implementation을 선호해야한다고 합니다.</p>
<h3 id="Common-Module"><a href="#Common-Module" class="headerlink" title="Common Module"></a>Common Module</h3><p><a href="https://github.com/kdevkr/gradle-multi-module">gradle-multi-module</a> 처럼 그래들 멀티 모듈 프로젝트에 공용으로 적용되는 코드를 가지는 Common 모듈이 있을때 다음과 같이 공통으로 적용되어야하는 설정을 수행할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title">objectMapperBuilderCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; builder</span><br><span class="line">                .featuresToEnable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)</span><br><span class="line">                .featuresToDisable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)</span><br><span class="line">                .modules(List.of(<span class="keyword">new</span> Jdk8Module(), <span class="keyword">new</span> JavaTimeModule()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드에서는 Date 또는 Timestamp와 같은 클래스에 대하여 Long 값으로 변환하는 기능을 활성화하기 위하여 SerializationFeature.WRITE_DATES_AS_TIMESTAMPS를 적용하였습니다. </p>
<h4 id="Common-Dependencies"><a href="#Common-Dependencies" class="headerlink" title="Common Dependencies"></a>Common Dependencies</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java-library&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api <span class="string">&#x27;org.springframework.boot:spring-boot-starter-security&#x27;</span></span><br><span class="line">    api <span class="string">&#x27;com.google.code.gson:gson&#x27;</span></span><br><span class="line">    api <span class="string">&#x27;com.fasterxml.jackson.core:jackson-databind&#x27;</span></span><br><span class="line">    api <span class="string">&#x27;org.hibernate.validator:hibernate-validator&#x27;</span></span><br><span class="line">    api <span class="string">&#x27;org.apache.commons:commons-lang3&#x27;</span></span><br><span class="line">    api <span class="string">&#x27;org.apache.commons:commons-collections4:4.4&#x27;</span></span><br><span class="line">    api <span class="string">&#x27;com.google.guava:guava:31.0.1-jre&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 설정처럼 implementation 대신에 api를 사용하면 동일한 버전의 디펜던시를 다른 외부 모듈에서도 사용할 수 있도록 클래스패스에 노출할 수 있습니다. 이를 통해 각 모듈에서 사용되는 디펜던시 버전이 달라서 발생할 수 있는 문제를 방지할 수 있게 됩니다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://docs.gradle.org/current/userguide/dependency_management_for_java_projects.html">Managing Dependencies of JVM Projects</a>  </li>
<li><a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph">The Java Library Plugin</a>  </li>
</ul>
]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 5 빌드 속도 개선하기</title>
    <url>/improve-webpack5-build-speed/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>현재 조직에서는 웹팩 4로 구성된 프로젝트를 웹팩 5를 사용할 수 있도록 업그레이드 작업을 수행하였고 많은 노력 끝에 최신 버전의 웹팩 구성으로 변경하는 것을 완료했습니다. 그러나 오히려 웹팩 5으로 전환하게 된 후 빌드 시간이 더 늘어남을 경험하게 되었는데 오늘은 왜 이런 문제가 발생했는지를 공유하고자 합니다.</p>
<h2 id="Webpack5"><a href="#Webpack5" class="headerlink" title="Webpack5"></a>Webpack5</h2><p>어떤 도구에 대한 최신 버전을 사용하려는 목적은 버그 개선 뿐만 아니라 구조적인 개선으로 인한 성능 향상에 있기도 합니다. 물론 반드시 최신 버전으로 업데이트하는 것이 성능 상으로 좋아짐을 보장할 순 없습니다. 웹팩에서 마이그레이션 가이드 문서를 제공한다고해도 많은 로더와 플러그인등을 사용하기 때문에 빌드 성능이 좋지 않다는 것을 검토하기에는 어려움이 많습니다.</p>
<h3 id="느려진-재빌드-시간"><a href="#느려진-재빌드-시간" class="headerlink" title="느려진 재빌드 시간"></a>느려진 재빌드 시간</h3><p>웹팩 5로 전환하고나서 일부 시스템 환경에 따라 시간은 다르지만 다음과 같이 빌드 시간이 상당히 느려짐을 경험했습니다. 초기 빌드 시간은 그다지 차이가 발생하지 않았으나 웹팩 5가 조금은 빨랐습니다. 그러나, 젠킨스와 같은 CI 도구에서는 재빌드를 수행하기도 하므로 다음과 같이 재빌드에 대해서 검토한 결과 오히려 빌드가 느림을 확인했습니다. </p>
<p><img data-src="/images/posts/improve-webpack5-build-speed/wp5-build-02.png#full"></p>
<p>재빌드 시에만 웹팩 5에서 심각하게 느림을 보이는 이유는 <strong>캐시</strong>에 있었습니다. 웹팩 5에서는 영구 캐시(파일시스템 캐시)를 지원하기 위해서 캐시 방식을 변경하였습니다. 이전 웹팩 4에서는 캐시 방식이 없으므로 다음과 같이 로더와 플러그인에서 자체적인 캐시 파일을 만드는 것을 제한하지 않았습니다.</p>
<p><img data-src="/images/posts/improve-webpack5-build-speed/wp5-build-03.png"></p>
<p>그러나 우측의 웹팩 5에서는 <code>terser-webpack-plugin</code> 과 <code>css-minimizer-webpack-plugin</code>에 대한 캐시 폴더가 생성되지 않았음을 확인할 수 있는데요. 이렇게 된 정확한 이유는 찾을 수 없었지만 예상하는 바는 캐시 구조 변경으로 인하여 웹팩 자체적으로 제공하는 로더와 플러그인에 대해서는 캐시 파일을 만들지않도록 수정된 것 같습니다.</p>
<h4 id="영구-캐시"><a href="#영구-캐시" class="headerlink" title="영구 캐시"></a>영구 캐시</h4><p>영구 캐시(Persistent Cache)를 위해 파일시스템 캐시를 지정하면 어떻게 되는지 확인해보겠습니다. </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">cache</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;filesystem&#x27;</span>,</span><br><span class="line">        <span class="attr">buildDependencies</span>: &#123;</span><br><span class="line">            <span class="attr">config</span>: [__filename]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node_modules 하위의 캐시 폴더를 지운 상태에서 빌드를 수행하고 다시한번 재빌드를 수행한 결과를 비교해봅니다.</p>
<p><img data-src="/images/posts/improve-webpack5-build-speed/wp5-build-04.png"></p>
<p>웹팩 5에서 지원하는 파일시스템 캐시를 적용하고나니 재빌드 시간이 무려 15초로 단축됨을 확인할 수 있습니다. 이처럼 웹팩 5로 변경하고나서 오히려 빌드 시간이 느려짐을 경험했던 분이라면 사용중인 로더와 플러그인에서 자체적인 캐시를 사용했는지 검토하고 <strong>파일시스템 캐시</strong>를 적용하셔야 할 수 있습니다.</p>
<h3 id="로더-및-플러그인-대체"><a href="#로더-및-플러그인-대체" class="headerlink" title="로더 및 플러그인 대체"></a>로더 및 플러그인 대체</h3><p>최신버전의 웹팩 구성을 위해서는 사용하는 로더와 플러그인들의 호환성을 위해 최신 버전으로 업데이트해야만 합니다. 로더와 플러그인들의 버전이 업데이트되면서 오히려 수행하는 일이 더 많아질 수 있음을 인지해야할 수 있습니다. 예를 들어, 바벨을 적용중이라면 더 많은 문법을 지원하거나 프리셋에 더 많은 플러그인이 기본적으로 포함될 수도 있습니다.</p>
<h4 id="esbuild-loader"><a href="#esbuild-loader" class="headerlink" title="esbuild-loader"></a>esbuild-loader</h4><p><a href="https://github.com/privatenumber/esbuild-loader">esbuild-loader</a>는 esbuild를 통해 웹팩 빌드를 더 빠르게 수행하기 위한 로더 중 하나입니다. 이외에도 <a href="https://github.com/swc-project/swc-loader">swc-loader</a>도 있습니다.</p>
<blockquote>
<p>esbuild와 swc는 떠오르는 자바스크립트 번들러입니다!</p>
</blockquote>
<p>esbuild는 자체적으로 빠른 것도 있지만 Minification도 함께 지원한다는 장점도 있습니다. 기존에는 트랜스파일링을 위해 바벨 로더를 사용하고 자바스크립트 또는 CSS 파일 축소를 위해서 terser-webpack-plugin과 css-minimizer-plugin을 적용해야했습니다. esbuild 만으로도 위 기능을 대체할 수 있기 때문에 여러가지 로더와 플러그인을 수행하는 것보다는 더 좋을 수 있습니다.</p>
<blockquote>
<p>웹팩 문서에서도 최대한 로더와 플러그인을 줄여야한다고 안내합니다.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">                loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                    <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">mimimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(),</span><br><span class="line">            <span class="keyword">new</span> CssMinimizerPlugin(&#123;</span><br><span class="line">                <span class="attr">minimizerOptions</span>: &#123;</span><br><span class="line">                    <span class="attr">preset</span>: [</span><br><span class="line">                        <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">discardDuplicates</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">                            <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 바벨을 esbuild-loader로 변경해보고 빌드를 해보겠습니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">                loader: <span class="string">&#x27;esbuild-loader&#x27;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                    <span class="attr">target</span>: <span class="string">&#x27;es2015&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/improve-webpack5-build-speed/wp5-build-05.png" alt="esbuild-loader + teser + css-miminizer"></p>
<p>초기 빌드 시 2분 54초라는 시간에서 <strong>2분 21초</strong>로 단축되었습니다.</p>
<h4 id="TerserPlugin-esbuildMinify"><a href="#TerserPlugin-esbuildMinify" class="headerlink" title="TerserPlugin.esbuildMinify"></a>TerserPlugin.esbuildMinify</h4><p>terser-webpack-plugin은 esbuild로 자바스크립트에 대한 최적화를 수행할 수 있도록 <code>TerserPlugin.esbuildMinify</code>를 지원합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">mimimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                <span class="attr">minify</span>: TerserPlugin.esbuildMinify</span><br><span class="line">            &#125;),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/improve-webpack5-build-speed/wp5-build-06.png" alt="esbuild-loader + teser[esbuild] + css-miminizer"></p>
<h4 id="CssMinimizerPlugin-esbuildMinify"><a href="#CssMinimizerPlugin-esbuildMinify" class="headerlink" title="CssMinimizerPlugin.esbuildMinify"></a>CssMinimizerPlugin.esbuildMinify</h4><p>css-minimizer-webpack-plugin도 esbuild로 CSS에 대한 최적화를 수행할 수 있도록 <code>CssMinimizerPlugin.esbuildMinify</code>을 지원합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">mimimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> CssMinimizerPlugin(&#123;</span><br><span class="line">                <span class="attr">minify</span>: CssMinimizerPlugin.esbuildMinify</span><br><span class="line">            &#125;),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/improve-webpack5-build-speed/wp5-build-07.png" alt="esbuild-loader + teser[esbuild] + css-miminizer[esbuild]"></p>
<h4 id="ESBuildMinifyPlugin"><a href="#ESBuildMinifyPlugin" class="headerlink" title="ESBuildMinifyPlugin"></a>ESBuildMinifyPlugin</h4><p>esbuild-loader에는 <a href="https://github.com/privatenumber/esbuild-loader#css-assets">ESBuildMinifyPlugin</a>가 포함되어있으므로 굳이 terser-webpack-plugin과 css-minimizer-webpack-plugin을 사용할 필요가 없습니다. 두개의 플러그인으로 수행하는 것보다는 하나의 플러그인으로 처리하는게 더 효율적입니다. 최적화에 대한 벤치마크는 <a href="https://github.com/privatenumber/minification-benchmarks">JS minification benchmarks</a>를 참고하시기 바랍니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ESBuildMinifyPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;esbuild-loader&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">mimimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> ESBuildMinifyPlugin(&#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;es2015&#x27;</span>,</span><br><span class="line">                <span class="attr">css</span>: <span class="literal">true</span></span><br><span class="line">            &#125;),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/improve-webpack5-build-speed/wp5-build-08.png" alt="esbuild-loader + esbuild-minify"></p>
<h3 id="빌드-결과-종합"><a href="#빌드-결과-종합" class="headerlink" title="빌드 결과 종합"></a>빌드 결과 종합</h3><p>기존에 사용하던 로더와 플러그인을 대체하면서 빌드 시간이 단축됨을 확인했습니다. 그러나 여러분의 프로젝트에서 요구하는 번들링 품질에 대해서도 검토하셔야만 합니다. 단순히 빌드 시간이 단축되었다고 더 좋다고 할 수는 없기 때문입니다. 예를 들어, esbuild에서 지원하는 문법의 한계가 있으므로 반드시 목표로하는 브라우저에서 동작하는지 검증해야합니다. </p>
<table>
<thead>
<tr>
<th>로더</th>
<th>플러그인</th>
<th>빌드시간</th>
</tr>
</thead>
<tbody><tr>
<td>babel-loader</td>
<td>teser + css-minimizer</td>
<td>2 mins, 54.35 secs</td>
</tr>
<tr>
<td>esbuild-loader</td>
<td>teser + css-minimizer</td>
<td>2 mins, 21.11 secs</td>
</tr>
<tr>
<td>esbuild-loader</td>
<td>teser[esbuild] + css-minimizer</td>
<td>1 mins, 29.034 secs</td>
</tr>
<tr>
<td>esbuild-loader</td>
<td>teser[esbuild] + css-minimizer[esbuild]</td>
<td>1 mins, 19.44 secs</td>
</tr>
<tr>
<td>esbuild-loader</td>
<td>esbuild-minify</td>
<td>1 mins, 16.92 secs</td>
</tr>
</tbody></table>
<blockquote>
<p>빌드 품질에 상관없으신 분들이라면 esbuild 도입을 검토해보시는 것도 나쁘지 않을 것 같습니다.</p>
</blockquote>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Webpack5</tag>
        <tag>Persistent cache</tag>
      </tags>
  </entry>
  <entry>
    <title>IP 대역 그리고 위치추적</title>
    <url>/ip-band-and-location-tracking/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 IT 인프라를 구성하는 IP 대역과 NAT 그리고 IP를 활용한 위치 추적에 대해서 알아봅니다. </p>
<h2 id="IP-대역"><a href="#IP-대역" class="headerlink" title="IP 대역"></a>IP 대역</h2><p>IT 인프라에서 IP는 퍼블릭 IP 그리고 프라이빗 IP로 구분되어집니다. <strong>퍼블릭 IP</strong>는 인터넷에 접속할 수 있는 공인 IP를 말하며 <strong>프라이빗 IP</strong>는 개인적으로 구성한 네트워크 망에서 사용하는 사설 IP를 말합니다. 따라서, <strong>사설망 IP로는 외부 인터넷 접속을 통해 구글 또는 네이버 사이트에 접근할 수 없습니다.</strong></p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p><a href="https://datatracker.ietf.org/doc/html/rfc1631">NAT(IP Network Address Translator)</a>는 IPv4 주소체계의 한계로 인하여 IP 주소가 부족해지는 현상을 보완하기 위해 사용하는 기술입니다. NAT는 <strong>내부 사설망 IP를 가지고 외부 네트워크망에 접속할 수 있도록 공인 IP로 변환</strong>하는 기능을 수행합니다. 일반적으로 사용하는 공유기에는 NAT 기능을 포함하고 있기 때문에 공유기에서 192.168.0.2와 같은 주소를 할당하더라도 외부 인터넷에 접속할 경우에는 공인 IP로 변환하여 요청하게 됩니다.</p>
<p>이러한 차이로 윈도우 컴퓨터의 명령프롬프트에서 <strong>ifconfig</strong> 명령어를 실행하면 <strong>공유기에서 할당한 사설 IP</strong>를 확인할 수 있지만 아이피 정보를 확인할 수 있는 <a href="https://ipconfig.io/">ipconfig.io</a>, <a href="https://ifconfig.io/">ifconfig.io</a>, <a href="https://ifconfig.me/">ifconfig.me</a>에 접속해보면 사설 IP가 아닌 <strong>공인 IP</strong>를 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/ip-band-and-location-tracking/ipconfig-01.png" alt="내부 아이피 조회"></p>
<p><img data-src="/images/posts/ip-band-and-location-tracking/ipconfig-02.png" alt="외부 아이피 조회"></p>
<h3 id="IP-위치-조회"><a href="#IP-위치-조회" class="headerlink" title="IP 위치 조회"></a>IP 위치 조회</h3><p>위에서 확인한 공인 IP에 대해서 위치추적 사이트라는 곳에서 조회를 해보면 실제로 살고있는 곳 보다는 터무니없는 곳을 보여주는 경우가 많습니다. 이렇게 위치추적 사이트에서 IP에 대한 위치 조회가 정확하지 않은 이유는 <strong>인터넷 서비스 사업자(ISP)인 KT 인터넷과 같은 업체에서 지역을 정해서 IP 대역을 할당</strong>하고 그 지역내에서 DHCP를 통해 동적으로 할당하기 때문입니다. 예를 들어, 한국인터넷진흥원에서 제공하는 <a href="https://후이즈검색.한국/">WHOIS</a> 서비스를 통해 IP를 조회해보면 조금 더 상세한 지역을 안내해줍니다.</p>
<p><img data-src="/images/posts/ip-band-and-location-tracking/ipconfig-03.png" alt="WHOIS 조회"></p>
<p>실제로 제가 살고 있는 경기도 양주시에서 사용중인 IP라고 안내해주었습니다. 이렇게 한국인터넷진흥원에서 보다 정확한 위치를 확인할 수 있는 이유는 <strong>KT 인터넷과 같은 인터넷 서비스 사업자에서 한국인터넷진흥원에 지역에 대한 IP 대역 정보를 등록</strong>하기 때문입니다.</p>
<p>공인 IP 대역의 <strong>218.152.0.0부터 218.159.255.255는 KT 인터넷에서 사용중인 IP 대역</strong>이며 그 중에서 218.156.190.X에 대한 IP 대역은 경기도 양주시에서 사용하도록 할당하는 것을 알 수 있습니다. 위치 추적 사이트에서 인터넷 서비스 사업자의 IP 대역은 알 수 있지만 <strong>특정 IP가 실제로 KT 인터넷이 어떤 지역에 할당했는지에 대한 정보가 없기 때문에</strong> KT 인터넷에 대한 본사 또는 지역적으로 퍼져있는 KT 인터넷 장비의 위치 정보를 대신 표시해주는 것 입니다.</p>
<blockquote>
<p>인터넷 서비스 사업자는 지역에 대하여 IP 대역을 형성하기 때문에 특정 IP 대역에서 트래픽 과부화가 발생하면 인터넷 속도를 제한하는 락을 걸기도 합니다. 실제로 인터넷 속도가 충분하게 나오지 않아서 인터넷 기사를 불러 확인해보면 주변 장비에 대한 정보를 확인하고 락 해제를 요청하는 걸 많이 경험했습니다.</p>
<p>지난 4월에 난리였던 <a href="https://www.seoul.co.kr/news/newsView.php?id=20210420500154">KT ‘10기가 인터넷’ 속도저하 논란에 방통위 조사 나선다</a>와 같은 경우도 트래픽 규모에 따라 제한을 둔 것인데 기술적으로 결함이 있지 않았나 싶네요.</p>
</blockquote>
<h3 id="현실과-영화는-다르다"><a href="#현실과-영화는-다르다" class="headerlink" title="현실과 영화는 다르다"></a>현실과 영화는 다르다</h3><p>아무튼, 영화에서는 IP 정보를 알게되면 해당 IP를 사용하는 범죄자의 위치를 정확히 아는 것처럼 나오는 경우가 많습니다. 실제로는 경찰이 필요에 의해 웹 서비스 회사에 특정 아이디에 대한 IP 이력 정보를 요구하는 공조 요청을 하게 되고 <strong>제공받은 IP를 다시 인터넷 서비스 사업자인 KT 본사에게 IP 대역에 대한 정보를 요청</strong>하게 됩니다. 그래서 최종적으로는 <strong>정확한 위치는 아니더라도 대략적으로 읍면동까지</strong>는 알게됩니다.</p>
<p>범죄자가 사용하는 IP가 해외에서 사용하는 공인 IP 정보로 조회되는 경우에는 더 까다로워지는 것은 맞습니다. 해당 IP 대역을 할당하는 인터넷 서비스 업체에게 공조 요청을 하는게 아니라 <strong>국제형사사법 공조법에 의거</strong>해서 국가 간 공조 요청을 하고 제공받아야합니다. 경찰분들이 담당하는 사건들이 하나가 아니기 때문에 해외 IP에 대한 추적을 꺼려하는게 어찌보면 당연할 수 있습니다. </p>
<p>그럼에도 불구하고 <a href="https://www.youtube.com/watch?v=aWqK1b5w9Yo">성 착취 영상물을 유포한 사건</a>의 용의자도 집요한 추적 끝에 잡아내기도 하죠. 해외 VPN 서버를 사용하면 추적할 수 없다는 이야기를 하는 사람들이 많은데 <strong>사실은 추적은 되지만 귀찮을 수 있다</strong>라고 봐야겠죠.</p>
<h2 id="실무-환경에서의-IP"><a href="#실무-환경에서의-IP" class="headerlink" title="실무 환경에서의 IP"></a>실무 환경에서의 IP</h2><p>그러면 실무 환경인 회사에서 사용하는 IP에 대해서 알아보도록 하겠습니다. 회사에서도 자체 내부 사설망을 구축하여 회사 내부에서 근무하는 직원들이 사용할 수 있는 IP를 할당하게 됩니다. 이러한 것은 회사 네트워크를 관리하는 네트워크 담당자가 수행합니다. </p>
<h3 id="NAT-아이피"><a href="#NAT-아이피" class="headerlink" title="NAT 아이피"></a>NAT 아이피</h3><p>일반적으로 라우터 장비로부터 DHCP로 동적으로 할당받는 내부 아이피를 사용하여 인터넷을 사용하지만 경우에 따라서는 외부 인터넷망에서 회사 네트워크 대역에 접근할 수 있도록 NAT 아이피를 요청해야하는 경우도 있습니다.</p>
<p style="text-align:center; font-weight:bold;">"외부에서 접근하기 위한 NAT 아이피가 필요합니다."</p>

<p>그러면 네트워크 담당자는 NAT 아이피가 필요한 사유를 검토하고 NAT 아이피와 함께 외부에서 접근 가능한 도메인 주소와 포트 정보를 전달해줍니다. 회사 라우터 장비에서는 외부 트래픽의 도메인과 포트를 확인하고 연결된 NAT 아이피로 트래픽을 전달해줌으로써 내부 사설망에서 실행중인 애플리케이션에 접근할 수 있게 됩니다.</p>
<h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>코로나 19로 인하여 <strong>대부분의 IT 기업들이 재택근무를 허용</strong>하게 되었습니다. 필요에 의해 회사로 출근하기도 하지만 대부분의 업무는 집에서 수행합니다. 하지만, 개발 조직에서는 개발 환경에서 사용하는 많은 인스턴스를 외부에서 접근이 불가능한 회사 내부 사설망 서버에 구축합니다. 그리고 아마존 웹 서비스와 같은 클라우드 환경을 사용한다고 하더라도 <strong>SSH를 통한 인스턴스 접근은 회사에서 사용중인 아이피 대역에 대해서만 허용</strong>하는 경우가 많습니다.</p>
<p>집에서 사용하는 공인 IP는 회사에서 사용하는 아이피 대역이 아니므로 SSH 접근이 불가능합니다. 그렇기 때문에 회사 외부에서도 회사에서 사용하는 아이피 대역처럼 사용할 수 있는 VPN을 활용하게 됩니다. 제가 다니고 있는 회사에서는 <strong>TLS 프로토콜을 적용하여 통신하는 OpenVPN을 사용</strong>하고 있으며 여자친구가 일하는 회사에서는 Pulse Secure와 함께 <a href="https://vip.symantec.com/">VIP Access</a>을 사용하여 2단계 인증까지 요구하기도 합니다.</p>
<p>이 글을 보신 여러분들도 인터넷 접속을 위해 할당받은 외부 아이피를 확인해보고 한국인터넷진흥원의 WHOIS 서비스를 통해 어느 지역까지 추적되는지 경험해보시기 바랍니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>IP Band</tag>
        <tag>NAT</tag>
        <tag>Location Tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>KDB+</title>
    <url>/kdbplus/</url>
    <content><![CDATA[<blockquote>
<p>이 글은 KDB+라는 시계열 데이터베이스를 활용하면서 국내 레퍼런스를 찾아볼 수 없는 문제로 인하여 별도로 정리한 내용입니다. 따라서, 전문적으로 활용하는 수준은 아니므로 잘못된 정보가 포함되어있을 수 있음을 알려드립니다. KDB+에 대한 더 자세한 내용은 <a href="https://github.com/kdevkr/kdb%EB%A5%BC">https://github.com/kdevkr/kdb를</a> 참고하시기 바랍니다.</p>
</blockquote>
<h2 id="KDB"><a href="#KDB" class="headerlink" title="KDB+"></a>KDB+</h2><p><a href="https://kx.com/">KDB+</a>는 KxSystems라는 회사에서 개발하고 제공하는 상용 시계열 데이터베이스입니다. 메모리 엔진을 사용하므로 데이터를 넣거나 연산을 수행하는 시간이 굉장히 짧습니다. 그러나 q 라는 자체적으로 고안한 언어에 대해서 이해해야해서 러닝커브에 대한 단점이 있습니다. 예를 들어, 다음은 KxSystems에서 권장하는 <a href="https://github.com/KxSystems/kdb-tick/blob/master/tick.q">Tickerplant라는 아키텍처의 스크립트 일부분</a>입니다.</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">ld:&#123;if[<span class="built_in">not</span> <span class="built_in">type</span> <span class="built_in">key</span> L::`$(<span class="number">-10</span>_string L),<span class="built_in">string</span> x;.[L;();:;()]];i::j::<span class="number">-11</span>!(<span class="number">-2</span>;L);if[<span class="number">0</span>&lt;=<span class="built_in">type</span> i;<span class="number">-2</span> (<span class="built_in">string</span> L),<span class="string">&quot; is a corrupt log. Truncate to length &quot;</span>,(<span class="built_in">string</span> last i),<span class="string">&quot; and restart&quot;</span>;exit <span class="number">1</span>];<span class="built_in">hopen</span> L&#125;;</span><br><span class="line">tick:&#123;init[];if[<span class="built_in">not</span> <span class="built_in">min</span>(<span class="type">`time</span>`sym~<span class="number">2</span>#<span class="built_in">key</span> <span class="built_in">flip</span> <span class="built_in">value</span>@)<span class="built_in">each</span> t;&#x27;`timesym];@[;`sym;`g#]<span class="built_in">each</span> t;d::.z.D;if[l::<span class="built_in">count</span> y;L::`$<span class="string">&quot;:&quot;</span>,y,<span class="string">&quot;/&quot;</span>,x,<span class="number">10</span>#<span class="string">&quot;.&quot;</span>;l::ld d]&#125;;</span><br><span class="line"></span><br><span class="line">endofday:&#123;end d;d+:<span class="number">1</span>;if[l;<span class="built_in">hclose</span> l;l::<span class="number">0</span>(`.u.ld;d)]&#125;;</span><br><span class="line">ts:&#123;if[d&lt;x;if[d&lt;x<span class="number">-1</span>;<span class="built_in">system</span><span class="string">&quot;t 0&quot;</span>;&#x27;<span class="string">&quot;more than one day?&quot;</span>];endofday[]]&#125;;</span><br><span class="line"></span><br><span class="line">if[<span class="built_in">system</span><span class="string">&quot;t&quot;</span>;</span><br><span class="line"> .z.ts:&#123;pub&#x27;[t;<span class="built_in">value</span> <span class="built_in">each</span> t];@[`.;t;@[;`sym;`g#]<span class="number">0</span>#];i::j;ts .z.D&#125;;</span><br><span class="line"> upd:&#123;[t;x]</span><br><span class="line"> if[<span class="built_in">not</span> <span class="number">-16</span>=<span class="built_in">type</span> <span class="built_in">first</span> <span class="built_in">first</span> x;if[d&lt;<span class="string">&quot;d&quot;</span>$a:.z.P;.z.ts[]];a:<span class="string">&quot;n&quot;</span>$a;x:$[<span class="number">0</span>&gt;<span class="built_in">type</span> <span class="built_in">first</span> x;a,x;(<span class="built_in">enlist</span>(<span class="built_in">count</span> <span class="built_in">first</span> x)#a),x]];</span><br><span class="line"> t insert x;if[l;l <span class="built_in">enlist</span> (`upd;t;x);j+:<span class="number">1</span>];&#125;];</span><br><span class="line"></span><br><span class="line">if[<span class="built_in">not</span> <span class="built_in">system</span><span class="string">&quot;t&quot;</span>;<span class="built_in">system</span><span class="string">&quot;t 1000&quot;</span>;</span><br><span class="line"> .z.ts:&#123;ts .z.D&#125;;</span><br><span class="line"> upd:&#123;[t;x]ts<span class="string">&quot;d&quot;</span>$a:.z.P;</span><br><span class="line"> if[<span class="built_in">not</span> <span class="number">-16</span>=<span class="built_in">type</span> <span class="built_in">first</span> <span class="built_in">first</span> x;a:<span class="string">&quot;n&quot;</span>$a;x:$[<span class="number">0</span>&gt;<span class="built_in">type</span> <span class="built_in">first</span> x;a,x;(<span class="built_in">enlist</span>(<span class="built_in">count</span> <span class="built_in">first</span> x)#a),x]];</span><br><span class="line"> f:<span class="built_in">key</span> <span class="built_in">flip</span> <span class="built_in">value</span> t;pub[t;$[<span class="number">0</span>&gt;<span class="built_in">type</span> <span class="built_in">first</span> x;<span class="built_in">enlist</span> f!x;<span class="built_in">flip</span> f!x]];if[l;l <span class="built_in">enlist</span> (`upd;t;x);i+:<span class="number">1</span>];&#125;];</span><br></pre></td></tr></table></figure>

<p>KDB+에서는 q라는 언어로 작성된 스크립트를 사용합니다. 위처럼 KxSystems에서 제공하는 샘플 스크립트가 존재하기는 하지만 코드에 대한 설명이 없으므로 위 코드를 이해하는 건 전부 사용자인 개발자의 몫이며 이로 인하여 러닝커브가 높을 수 있습니다. 저는 Q 언어에 대한 튜토리얼을 제공할 의도가 아니므로 공식 레퍼런스에서 제공하는 정보를 참고하면서 알게되거나 느낀점을 공유해보려고 합니다.</p>
<blockquote>
<p>Q 언어에 대해서 궁금하시다면 <a href="https://code.kx.com/q/basics/by-topic/">Q language resources by topic</a>를 참고하세요.</p>
</blockquote>
<h3 id="q-프로세스"><a href="#q-프로세스" class="headerlink" title="q 프로세스"></a>q 프로세스</h3><p>KDB+/q 프로세스는 Windows, Mac OSX, Linux 운영체제에서 사용할 수 있도록 지원합니다. 운영체제에 따라 사용할 수 있는 기능이 몇가지 부분에 대해서 다를 수는 있습니다. 예를 들어, 리눅스 운영체제에서는 <a href="https://code.kx.com/q4m3/11_IO/#116-interprocess-communication">프로세스 통신</a>을 위해 TCP/IP를 사용할 때 유닉스 도메인 소켓 방식을 사용할 수 있습니다.</p>
<h4 id="실행-환경-변수"><a href="#실행-환경-변수" class="headerlink" title="실행 환경 변수"></a>실행 환경 변수</h4><p>KDB+의 q 프로세스는 실행되는 시점에 QHOME, QLIC, QINIT 환경 변수를 참조합니다. </p>
<ul>
<li>QHOME: KDB 프로세스를 실행하기 위하여 부트스트랩할 q.k 파일을 찾는 경로입니다.</li>
<li>QLIC: KDB 프로세스에서 사용할 라이센스 파일을 지정합니다. 기본적으로 QHOME 경로에서 kc.lic 파일을 요구합니다.</li>
<li>QINIT: q.k 파일이 부트스트랩된 이후에 루트 컨텍스트 위치에서 실행될 스크립트 파일입니다. 이 환경변수가 정의되지 않으면 QHOME 위치에서 q.q 파일을 실행합니다.</li>
</ul>
<h4 id="프로세스-실행-인수"><a href="#프로세스-실행-인수" class="headerlink" title="프로세스 실행 인수"></a>프로세스 실행 인수</h4><p>공식 문서의 <a href="https://code.kx.com/q/basics/cmdline/">커맨드 라인 옵션</a>을 참고하면 프로세스 실행 시 적용할 수 있는 인수 옵션을 확인할 수 있습니다. 일반적으로 프로세스를 실행할 때 지정하는 옵션은 아래와 같습니다.</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -p: 수신 포트</span></span><br><span class="line"><span class="comment">// -s: 병렬 처리 시 사용될 보조 스레드</span></span><br><span class="line">q script.q -p <span class="number">5000</span> -s <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>프로세스 실행 시 보조 스레드 옵션을 지정해야 스레드가 활성화되며 REPL에서만 동작합니다. 따라서, 백그라운드 데몬 프로세스를 실행하는 경우 보조 스레드 수를 동적으로 변경할 수 없습니다. 아래와 같이 클라이언트를 통해 q 프로세스에 보조 스레드 수를 변경하기 위한 시스템 명령을 전달하는 경우 오류가 발생합니다.</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">q)\s <span class="number">4</span></span><br><span class="line">&#x27;enable secondary threads via cmd line -s only</span><br></pre></td></tr></table></figure>

<h4 id="프로세스-종료"><a href="#프로세스-종료" class="headerlink" title="프로세스 종료"></a>프로세스 종료</h4><p>REPL 세션 또는 연결된 클라이언트에서 <a href="https://code.kx.com/q/basics/syscmds/#quit">\</a>를 입력하거나 <a href="https://code.kx.com/q/ref/exit/">exit 0</a>을 입력해서 프로세스를 종료할 수 있습니다. </p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">\\\</span><br><span class="line">exit <span class="number">0</span></span><br><span class="line">sublime-q &gt;&gt; 현재 연결은 원격 호스트에 의해 연결이 강제로 끊겼습니다.</span><br></pre></td></tr></table></figure>

<h3 id="스크립트-파일"><a href="#스크립트-파일" class="headerlink" title="스크립트 파일"></a>스크립트 파일</h3><p>REPL인 q 세션에서는 멀티 라인 표현식을 지원하지 않습니다. 따라서, <a href="https://code.kx.com/q/learn/tour/scripts/">스크립트 파일</a>을 작성하는게 더 효율적이며 서브라임 텍스트의 <a href="https://github.com/komsit37/sublime-q">sublime-q</a>와 같은 패키지를 활용하면 쉽게 q 프로세스와 통신하여 상호작용이 가능합니다. 또한, 스크립트 파일을 작성해두면 q 프로세스를 실행할 때 해당 스크립트 파일을 불러올 수 있도록 추가할 수 있습니다.</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">q script.q -p <span class="number">5000</span></span><br><span class="line">KDB+ <span class="number">4.0</span> <span class="number">2021.07</span><span class="number">.12</span> Copyright (C) <span class="number">1993</span><span class="number">-2021</span> Kx Systems</span><br><span class="line">w64/ <span class="number">12</span>(<span class="number">16</span>)core <span class="number">32700</span>MB Mambo desktop-ojj4tb3 <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span> EXPIRE <span class="number">2022.11</span><span class="number">.01</span> kdevkr@gmail.com KOD #<span class="number">5006323</span></span><br><span class="line"></span><br><span class="line"><span class="number">2021.11</span><span class="number">.04</span>T22:<span class="number">38</span>:<span class="number">41.153</span> [INFO] KDB+ Version: <span class="number">4</span></span><br><span class="line"><span class="number">2021.11</span><span class="number">.04</span>T22:<span class="number">38</span>:<span class="number">41.153</span> [INFO] KDB+ ProcessID: <span class="number">24388</span></span><br><span class="line"><span class="number">2021.11</span><span class="number">.04</span>T22:<span class="number">38</span>:<span class="number">41.153</span> [INFO] KDB+ License: <span class="number">16</span> <span class="number">2022.11</span><span class="number">.01</span> <span class="number">2022.11</span><span class="number">.01</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> kdevkr@gmail.com KOD #<span class="number">5006323</span> <span class="number">0</span></span><br><span class="line">The script file loaded after q.q file.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>QINIT 또는 q.q 파일에 정의된 스크립트는 무조건 실행되므로 공통으로 적용되어야하는 사항은 QINIT 스크립트 파일에 작성하는 것이 좋습니다.</p>
</blockquote>
<h4 id="스크립트-내-프로세스-통신"><a href="#스크립트-내-프로세스-통신" class="headerlink" title="스크립트 내 프로세스 통신"></a>스크립트 내 프로세스 통신</h4><p>스크립트 내에서 프로세스 통신을 위해 <a href="https://code.kx.com/q/basics/handles/">Connection handles</a>를 사용하는 경우 일반적인 문자열 형태의 q 표현식을 전달하는 것보다는 <a href="https://code.kx.com/q/learn/startingkdb/ipc/">람다 함수와 파라미터</a>를 보내는 메시지 형식을 사용하는 것이 더 효율적입니다.</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">h: <span class="built_in">hopen</span> `::<span class="number">5011</span>;</span><br><span class="line">h(&#123;trades&#125;;::)</span><br></pre></td></tr></table></figure>

<p>위와 같이 함수와 파라미터를 전달하는 경우 IDE에서 지원하는 구문 강조가 적용되어 원하는 바를 더 명확하게 확인할 수 있다는 장점도 제공됩니다.</p>
<h4 id="커맨드-라인-파라미터"><a href="#커맨드-라인-파라미터" class="headerlink" title="커맨드 라인 파라미터"></a>커맨드 라인 파라미터</h4><p>프로세스에서 실행할 스크립트를 작성할 때 프로세스 실행 시 입력해야할 정보가 필요할 수 있습니다. KDB에서 제공하는 미리 정의된 네임스페이스를 통해 커맨드 라인에서 입력한 파라미터를 스크립트에서 가져올 수 있습니다.</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">q -p <span class="number">5000</span> -pidfile q.pid</span><br></pre></td></tr></table></figure>

<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .z.x를 사용하여 커맨드 라인 옵션을 제외한 인수를 파라미터로 가져올 수 있다.</span></span><br><span class="line">.z.x</span><br><span class="line"><span class="string">&quot;-pidfile&quot;</span></span><br><span class="line"><span class="string">&quot;q.pid&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .Q.opt를 사용하여 커맨드 라인 파라미터를 Dict로 변경할 수 있다.</span></span><br><span class="line">.Q.opt .z.x</span><br><span class="line">pidfile| <span class="string">&quot;q.pid&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .Q.def를 사용하여 커맨드 라인 파라미터에 대한 기본값을 정의할 수 있다.</span></span><br><span class="line">.Q.def[`whoami`logdst`pidfile!(`mambo;`$(<span class="string">&quot;logs/q.log&quot;</span>);`)].Q.opt .z.x</span><br><span class="line">whoami | mambo</span><br><span class="line">logdst | logs/q.log</span><br><span class="line">pidfile| q.pid</span><br></pre></td></tr></table></figure>

<h3 id="사용자-및-패스워드"><a href="#사용자-및-패스워드" class="headerlink" title="사용자 및 패스워드"></a>사용자 및 패스워드</h3><p><a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd">사용자에 대한 패스워드를 정의한 파일을 지정</a>하여 q 프로세스와의 연결을 제한할 수 있습니다. 비밀번호는 평문, MD5, SHA-1을 지원합니다. 단, 사용자와 비밀번호 암호 방식은 유일해야하므로 평문을 사용하는 사용자와 SHA-1 해시가 적용된 사용자를 같이 구성할 수 없습니다. q 프로세스를 실행할 때 -u 옵션에 패스워드 파일을 지정하면 프로세스 실행 후에도 패스워드 파일을 수정하고 \u 명령어로 프로세스를 중단하지 않고 사용자 및 패스워드를 적용할 수 있습니다. 이와 같은 정보를 토대로 다음과 같은 방식으로도 사용자 및 패스워드를 적용할 수 있습니다.</p>
<p><strong>익명 사용자에 대한 패스워드 파일 생성</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:</span><br></pre></td></tr></table></figure>

<p><strong>q 프로세스 실행 시 패스워드 파일 적용</strong></p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">q -p <span class="number">5000</span> -u userpass.txt</span><br></pre></td></tr></table></figure>

<p><strong>신규 사용자의 패스워드 해시 생성</strong></p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="comment">// raze string md5 &quot;mambo&quot;</span></span><br><span class="line"><span class="comment">// &quot;dfa67b75dc3d5868c3e88c83774c0d01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">raze</span> <span class="built_in">string</span> <span class="number">-33</span>!<span class="string">&quot;mambo&quot;</span></span><br><span class="line"><span class="string">&quot;78492a38605bdf6e691c4e2f77c69c4a0904c647&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>신규 사용자 및 패스워드 적용 후 저장</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mambo:78492a38605bdf6e691c4e2f77c69c4a0904c647</span><br></pre></td></tr></table></figure>

<p><strong>사용자 및 패스워드 정보 갱신</strong></p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">\u</span><br><span class="line"></span><br><span class="line"><span class="built_in">hopen</span> `:localhost:<span class="number">5000</span>:mambo:mambo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>패스워드 파일에 사용자 이름을 생략함으로써 익명 사용자에 대한 비밀번호도 적용할 수 있습니다.</p>
</blockquote>
<h3 id="아키텍처"><a href="#아키텍처" class="headerlink" title="아키텍처"></a>아키텍처</h3><p>학습 단계에서는 KDB+를 단일 q 프로세스로 실행하여 사용하지만 실제로 운용되는 환경에서는 KxSystems에서 권장하는 <a href="https://code.kx.com/q/architecture/">Tickerplant 아키텍처</a>를 구성합니다. q 프로세스에서 사용할 메모리가 부족해지면 <strong>`wsfull</strong> 오류가 발생하고 프로세스가 종료되는 문제점을 가지고 있습니다. Tickerplant는 FeedHandler에서 전송되는 데이터를 수신하는 TP 프로세스와 TP 프로세스로 들어온 데이터를 가져가는 RDB(Realtime DB) 프로세스, 날짜 또는 시간 단위로 저장하는 HDB(Historical DB) 프로세스로 분리하게 됩니다. 각 프로세스의 역할이 구분되어있으므로 현재 날짜 또는 시간에 대한 데이터를 메모리에 저장하는 RDB 프로세스가 예기치 못한 상황에 종료되더라도 TP 프로세스는 지속적으로 데이터를 수신할 수 있게 됩니다.</p>
<blockquote>
<p><a href="https://code.kx.com/q/learn/startingkdb/tick/">Realtime database</a><br>As a minimum, it is recommended to have RAM of at least 4× expected data size, so for 5 GB data per day, the RDB machine should have at least 20 GB RAM. In practice, much larger RAM might be used.</p>
</blockquote>
<p>위 내용에 따르면 날짜별로 파티셔닝되는 구조를 가지는 경우에 RDB 프로세스에 5GB 규모의 데이터를 보유하고 있어야한다면 시스템적으로 최소한 20GB 만큼의 메모리가 준비되어야합니다. 또한, 시스템 자원을 준비할 수 있지 않아 날짜가 아닌 시간 단위로 파티셔닝하는 경우 무수히 많은 폴더가 만들어지므로 긴 범위의 기간에 대한 연산을 수행하여야하는 경우 I/O 성능이 좋은 디스크를 사용해야할 수 있습니다.</p>
<h4 id="데이터-관리"><a href="#데이터-관리" class="headerlink" title="데이터 관리"></a>데이터 관리</h4><p>Tickerplant는 KDB+에서 권장되는 아키텍처이지만 데이터 관리에 대한 문제점을 가지고 있습니다. 일반적으로 사용되는 증권 시장의 경우 데이터가 순차적으로 발생한다는 것이 보장되며 지난 기간에 대한 데이터가 현재 시간에 들어오지 않는다는 것을 기준으로 하기 때문에 사업 분야와 고객의 요구사항으로 인하여 현재 시점에 지난 기간에 대한 데이터를 등록하는 경우 RDB 프로세스에서 메모리에 저장된 데이터를 파일로 저장하는 시점에 해당 파티션 폴더에는 지난 기간에 대한 파티션 데이터가 포함되어있게 됩니다.</p>
<p>q 프로세스에서 파티션 테이블에 대해서는 각 파티션에 맞는 데이터만 존재해야함을 보장해야합니다. 그 이유는 데이터 연산 시 파티셔닝의 기준이 되는 특수한 컬럼을 통해 전체 파티션을 조회하지 않고도 빠르게 필요한 파티션의 데이터를 메모리에 로드할 수 있기 때문입니다. 결국에는 RDB 프로세스가 저장한 파티션 폴더의 데이터를 확인하고 올바른 파티션에 데이터를 병합해야하는 작업을 수행해야합니다.</p>
<p>데이터베이스를 운용하면서 데이터 병합 과정을 거치고 난 후 파티셔닝된 폴더가 순차적으로 나열되지 않을 수 있을 수 있습니다. 이러한 문제가 발생하는 경우 q 프로세스는 정확한 파티션을 확인할 수 없으므로 일부 조회가 불가능한 상태가 될 가능성이 있습니다. 다행히도 KDB+에서 제공하는 몇가지 함수를 이용해서 잘못된 파티셔닝을 바로 잡도록 작업을 수행해볼 수 있습니다.</p>
<ul>
<li><a href="https://code.kx.com/q/ref/dotq/#qchk-fill-hdb">.Q.chk (fill HDB)</a></li>
<li><a href="https://code.kx.com/q/ref/dotq/#qbv-build-vp">.Q.bv (build vp)</a></li>
<li><a href="https://code.kx.com/q/ref/dotq/#qvp-missing-partitions">.Q.vp (missing partitions)</a></li>
</ul>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">.Q.bv[]</span><br><span class="line">.Q.vp</span><br><span class="line"></span><br><span class="line">.Q.chk[]</span><br></pre></td></tr></table></figure>

<h3 id="제한-및-오류"><a href="#제한-및-오류" class="headerlink" title="제한 및 오류"></a>제한 및 오류</h3><p>KDB+의 q 프로세스에 존재하는 몇가지 제한 사항에 대해서 알아보겠습니다.</p>
<h4 id="라이센스-코어-제한"><a href="#라이센스-코어-제한" class="headerlink" title="라이센스 코어 제한"></a>라이센스 코어 제한</h4><p>먼저, 상업용 라이센스를 구매하더라도 라이센스에 지정된 코어 수를 넘어가게되는 시스템을 사용하려는 경우 q 프로세스 실행 시 <strong>`cores</strong> 라는 오류가 발생합니다. 이는 q 프로세스가 해당 코어 수를 사용할 수 있도록 허용되지 않기 때문이므로 프로세스를 실행할 때 리눅스의  <strong>taskset</strong>을 활용하여 프로세스가 사용할 수 있는 CPU를 지정해야합니다.</p>
<h4 id="함수-파라미터-개수-제한"><a href="#함수-파라미터-개수-제한" class="headerlink" title="함수 파라미터 개수 제한"></a>함수 파라미터 개수 제한</h4><p>공식 문서의 <a href="https://code.kx.com/q/basics/errors/">Errors</a>를 참고하면 q 프로세스에서 발생하는 오류에 대해서 검토할 수 있습니다. 특히, 함수 파라미터 개수는 최대 8개로 제한되어있는 특징이 있습니다. 따라서, 스크립트에 정의하는 함수 또는 람다에서 사용되는 파라미터 개수가 8개보다 많아지는 경우 Dict를 활용해야할 수 있습니다. 이외에도 다음의 제한된 사항이 있습니다.</p>
<ul>
<li>conn: Too many connections (1022 max)</li>
<li>elim: Too many enumerations (max: 57)</li>
<li>globals: Too many global variables</li>
<li>limit: Too many constants</li>
<li>locals: Too many local variables</li>
<li>params: Too many parameters (8 max)</li>
</ul>
<h3 id="느낀점"><a href="#느낀점" class="headerlink" title="느낀점"></a>느낀점</h3><p>현재 조직에서는 KDB+ 시계열 데이터베이스를 사용중이지만 이와 관련한 국내 레퍼런스는 찾아볼 수 없으므로 다른 회사로 이직하게되면 더이상 관심가지지않을 것 같습니다. 컬럼형 시계열 데이터베이스이면서 빠른 속도를 제공하는 것은 맞지만 그에 따른 라이센스 비용과 어떻게 사용하는 것이 좋거나 문제가 발생했을때의 해결방안을 찾고 원하는 결과를 가지기 위해서 Q 언어와 함께 qSQL이라고하는 SQL과 비슷하지만 다른 쿼리를 작성하는 것이 효율적이다라고 볼 수 없는 것 같습니다.</p>
<p>기본적으로 메모리에 데이터를 저장하고 파일로 저장된 데이터는 연산 시 메모리에 불러오게되므로 데이터 규모에 따라 프로세스를 실행하는 시스템 자원이 보장되어야한다는 문제점도 있습니다. 시스템 메모리 자원을 확보할 수 없는 경우 파티션으로 저장되는 구조를 지원하지만 다수의 폴더로 분산하여 데이터를 저장하기 때문에 디스크 I/O 성능도 고려해야합니다. 결국 예상되는 규모에 따라 안정적으로 운용될 수 있도록 시스템 자원을 준비해야합니다.</p>
<p>조직내에서는 어쩔 수 없이 사용하고 있지만 개인적으로 학습하는 것은 추천하지 않을 것 같습니다.</p>
<h2 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h2><ul>
<li><a href="https://code.kx.com/">code.kx</a></li>
<li><a href="https://community.kx.com/">community.kx</a></li>
</ul>
]]></content>
      <tags>
        <tag>Kx</tag>
        <tag>KDB+</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS IAM 사용자 리전 제한하기</title>
    <url>/limit-region-aws-iam-user/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>회사에 있던 책들 중 <strong>탄력적 개발로 이끄는 AWS 실천 기술</strong>이라는 책을 읽어보고 관련된 정보를 찾으면서 AWS 활용 방안에 대해 공부하고 있습니다.</p>
<p>AWS 프리 티어 또는 AWS 서비스를 학습하는 사람이라면 모든 권한을 가지고 있는 루트 사용자 계정을 사용하는 경우가 많을겁니다. 실무 환경에서는 회사의 루트 사용자 계정이 아닌 IAM을 통해 직무 또는 특정 권한을 가지는 사용자를 만들어서 사용하도록 구성하겠죠. 보안 등급이 높거나 체계적인 회사라면 AWS 리소스에 대한 정책을 검토하고 부여하겠지만 제가 다니고 있는 회사의 팀에서도 모든 권한을 부여한 사용자를 만들어서 사용하고 있는 것을 보았고 직원마다 권한을 부여할 수 있도록 사용자를 발급해달라고 요청하여 사용하고는 있습니다.</p>
<blockquote>
<p>루트 사용자 계정을 사용하지 않는다고 해도 권한 정책을 검토하고 부여하는 것이 귀찮은 건 맞습니다. 결국 사용자에게 모든 권한을 가지는 정책을 연결하여 사용할 수도 있습니다.</p>
</blockquote>
<p>AWS와 같은 클라우드 서비스는 다양한 지역에 존재하는 데이터 센터에 자원을 생성하고 사용할 수 있도록 지원하기 때문에 사용자 계정 정보가 유출된다면 주로 사용하는 리전이 아닌 곳에 AWS 리소스가 생성되고 요금이 발생하는 문제가 생길 수 있습니다. 일부 요금 폭탄 문제가 생기는 분들도 주로 사용하는 서울 리전에 대한 리소스만 체크한 상태로 있다가 전혀 사용하지 않고 있는 리전에 실행된 AWS 리소스로 인하여 발생하는 요금으로 당황하는 경우도 많은 것 같습니다. </p>
<p>이 글에서는 IAM 사용자의 계정 정보가 유출되더라도 주로 사용하는 리전만 접근할 수 있도록 제한하여 불필요한 리전에 AWS 리소스가 나도 모르게 생성되지 않도록 방지하는 대책을 설정할 수 있는 방법을 알려드립니다.</p>
<h2 id="AWS-IAM"><a href="#AWS-IAM" class="headerlink" title="AWS IAM"></a>AWS IAM</h2><p>IAM(Identity and Access Management)은 사용자의 신원을 확인하거나 리소스에 대한 액세스 권한을 통합적으로 관리하는 기능을 말합니다. AWS IAM도 마찬가지로 조직을 구성하거나 장기 또는 임시적으로 AWS 리소스 권한을 부여하는 기능을 제공합니다.</p>
<h3 id="IAM-사용자"><a href="#IAM-사용자" class="headerlink" title="IAM 사용자"></a>IAM 사용자</h3><p>AWS IAM의 사용자는 AWS 리소스에 대한 장기적인 권한을 가지도록 구성하는 장기 자격 증명입니다. </p>
<p>먼저, 테스트를 위한 IAM 사용자인 pika를 만들겠습니다. pika는 <strong>모든 권한을 가지는 직무 정책인 AdminisratorAccess</strong>를 가진다고 가정하겠습니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-01.png"></p>
<p>pika는 AWS에서 기본적으로 제공하는 관리형 정책인 AdministratorAccess와 IAMUserChangePassword을 가지게 되었습니다.</p>
<p>그러면 pika 사용자의 비밀번호가 유출되어 누군가가 AWS 콘솔에 접속할 수 있게 된다면 수 많은 리전에 VPC를 생성하거나 EC2 인스턴스를 실행할 수 있는 상태가 됩니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-02.png"></p>
<h3 id="IAM-사용자-리전-제한"><a href="#IAM-사용자-리전-제한" class="headerlink" title="IAM 사용자 리전 제한"></a>IAM 사용자 리전 제한</h3><p>만약 pika라는 사용자가 애플리케이션을 운영하기 위한 구성을 서울(ap-northeast-2) 리전에서만 사용한다고 가정해본다면 다른 리전에 대한 권한을 불필요하게 주고 있는 상태가 됩니다. </p>
<h4 id="aws-RequestedRegion"><a href="#aws-RequestedRegion" class="headerlink" title="aws:RequestedRegion"></a>aws:RequestedRegion</h4><p>IAM 정책을 정의할 때 aws:RequestedRegion는 글로벌 조건 키를 사용하면 특정 리전에 대해서만 권한을 가지도록 제한할 수 있습니다.</p>
<p>만약, 서울 리전만 권한을 부여하고 싶다면 다음과 같이 조건절을 정의하면 됩니다.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Action&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Condition&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;StringEquals&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;aws:RequestedRegion&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;ap-northeast-2&quot;</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>기존에 연결하였던 AdministratorAccess라는 직무 정책을 해제하고 AdministratorAccessOnlySeoul이라는 정책을 만들어서 연결하겠습니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-03.png"></p>
<h3 id="리전-제한-확인"><a href="#리전-제한-확인" class="headerlink" title="리전 제한 확인"></a>리전 제한 확인</h3><p>pika 사용자는 서울 리전에 대한 권한만 가지도록 제한되었기 때문에 정말로 그러한 상태가 되는지 확인해보겠습니다.</p>
<p>연결되지 않은 탄력적 IP는 요금을 지불해야하므로 탄력적 IP를 생성하려고 시도했지만 불가능합니다. </p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-04.png"></p>
<p>EC2 인스턴스를 생성하기 위해서 서울 리전에서 사용가능한 AMI 유형을 조회할 수 없기 때문에 진행할 수 없습니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-05.png"></p>
<p>도쿄 리전에 대한 페이지는 접속할 수 있지만 AWS 리소스를 생성하는 것은 동일하게 AWS API를 사용하기 때문에 서울 리전외에는 권한 오류가 발생하게 됩니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-06.png"></p>
<p>심지어는 글로벌 리전 서비스인 S3에서도 권한 오류가 발생합니다. 이는 S3 서비스로 이동할 때 현재 리전 파라미터를 전달하기 때문인데 서울 리전으로 변경하거나 제거하시면 됩니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-07.png"></p>
<h3 id="경계-설정으로-리전-제한"><a href="#경계-설정으로-리전-제한" class="headerlink" title="경계 설정으로 리전 제한"></a>경계 설정으로 리전 제한</h3><p>앞서 pika 사용자는 AdministratorAccess라는 직무 정책과 동일하게 모든 권한을 가지는 AdministratorAccessOnlySeoul이라는 정책을 만들어서 연결하여 제한하였습니다. 그러나 사용자마다 부여된 권한이 다를 수 있기 때문에 매번 리전을 제한하는 정책을 만들어서 연결하기에는 불편함이 있습니다. 이 경우에는 정책을 권한 경계(Permissions boundary)로 설정하면 모든 사용자마다 부여된 정책에 대하여 리전을 제한할 수 있습니다.</p>
<h4 id="특정-서비스에-대한-권한을-가진-사용자"><a href="#특정-서비스에-대한-권한을-가진-사용자" class="headerlink" title="특정 서비스에 대한 권한을 가진 사용자"></a>특정 서비스에 대한 권한을 가진 사용자</h4><p>제가 사용하는 mambo라는 사용자는 VPC, EC2, S3에 대한 모든 권한을 가지도록 정책을 연결하였습니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-08.png"></p>
<h4 id="서울-리전을-경계로-제한"><a href="#서울-리전을-경계로-제한" class="headerlink" title="서울 리전을 경계로 제한"></a>서울 리전을 경계로 제한</h4><p>이전과 동일하게 서울 리전만을 사용할 수 있도록 제한하기 위해 정책을 만들어서 권한 경계로 설정하겠습니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-09.png"></p>
<p>mambo 사용자는 RDS에 대한 권한이 없기 때문에 서울 리전에서도 RDS를 사용하여 데이터베이스를 생성할 수 없습니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-10.png"></p>
<p>EC2 서비스에 대한 권한을 가지고 있지만 경계 설정으로 인하여 서울 리전이 아니면 권한이 없게 됩니다.</p>
<p><img data-src="/images/posts/limit-region-aws-iam-user/aws-iam-user-11.png"></p>
<h4 id="글로벌-서비스-리전"><a href="#글로벌-서비스-리전" class="headerlink" title="글로벌 서비스 리전"></a>글로벌 서비스 리전</h4><p>CloudFront, Route53, IAM과 같은 글로벌 서비스는 미국 동부 (us-east-1) 리전의 엔드포인트를 사용하기 때문에 이에 대한 권한을 별도로 설정하여야합니다.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Action&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;cloudfront:*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;route53:*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;iam:*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;support:*&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;Resource&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Condition&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;StringEquals&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;aws:RequestedRegion&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;us-east-1&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="끝마치며"><a href="#끝마치며" class="headerlink" title="끝마치며"></a>끝마치며</h2><p>IAM 사용자가 사용할 수 있는 리전을 제한함으로써 비록 계정 정보가 유출되더라도 서울 리전에서만 AWS 리소스를 마음대로 생성할 수 있도록 방지할 수 있게 되었습니다. 이 방법을 적용하더라도 IAM 사용자의 비밀번호와 액세스 키는 주기적으로 갱신하는 것은 반드시 필요합니다.</p>
<p>감사합니다.</p>
]]></content>
  </entry>
  <entry>
    <title>도커 데스크탑이 사용하는 WSL 리소스 제한하기</title>
    <url>/limit-resources-docker-desktop-using-wslconfig/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다. </p>
<p>오늘은 <strong>윈도우 환경의 도커 데스크탑에서 사용하는 WSL 리소스를 제한하는 방법</strong>에 대하여 공유하고자 합니다. 윈도우에서 도커 데스크탑을 사용할 때 컴퓨터가 느려진다는 느낌을 받고있다면 현재 도커 데스크탑과 WSL에 의해 점유되는 메모리를 확인하시고 이 글에서 소개하는 방법으로 WSL가 점유하는 리소스를 제한하시는게 좋습니다.</p>
<h2 id="Docker-Desktop-WSL-2"><a href="#Docker-Desktop-WSL-2" class="headerlink" title="Docker Desktop WSL 2"></a>Docker Desktop WSL 2</h2><p>윈도우 10 환경에서 WSL 2를 설치하고 활성화했다면 도커 데스크탑에서 WSL 2를 사용해서 컨테이너를 구동될 수 있도록 지원하고 있습니다. </p>
<p><img data-src="/images/posts/docker-desktop-wsl-config/docker-desktop-wsl-config-01.png"></p>
<blockquote>
<p>Docker Desktop uses the dynamic memory allocation feature in WSL 2 to greatly improve the resource consumption. This means, Docker Desktop only uses the required amount of CPU and memory resources it needs, while enabling CPU and memory-intensive tasks such as building a container to run much faster.</p>
</blockquote>
<p>도커 데스크탑 공식 문서에서는 WSL 2을 사용하면 메모리를 동적으로 할당할 수 있고 리소스를 효율적으로 소비한다고 소개합니다. 그런데 실제로 도커를 사용하여 다수의 컨테이너를 실행하다보면 컴퓨터 성능이 점점 느려지는 것을 체감하실 수도 있는 분들도 계실텐데요. 이 문제는 WSL 깃허브에 이슈로 등록되어있는데 WSL가 점유하는 메모리를 제대로 반환하지 못하는 현상인 것 같습니다.</p>
<p><a href="https://github.com/microsoft/WSL/issues/4166">WSL 2 consumes massive amounts of RAM and doesn’t return it</a></p>
<p>이슈가 등록된 날짜는 2019년이지만 아직도 해결되지 않고 오픈된 상태로 남아있는 이슈입니다. 개발자 한분은 <a href="https://github.com/microsoft/WSL/issues/4166#issuecomment-526725261">WSL2 VM이 점유하는 리소스를 제한하는 방법</a>을 사용하여 WSL에서 사용하는 메모리를 제한하라고 해결책을 제시합니다.</p>
<h3 id="WSL-Configuration"><a href="#WSL-Configuration" class="headerlink" title="WSL Configuration"></a>WSL Configuration</h3><p>위에서 소개한 방법은 이미 도커 데스크탑에서도 설정 메뉴에서 소개하고 있는 부분으로 리소스 제한은 윈도우에 의해 관리되므로 CPU, 메모리 등을 제한하기 위해서는 WSL 2의 설정을 수행하라고 합니다.</p>
<p><img data-src="/images/posts/docker-desktop-wsl-config/docker-desktop-wsl-config-02.png"></p>
<h4 id="wslconfig-정의"><a href="#wslconfig-정의" class="headerlink" title=".wslconfig 정의"></a>.wslconfig 정의</h4><p>사용자 폴더 위치에서 .wslconfig 파일을 직접 생성하거나 다음과 같이 윈도우 터미널에서 비쥬얼 스튜디오 코드를 사용하여 생성할 수 있습니다. </p>
<blockquote>
<p>파일을 만들기 위한 파워 쉘 명령어가 별도로 존재하지만 비쥬얼 스튜디오 코드로 여는게 더 편하다고 생각합니다.</p>
</blockquote>
<p><img data-src="/images/posts/docker-desktop-wsl-config/docker-desktop-wsl-config-03.png"></p>
<p>비쥬얼 스튜디오 코드로 열어진 .wslconfig 파일의 내용을 다음과 같이 입력하고 저장합니다.</p>
<figure class="highlight plaintext"><figcaption><span>.wslconfig</span></figcaption><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=4GB</span><br><span class="line">processors=2</span><br><span class="line">swap=0</span><br></pre></td></tr></table></figure>

<h4 id="wslconfig-반영"><a href="#wslconfig-반영" class="headerlink" title=".wslconfig 반영"></a>.wslconfig 반영</h4><p>파일에 정의한 내용을 WSL에 반영하기 위해서는 도커 데스크탑을 종료하고 <strong>PowerShell</strong>을 관리자 권한으로 실행한 다음 <strong>LxssManager</strong>를 다시 실행해야합니다.</p>
<p><img data-src="/images/posts/docker-desktop-wsl-config/docker-desktop-wsl-config-04.png"></p>
<h3 id="비교해보기"><a href="#비교해보기" class="headerlink" title="비교해보기"></a>비교해보기</h3><p>다음은 간단하게 WSL 2의 기본 설정에 의해 동작하는 것과 .wslconfig을 정의해서 WSL 에서 사용할 리소스를 제한하였을 경우를 비교한 내용입니다. 대략적으로 어떤 차이를 보이는지만 확인해주시기 바랍니다.</p>
<h4 id="기본-WSL-2"><a href="#기본-WSL-2" class="headerlink" title="기본 WSL 2"></a>기본 WSL 2</h4><p>먼저, 기본 WSL 2 설정에 의해 도커 데스크탑이 점유하게 되는 리소스를 확인해보죠.</p>
<p><img data-src="/images/posts/docker-desktop-wsl-config/docker-desktop-wsl-config-05.gif"></p>
<p>기다리기 지겨워하실 분들을 위해서 설명하자면 컨테이너를 실행할때마다 메모리가 올라가면서 4GB를 점유한 것을 보여주고 있습니다. 사용하는 만큼 메모리를 점유하는 것은 당연한 부분일 수 있으나 문제는 그 다음부터 발생합니다.</p>
<p><img data-src="/images/posts/docker-desktop-wsl-config/docker-desktop-wsl-config-06.png"></p>
<p>위 화면을 살펴보시면 도커 데스크탑으로 실행했던 컨테이너를 전부 종료하고 이미지 그리고 볼륨을 전부 삭제했음에도 불구하고 <strong>WSL2에서 점유중인 메모리의 일부는 반환되지 않고 있음</strong>을 보여줍니다. </p>
<h4 id="사용자-정의-WSL-2"><a href="#사용자-정의-WSL-2" class="headerlink" title="사용자 정의 WSL 2"></a>사용자 정의 WSL 2</h4><p>이제 WSL 2에서 점유하여 사용할 프로세서를 2개, 메모리를 2GB 그리고 스왑을 하지않도록 설정하고 앞서 컨테이너를 실행했던 것을 다시 시도 해본 결과를 확인해보겠습니다.</p>
<p><img data-src="/images/posts/docker-desktop-wsl-config/docker-desktop-wsl-config-07.gif"></p>
<p>기본 설정때와는 다르게 여러개의 컨테이너를 실행하더라도 WSL2에서 할당하는 메모리는 2GB를 넘지않게 됨을 확인할 수 있습니다. 물론, 점유하고 있는 리소스가 제한되어있기 때문에 컨테이너 성능은 줄어들게 당연한 부분입니다. 따라서, 시스템 자원이 여유롭다면 적당하게 제한하시는 것을 추천합니다.</p>
<h2 id="느려짐을-체감하는-이유"><a href="#느려짐을-체감하는-이유" class="headerlink" title="느려짐을 체감하는 이유"></a>느려짐을 체감하는 이유</h2><p>.wslconfig 파일을 정의하지 않고 기본 설정으로 WSL 2를 사용하고 있을때 도커 데스크탑이 시스템 자원을 어느정도 까지 사용할 수 있을 지 확인해보겠습니다.</p>
<p><img data-src="/images/posts/docker-desktop-wsl-config/docker-desktop-wsl-config-08.png"></p>
<p>기본적으로 <em><strong>프로세서는 전부 사용</strong></em>한다고 하며 메모리는 <strong>총 메모리의 절반 또는 8GB 중 작은쪽으로 설정</strong>됩니다. 저의 경우는 32GB의 메모리이므로 메모리의 절반보다 작은 8GB가 설정되게 됩니다. 일반적으로 개발자가 사용하는 컴퓨터의 메모리 용량 16GB이라면 동일하게 8GB이므로 <strong>무려 총 메모리의 절반이나 점유</strong>할 수 있게 되고 컨테이너를 종료하더라도 일부의 메모리는 점유하고 있을 수 있다는 이야기입니다.</p>
<p>윈도우의 리소스 모니터를 사용해서 vmmem에 할당된 메모리가 높은지 확인해보시기 바라며 이상으로 도커 데스크탑이 사용하는 WSL 리소스 제한하기를 마치겠습니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>WSL</tag>
        <tag>Docker Desktop</tag>
      </tags>
  </entry>
  <entry>
    <title>롬복 어노테이션 프로세서</title>
    <url>/lombok-annotation-processor/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 인텔리제이에서 롬복 라이브러리를 적용하는 방법을 알아가기 위한 내용을 공유하고자 합니다.</p>
<h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p><a href="https://projectlombok.org/">롬복 라이브러리</a>는 자바 프로젝트에서 필수적으로 사용될만큼 편리하고 유용한 기능을 제공합니다. 롬복 라이브러리는 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html">APT(Annotation Processing Tool)</a>를 통해 어노테이션 프로세서(Annotation Processor)로 컴파일 단계에서 수행하게 됩니다. 따라서, 롬복 라이브러리를 사용하기 위해서는 프로젝트에서 어노테이션 프로세서를 동작시키기 위한 설정을 해야합니다.</p>
<h3 id="인텔리제이-어노테이션-프로세서"><a href="#인텔리제이-어노테이션-프로세서" class="headerlink" title="인텔리제이 어노테이션 프로세서"></a>인텔리제이 어노테이션 프로세서</h3><p>인텔리제이에서는 클래스패스에 있는 어노테이션 프로세서를 구성하기 위한 <a href="https://www.jetbrains.com/help/idea/annotation-processors-support.html">어노테이션 프로세싱 기능</a>을 지원합니다. 이 어노테이션 프로세싱 기능이 활성화되면 클래스패스에 있는 어노테이션 프로세서를 자동으로 등록하게 됩니다.</p>
<p><img data-src="/images/posts/lombok-annotation-processor/intellij-annotation-processing.png"></p>
<h4 id="그래들-프로젝트"><a href="#그래들-프로젝트" class="headerlink" title="그래들 프로젝트"></a>그래들 프로젝트</h4><p>인텔리제이는 그래들 프로젝트에 있는 기본 그래들 래퍼를 사용하여 프로젝트를 빌드하고 실행하도록 설정되어있습니다. <strong>Build Tools &gt; Gradle</strong> 메뉴에서 기본 그래들 래퍼가 아닌 인텔리제이 자체로 빌드하고 실행되도록 변경할 수 있습니다. 인텔리제이 자체적으로는 롬복 플러그인을 번들에 포함하고 있으므로 롬복 어노테이션 프로세서가 클래스패스에 위치하기 때문에 어노테이션 프로세싱 기능이 활성화되어있다면 롬복에 대한 어노테이션 프로세서가 자동으로 등록되게 됩니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>인텔리제이는 친절하게도 롬복 라이브러리가 클래스패스에 있지만 어노테이션 프로세싱 기능이 비활성화되어있으면 이벤트 로그에 기능 활성화를 묻는 알림을 제공합니다.</em><br><em>또한, 인텔리제이를 사용하도록 선택한 환경에서는 별다른 설정없이도 클래스패스에 롬복 라이브러리가 있으면 어노테이션 프로세서가 동작함을 확인할 수 있습니다.</em></p>
</blockquote>
<h4 id="그래들-어노테이션-프로세서-구성"><a href="#그래들-어노테이션-프로세서-구성" class="headerlink" title="그래들 어노테이션 프로세서 구성"></a>그래들 어노테이션 프로세서 구성</h4><p>프로젝트의 기본 설정은 프로젝트의 그래들 래퍼로 실행하는 환경이라고 하였습니다. 이 경우에는 롬복 라이브러리에 대한 어노테이션 프로세서를 그래들 구성 파일에 정의해야합니다.</p>
<p><img data-src="/images/posts/lombok-annotation-processor/intellij-gradle-build-and-run.png"></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그래들의 annotationProcessor를 통해 롬복 라이브러리의 어노테이션 프로세서가 어노테이션 프로세서가 위치하는 클래스패스에 등록됨에 따라 인텔리제이는 어노테이션 프로세싱 기능 활성화 여부를 확인하고 활성화에 대한 알림을 제공합니다. </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">   compileOnly &#123;</span><br><span class="line">       extendsFrom annotationProcessor</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그래들 기반의 스프링 부트 프로젝트를 시작할 때 롬복을 추가하면 위 구문이 포함되는 것을 확인하실 수 있습니다. 이 구문의 역할이 무엇인지 궁금하지 않으신가요? 인텔리제이는 그래들 설정 팡리에 위 구문이 포함되는 경우 <code>Gradle Imported</code>라는 이름의 프로파일로써 롬복 라이브러리를 어노테이션 프로세서로 등록하기 위한 어노테이션 프로세싱 기능을 활성화하는 것을 자동으로 구성하게 됩니다.</p>
<p><img data-src="/images/posts/lombok-annotation-processor/intellij-lombok-annotation-processing-extends-from.png"></p>
<blockquote>
<p><em>인텔리제이는 기본 프로파일에 대해 어노테이션 프로세싱 기능이 활성화되어있지 않으면 이벤트 로그를 통해 롬복을 위한 어노테이션 프로세싱 기능 활성화를 안내하는 것 같습니다.</em></p>
</blockquote>
<h3 id="롬복-어노테이션-프로세서"><a href="#롬복-어노테이션-프로세서" class="headerlink" title="롬복 어노테이션 프로세서"></a>롬복 어노테이션 프로세서</h3><p>다시 내용을 정리해보자면, 롬복 라이브러리를 적용하기 위해서는 롬복 라이브러리의 어노테이션 프로세서를 등록하기 위한 설정을 수행해야합니다.</p>
<ul>
<li>인텔리제이 어노테이션 프로세싱 활성화(Enable annotation processing)</li>
<li>그래들 어노테이션 프로세서 구성</li>
</ul>
<h4 id="그래들-어노테이션-프로세서-구성-1"><a href="#그래들-어노테이션-프로세서-구성-1" class="headerlink" title="그래들 어노테이션 프로세서 구성"></a>그래들 어노테이션 프로세서 구성</h4><p>인텔리제이를 사용하는 개발 환경에서는 인텔리제이 어노테이션 프로세싱 활성화 기능을 통해 클래스패스에 있는 어노테이션 프로세서를 자동으로 등록할 수 있습니다만, 젠킨스와 같은 빌드 환경에서 그래들로 어노테이션 프로세서를 등록하기 위해서는 이를 위한 구성을 해야합니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    compileOnly &#123;</span><br><span class="line">        extendsFrom annotationProcessor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">    testCompileOnly <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">    testAnnotationProcessor <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 위 구성은 간단하게 <strong>그래들 롬복 플러그인</strong> 으로 대체할 수 있는데 빌드 도구의 플러그인을 사용하는 것은 공식 홈페이지에서도 추천하는 방식입니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">   id <span class="string">&quot;io.freefair.lombok&quot;</span> version <span class="string">&quot;6.3.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>IntelliJ</tag>
        <tag>Lombok</tag>
        <tag>Annotation Processor</tag>
      </tags>
  </entry>
  <entry>
    <title>리눅스에서 프로세스 실행 유지하기</title>
    <url>/maintaining-process-execution-in-linux/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>서버에서 실행중인 애플리케이션은 언제든지 <strong>예기치 않은 상황</strong>으로 중단될 수 있습니다. 예를 들어, 일시적으로 전력이 차단되어 서버 장비가 다시 시작되거나 애플리케이션 프로세스가 서버 자원을 많이 사용해서 프로세스가 중단되는 상황이 발생할 수 있습니다. </p>
<p>그래서 오늘 알아볼 내용은 리눅스에서 예기치 않은 상황으로 인하여 프로세스가 중단되었을 경우 자동으로 프로세스를 다시 실행시킴으로써 프로세스 실행 상태를 유지하기 위한 방법입니다.</p>
<h2 id="프로세스-실행-유지"><a href="#프로세스-실행-유지" class="headerlink" title="프로세스 실행 유지"></a>프로세스 실행 유지</h2><p>먼저, 스프링 부트 애플리케이션을 다음과 같이 실행할 수 있다고 가정 하겠습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nohup java -jar -Xmx500m demo.war 1&gt; app.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="comment"># [1] 227</span></span><br><span class="line"></span><br><span class="line">ls -l</span><br><span class="line"><span class="comment"># total 21M</span></span><br><span class="line"><span class="comment"># -rw-r--r-- 1 ec2-user ec2-user 2.0K Oct  8 15:19 app.log</span></span><br><span class="line"><span class="comment"># -rw-r--r-- 1 ec2-user ec2-user    3 Oct  8 15:19 app.pid</span></span><br><span class="line"><span class="comment"># -rwxr-xr-x 1 ec2-user ec2-user  20M Oct  8 12:28 demo.war*</span></span><br><span class="line"></span><br><span class="line">cat app.pid</span><br><span class="line"><span class="comment"># 227</span></span><br></pre></td></tr></table></figure>

<p>위 예시에서 nohup 명령어를 사용하고 출력된 프로세스 아이디와 스프링 부트 애플리케이션에서 ApplicationPidWriter에 의해 생성된 프로세스 아이디 파일이 동일한 것을 확인할 수 있습니다.</p>
<h3 id="프로세스-아이디-확인하기"><a href="#프로세스-아이디-확인하기" class="headerlink" title="프로세스 아이디 확인하기"></a>프로세스 아이디 확인하기</h3><p>앞서 스프링 부트 애플리케이션처럼 애플리케이션 자체적으로 현재 실행중인 프로세스 아이디를 저장할 수 있는 기능을 포함하고 있다면 좋겠지만 그렇지 않을 수 있습니다. 그래서 이미 실행중인 프로세스 아이디를 확인하고 가져올 수 있는 방법을 알아야 합니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo $!</span></span><br><span class="line">nohup java -jar -Xmx500m demo.war 1&gt; app.log 2&gt;&amp;1 &amp; <span class="built_in">echo</span> $! &gt; app.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># JPS(JVM Process Status)</span></span><br><span class="line">jps -v | grep war | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps -ef</span></span><br><span class="line">ps -ef | grep java | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># netstat -tnlp</span></span><br><span class="line">netstat -tnlp | grep java | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span> | awk -F <span class="string">&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pgrep</span></span><br><span class="line">pgrep java</span><br></pre></td></tr></table></figure>

<p>첫번째 방식에 사용된 <strong>echo $!</strong> 는 마지막으로 백그라운드에서 실행된 명령어에 대한 PID값을 출력할 수 있는 명령어입니다.</p>
<h3 id="Crontab으로-프로세스-유지하기"><a href="#Crontab으로-프로세스-유지하기" class="headerlink" title="Crontab으로 프로세스 유지하기"></a>Crontab으로 프로세스 유지하기</h3><p>일반적으로 사용되는 고전적인 방식은 앞서 다양한 방식으로 추출된 프로세스 아이디에 대한 프로세스 실행 상태를 체크하는 스크립트를 Crontab을 통해 주기적으로 실행하는 것입니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">PID_FILE=<span class="string">&quot;app.pid&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">autorun</span></span> () &#123;</span><br><span class="line">  <span class="comment"># ... &amp; echo $! &gt; app.pid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$PID_FILE</span>&quot;</span> ] &amp;&amp; [ ! -z `cat <span class="string">&quot;<span class="variable">$PID_FILE</span>&quot;</span>` ]; <span class="keyword">then</span></span><br><span class="line">  PID=$(cat <span class="variable">$PID_FILE</span>)</span><br><span class="line">  <span class="keyword">if</span> ps -p <span class="variable">$PID</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PID_FILE</span>(<span class="variable">$PID</span>) is running&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    autorun</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  autorun</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="SystemD"><a href="#SystemD" class="headerlink" title="SystemD"></a>SystemD</h3><p>더 효율적인 방식은 Nginx와 같은 패키지를 APT 또는 YUM으로 설치할 때 SystemD 서비스에 자동으로 등록하는 것처럼  애플리케이션을 실행하는 명령어 또는 스크립트를 SystemD 서비스로 등록하는 것입니다. </p>
<p><strong>/etc/systemd/system/demo.service</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Demo</span><br><span class="line">After=syslog.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=ec2-user</span><br><span class="line">WorkingDirectory=/home/ec2-user</span><br><span class="line">ExecStart=/usr/bin/java -jar -Xmx500m demo.war</span><br><span class="line">ExecStop=kill -9 `cat app.pid`</span><br><span class="line">SuccessExitStatus=143</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>위와 같이 스크립트를 정의했다면 다음과 같이 서버가 실행될 때 서비스가 시작되도록 활성화하거나 직접 서비스를 실행하고 종료할 수 있습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> demo.service</span><br><span class="line">sudo systemctl start demo.service</span><br></pre></td></tr></table></figure>

<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>XML로 다국어 메시지 관리하기</title>
    <url>/managing-i18n-messages-with-xml/</url>
    <content><![CDATA[<blockquote>
<p>본 글은 <a href="/spring-validation">벨리데이션 오류 메시지가 사용자 언어로 처리되지 않은 이유</a>를 작성하면서 보완되었습니다.</p>
</blockquote>
<h2 id="다국어-메시지"><a href="#다국어-메시지" class="headerlink" title="다국어 메시지"></a>다국어 메시지</h2><p>스프링이나 스프링 부트에서 다국어 메시지를 적용하기 위해서는 Properties를 기본으로 사용해야합니다. 그러나, messages-en.properties 또는 messages-ko.properties와 같이 언어별로 프로퍼티 파일을 구분하여 메시지를 관리해야만 합니다. 이처럼 프로퍼티 파일로 메시지를 관리하다보면 해당 언어에서 특정 메시지를 키를 사용했는지 파악하는게 상당히 어렵습니다. 현재 조직처럼 회사 내 프로젝트를 진행할 때 메시지 키에 대해 정의된 문서가 없는 경우에는 개발자가 메시지 코드를 관리해야하므로 매번 검색해서 사용하고 있는지 파악해야만 합니다.</p>
<h3 id="대안-방식"><a href="#대안-방식" class="headerlink" title="대안 방식"></a>대안 방식</h3><p>프로퍼티 파일로 다국어 메시지를 관리하는 것을 보완하기 위한 방법은 다양합니다.</p>
<h4 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h4><p>애플리케이션 프로퍼티 파일을 야믈(Yaml) 파일로 대체하는 것처럼 YAML 파일을 사용해서 다국어 메시지를 관리하는 방법은 <a href="https://jmlim.github.io/spring/2018/11/28/spring-boot-Internationalization/">기억하기 위한 개발노트:스프링부트에서 다국어 기능 사용하기</a>를 통해 확인할 수 있습니다. 그러나 이 방식은 파일만 대체할 뿐 메시지를 관리하기 위한 YAML 파일은 언어별로 만들어야함으로 프로퍼티의 문제점을 동일하게 가지고 있습니다.</p>
<blockquote>
<p>ISO-8859-1 인코딩 형식으로 저장되는 프로퍼티와는 다르게 한글이 유니코드로 표시되지 않는다는 장점은 존재합니다.</p>
</blockquote>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>현재 조직에서는 프로젝트에서 사용하는 다국어 메시지를 XML 파일로 구성하여 관리하고 있습니다. 다음은 다국어 메시지를 관리하기 위한 XML 파일의 간단한 예시입니다.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">messages</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;btn.signIn&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ko_KR</span>&gt;</span>&lt;![CDATA[로그인]]&gt;<span class="tag">&lt;/<span class="name">ko_KR</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">en_US</span>&gt;</span>&lt;![CDATA[Login]]&gt;<span class="tag">&lt;/<span class="name">en_US</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">messages</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="커스텀-리소스-번들"><a href="#커스텀-리소스-번들" class="headerlink" title="커스텀 리소스 번들"></a>커스텀 리소스 번들</h3><p>프로퍼티 파일 대신에 XML로 메시지 소스를 만들기 위해서는 리소스 번들부터 만들어야합니다. ResourceBundle 클래스의 getBundle 함수를 사용해서 XML 파일을 읽어 리소스 번들로 변환할 수 있습니다. 리소스 번들로 메시지 소스를 만드는 구조는 <a href="https://firstboos.tistory.com/entry/XML-%EA%B8%B0%EB%B0%98%EC%9D%98-Resource-Bundle-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">XML 기반의 Resource Bundle, PropertyPlaceHolder 사용하기</a>에서 확인할 수 있습니다.</p>
<h4 id="XmlResourceBundle"><a href="#XmlResourceBundle" class="headerlink" title="XmlResourceBundle"></a>XmlResourceBundle</h4><p>그러나 앞서 알아본 다국어 메시지에 대한 XML 파일은 프로퍼티 구조를 따르지 않습니다. 그래서 <strong>Properties.loadFromXML</strong> 함수를 통해 XML을 프로퍼티 기준으로 읽으면 안됩니다. 다음처럼 XML 구성에 따라서 메시지 정보를 만들어야합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlResourceBundle</span> <span class="keyword">extends</span> <span class="title">ResourceBundle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Map&lt;String, String&gt;&gt; messages;</span><br><span class="line">    <span class="keyword">private</span> Locale i18n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlResourceBundle</span><span class="params">(InputStream is, Locale i18n)</span> <span class="keyword">throws</span> IOException, ParserConfigurationException, SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (is) &#123;</span><br><span class="line">            <span class="keyword">this</span>.i18n = i18n;</span><br><span class="line">            messages = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line">            Document doc = builder.parse(is);</span><br><span class="line">            doc.getDocumentElement().normalize();</span><br><span class="line"></span><br><span class="line">            NodeList entries = doc.getElementsByTagName(<span class="string">&quot;entry&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.getLength(); i++) &#123;</span><br><span class="line">                Element entry = (Element) entries.item(i);</span><br><span class="line">                String key = entry.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">                NodeList childNodes = entry.getChildNodes();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childNodes.getLength(); j++) &#123;</span><br><span class="line">                    Node n = childNodes.item(j);</span><br><span class="line">                    <span class="keyword">if</span> (n.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                        String locale = n.getNodeName();</span><br><span class="line">                        String message = n.getTextContent();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!messages.containsKey(locale)) &#123;</span><br><span class="line">                            messages.put(locale, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        messages.get(locale).put(key, message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">handleGetObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messages.get(i18n).get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; handleKeys = messages.keySet();</span><br><span class="line">        <span class="keyword">return</span> Collections.enumeration(handleKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i18n = locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Map&lt;String, String&gt;&gt; getMessages() &#123;</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getMessages</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messages.get(locale.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>기존의 handleGetObject 함수는 키 파라미터만 받도록 되어있기 때문에 메시지를 가져올 경우에 언어를 지정할 수 없으므로 리소스 번들을 생성하는 시점에 언어를 지정할 수 있게 하였습니다.</p>
</blockquote>
<h4 id="XmlResourceBundleLoader"><a href="#XmlResourceBundleLoader" class="headerlink" title="XmlResourceBundleLoader"></a>XmlResourceBundleLoader</h4><p>XmlResourceBundle를 로드하기 위한 클래스를 만들기 위해서 <a href="http://www.java2s.com/Tutorial/Java/0220__I18N/XMLresourcebundle.htm">The Strings.xml Resource Bundle</a>을 참고하여 코드를 작성합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlResourceBundleLoader</span> <span class="keyword">extends</span> <span class="title">ResourceBundle</span>.<span class="title">Control</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; formats = Collections.singletonList(<span class="string">&quot;xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getFormats</span><span class="params">(String baseName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> formats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceBundle <span class="title">newBundle</span><span class="params">(String baseName, Locale locale, String format, ClassLoader loader, <span class="keyword">boolean</span> reload)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        ResourceBundle resourceBundle = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String bundleName = toBundleName(baseName, locale);</span><br><span class="line">        String resourceName = toResourceName(bundleName, format);</span><br><span class="line"></span><br><span class="line">        URL url = loader.getResource(resourceName);</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        URLConnection connection = url.openConnection();</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reload) &#123;</span><br><span class="line">            connection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        InputStream stream = connection.getInputStream();</span><br><span class="line">        <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(stream)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (locale == Locale.ROOT) &#123;</span><br><span class="line">                locale = Locale.getDefault();</span><br><span class="line">            &#125;</span><br><span class="line">            resourceBundle = <span class="keyword">new</span> XmlResourceBundle(bis, locale);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXException | ParserConfigurationException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resourceBundle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="메시지-소스"><a href="#메시지-소스" class="headerlink" title="메시지 소스"></a>메시지 소스</h3><p>준비된 리소스 번들을 사용하기 위해서 메시지 소스로 변환해야합니다. 사용자 정의 메시지 소스를 만들기 위해서는 <strong>AbstractMessageSource</strong>를 상속하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.i18n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.NoSuchMessageException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.i18n.LocaleContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.AbstractMessageSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractMessageSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;String, MessageFormat&gt;&gt; formats = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Map&lt;String, String&gt;&gt; messages = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            load();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="string">&quot;messages&quot;</span>, Locale.ROOT, <span class="keyword">new</span> XmlResourceBundleLoader());</span><br><span class="line"></span><br><span class="line">        XmlResourceBundle xmlResourceBundle = (XmlResourceBundle) resourceBundle;</span><br><span class="line">        <span class="keyword">this</span>.messages = xmlResourceBundle.getMessages();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메시지 소스에서 지원하는 언어 목록</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getLocales</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(messages.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MessageFormat <span class="title">resolveCode</span><span class="params">(String code, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (formats) &#123;</span><br><span class="line">            <span class="comment">// 언어 포맷이 없을 경우 메시지 포맷을 새로 생성</span></span><br><span class="line">            <span class="keyword">if</span> (!formats.containsKey(locale.toString())) &#123;</span><br><span class="line">                formats.put(locale.toString(), <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, MessageFormat&gt; map = formats.get(locale.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 언어 포맷에 메시지 코드가 없으면 메시지 정보를 통해 포맷을 저장</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(code)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!messages.containsKey(locale.toString())) &#123;</span><br><span class="line">                    locale = Locale.getDefault();</span><br><span class="line">                &#125;</span><br><span class="line">                Map&lt;String, String&gt; msgs = messages.get(locale.toString());</span><br><span class="line">                map.put(code, <span class="keyword">new</span> MessageFormat(msgs.getOrDefault(code, code), locale));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map.get(code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getMessage(code, <span class="keyword">new</span> Object[<span class="number">0</span>], LocaleContextHolder.getLocale());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMessageException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String code, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getMessage(code, args, LocaleContextHolder.getLocale());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMessageException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String code, Object[] args, String defaultMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getMessage(code, args, defaultMessage, LocaleContextHolder.getLocale());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMessageException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String code, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getMessage(code, <span class="keyword">new</span> Object[<span class="number">0</span>], locale);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMessageException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="메시지-소스-갱신"><a href="#메시지-소스-갱신" class="headerlink" title="메시지 소스 갱신"></a>메시지 소스 갱신</h4><p>로컬 환경에서 애플리케이션을 개발하는 동안에는 메시지 소스 정보가 계속 변경되어야하는 요구사항이 있습니다. 스프링 부트를 사용하고 있다면 <strong>spring-boot-devtool</strong>을 사용해서 애플리케이션이 다시 실행할 수 있게 변경할 수 있습니다. 그러나, 메시지 정보가 변경되는 것이 애플리케이션 자체에 특별한 영향을 미치지는 않습니다. 애플리케이션을 다시 실행하지 않고 변경된 메시지 정보를 반영할 수 있도록 하는 것이 좋습니다.</p>
<blockquote>
<p>우리가 구현해야할 동작은 ReloadableResourceBundleMessageSource가 변경된 프로퍼티 파일을 다시 로드하는 것과 비슷합니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractMessageSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomMessageSource</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            load();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ArrayUtils.contains(environment.getActiveProfiles(), <span class="string">&quot;production&quot;</span>)) &#123;</span><br><span class="line">            reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                File file = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;messages.xml&quot;</span>).getFile();</span><br><span class="line">                <span class="keyword">long</span> lastModified = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lastModified &lt; file.lastModified()) &#123;</span><br><span class="line">                            load();</span><br><span class="line">                            log.info(<span class="string">&quot;Reload MessageSource - &#123;&#125;&quot;</span>, System.currentTimeMillis());</span><br><span class="line">                            lastModified = file.lastModified();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(e.getMessage());</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedException) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>위 처럼 파일 수정일을 비교하지 않아도 <a href="https://www.baeldung.com/java-nio2-watchservice">자바 7의 WatchService를 활용</a>해도 파일을 감시할 수 있습니다.</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li>  <a href="https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html">Installing a Custom Resource Bundle as an Extension</a></li>
<li>  <a href="http://www.java2s.com/Tutorial/Java/0220__I18N/XMLresourcebundle.htm">XML resource bundle</a></li>
<li>  <a href="https://firstboos.tistory.com/entry/XML-%EA%B8%B0%EB%B0%98%EC%9D%98-Resource-Bundle-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">XML 기반의 Resource Bundle, PropertyPlaceHolder 사용하기</a></li>
<li>  <a href="http://www.fun25.co.kr/blog/java-xml-parser-example-documentbuilder">[자바] XML 파싱 예제 - DocumentBuilder</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>특정 디펜던시에 대한 Dart Sass의 Deprecation 경고 제외하기</title>
    <url>/no-emit-deprecation-warnings-of-dart-sass/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 특정 디펜던시에 대한 Dart Sass의 Deprecation 경고를 제외하는 방법에 대해서 공유하려고 합니다.</p>
<h2 id="Deprecation-Warnings"><a href="#Deprecation-Warnings" class="headerlink" title="Deprecation Warnings"></a>Deprecation Warnings</h2><p>최신 웹팩에서 사용하는 sass-loader에서는 sass(Dart Sass)를 사용하는 것을 권장합니다. 다만, Dart Sass 버전에 따라 다음과 같이 Dart Sass 2.0에서부터 지원되지 않는 문법에 대한 경고 로그가 출력될 수 있습니다.</p>
<p><em>Deprecation Using / for division outside of calc() is deprecated and will be removed in Dart Sass 2.0.0</em></p>
<h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>부트스트랩의 변수를 오버라이딩하여 테마를 구성하고자 하는 경우 여러분의 SCSS 파일에서 부트스트랩에서 제공하는 SCSS 파일을 불러오게되면 아래처럼 경고 로그가 출력될 수 있습니다.</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">LOG from ./node_modules/sass<span class="literal">-loader</span>/dist/cjs.js sass<span class="literal">-loader</span> ./node_modules/css<span class="literal">-loader</span>/dist/cjs.js??clonedRule<span class="built_in">Set-2</span>[<span class="number">0</span>].rules[<span class="number">0</span>].use[<span class="number">1</span>]!./node_modules/postcss<span class="literal">-loader</span>/dist/cjs.js!./node_modules/<span class="built_in">resolve-url</span><span class="literal">-loader</span>/index.js!./node_modules/sass<span class="literal">-loader</span>/dist/cjs.js??clonedRule<span class="built_in">Set-2</span>[<span class="number">0</span>].rules[<span class="number">0</span>].use[<span class="number">4</span>]!./src/scss/bootstrap.scss</span><br><span class="line">&lt;w&gt; Deprecation <span class="keyword">Using</span> / for division outside of calc() is deprecated and will be removed in Dart Sass 2.0.0.</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Recommendation: math.div(<span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-lg</span>, <span class="number">2</span>) or calc(<span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-lg</span> / <span class="number">2</span>)</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; More info and automated migrator: https://sass<span class="literal">-lang</span>.com/d/slash<span class="literal">-div</span></span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\_variables.scss <span class="number">33</span>:<span class="number">46</span>  @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\index.scss <span class="number">7</span>:<span class="number">9</span>         @import</span><br><span class="line">&lt;w&gt; src\scss\bootstrap.scss <span class="number">11</span>:<span class="number">9</span>                          root stylesheet</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Deprecation <span class="keyword">Using</span> / for division outside of calc() is deprecated and will be removed in Dart Sass 2.0.0.</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Recommendation: math.div(<span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-sm</span>, <span class="number">2</span>) or calc(<span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-sm</span> / <span class="number">2</span>)</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; More info and automated migrator: https://sass<span class="literal">-lang</span>.com/d/slash<span class="literal">-div</span></span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\_variables.scss <span class="number">34</span>:<span class="number">46</span>  @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\index.scss <span class="number">7</span>:<span class="number">9</span>         @import</span><br><span class="line">&lt;w&gt; src\scss\bootstrap.scss <span class="number">11</span>:<span class="number">9</span>                          root stylesheet</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Deprecation <span class="keyword">Using</span> / for division outside of calc() is deprecated and will be removed in Dart Sass 2.0.0.</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Recommendation: math.div(<span class="variable">$font</span><span class="literal">-size</span><span class="literal">-lg</span> * <span class="variable">$line</span><span class="literal">-height</span><span class="literal">-lg</span> - <span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-lg</span>, <span class="number">2</span>) or calc((<span class="variable">$font</span><span class="literal">-size</span><span class="literal">-lg</span> * <span class="variable">$line</span><span class="literal">-height</span><span class="literal">-lg</span> - <span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-lg</span>) / <span class="number">2</span>)</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; More info and automated migrator: https://sass<span class="literal">-lang</span>.com/d/slash<span class="literal">-div</span></span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\form<span class="literal">-checkbox</span>\_form<span class="literal">-checkbox</span>.scss <span class="number">10</span>:<span class="number">10</span>  @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\form<span class="literal">-checkbox</span>\index.scss <span class="number">1</span>:<span class="number">9</span>             @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\index.scss <span class="number">5</span>:<span class="number">9</span>                           @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\index.scss <span class="number">14</span>:<span class="number">9</span>                                     @import</span><br><span class="line">&lt;w&gt; src\scss\bootstrap.scss <span class="number">11</span>:<span class="number">9</span>                                                       root stylesheet</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Deprecation <span class="keyword">Using</span> / for division outside of calc() is deprecated and will be removed in Dart Sass 2.0.0.</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Recommendation: math.div(<span class="variable">$font</span><span class="literal">-size</span><span class="literal">-lg</span> * <span class="variable">$line</span><span class="literal">-height</span><span class="literal">-lg</span> - <span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-lg</span>, <span class="number">2</span>) or calc((<span class="variable">$font</span><span class="literal">-size</span><span class="literal">-lg</span> * <span class="variable">$line</span><span class="literal">-height</span><span class="literal">-lg</span> - <span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-lg</span>) / <span class="number">2</span>)</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; More info and automated migrator: https://sass<span class="literal">-lang</span>.com/d/slash<span class="literal">-div</span></span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\form<span class="literal">-checkbox</span>\_form<span class="literal">-checkbox</span>.scss <span class="number">18</span>:<span class="number">10</span>  @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\form<span class="literal">-checkbox</span>\index.scss <span class="number">1</span>:<span class="number">9</span>             @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\index.scss <span class="number">5</span>:<span class="number">9</span>                           @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\index.scss <span class="number">14</span>:<span class="number">9</span>                                     @import</span><br><span class="line">&lt;w&gt; src\scss\bootstrap.scss <span class="number">11</span>:<span class="number">9</span>                                                       root stylesheet</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Deprecation <span class="keyword">Using</span> / for division outside of calc() is deprecated and will be removed in Dart Sass 2.0.0.</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; Recommendation: math.div(<span class="variable">$font</span><span class="literal">-size</span><span class="literal">-sm</span> * <span class="variable">$line</span><span class="literal">-height</span><span class="literal">-sm</span> - <span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-sm</span>, <span class="number">2</span>) or calc((<span class="variable">$font</span><span class="literal">-size</span><span class="literal">-sm</span> * <span class="variable">$line</span><span class="literal">-height</span><span class="literal">-sm</span> - <span class="variable">$b</span><span class="literal">-custom</span><span class="literal">-control</span><span class="literal">-indicator</span><span class="literal">-size</span><span class="literal">-sm</span>) / <span class="number">2</span>)</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; More info and automated migrator: https://sass<span class="literal">-lang</span>.com/d/slash<span class="literal">-div</span></span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\form<span class="literal">-checkbox</span>\_form<span class="literal">-checkbox</span>.scss <span class="number">33</span>:<span class="number">10</span>  @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\form<span class="literal">-checkbox</span>\index.scss <span class="number">1</span>:<span class="number">9</span>             @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\components\index.scss <span class="number">5</span>:<span class="number">9</span>                           @import</span><br><span class="line">&lt;w&gt; node_modules\bootstrap<span class="literal">-vue</span>\src\index.scss <span class="number">14</span>:<span class="number">9</span>                                     @import</span><br><span class="line">&lt;w&gt; src\scss\bootstrap.scss <span class="number">11</span>:<span class="number">9</span>                                                       root stylesheet</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; <span class="number">17</span> repetitive deprecation warnings omitted.</span><br><span class="line">&lt;w&gt;</span><br><span class="line">&lt;w&gt; null</span><br></pre></td></tr></table></figure>

<p>부트스트랩에서 사용중인 문법을 어떻게 바꾸라고 안내하지만 의존성에서 제공하는 파일을 수정할 수는 없습니다. 그래서 위 경고 로그를 출력하지 않게 하는 방법이 필요합니다.</p>
<h3 id="Dart-Sass-quietDeps"><a href="#Dart-Sass-quietDeps" class="headerlink" title="Dart Sass - quietDeps"></a>Dart Sass - quietDeps</h3><p>다행스럽게도 Dart Sass 에서는 <a href="https://sass-lang.com/documentation/cli/dart-sass#quiet-deps">quietDeps</a>옵션을 제공하여 의존성에 대한 Deprecation 경고 출력을 하지 않도록 지원합니다.<br>만약, 웹팩에서 sass-loader를 사용한다면 다음과 같이 <strong>sassOptions</strong> 속성으로 위 옵션을 적용할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;sass-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">sassOptions</span>: &#123;</span><br><span class="line">                <span class="attr">quietDeps</span>: [<span class="string">&quot;node_modules/bootstrap/**/*.scss&quot;</span>],</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>이제 부트스트랩의 SCSS 파일을 임포트하더라도 더이상 경고 로그는 출력되지 않게 되었습니다.<br>감사합니다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://sass-lang.com/documentation/cli/dart-sass#quiet-deps">Dart Sass - quiet-deps</a></li>
</ul>
]]></content>
      <tags>
        <tag>Dart Sass</tag>
        <tag>quietDeps</tag>
      </tags>
  </entry>
  <entry>
    <title>파이썬 도커 이미지 최적화</title>
    <url>/python-docker-image-optimization/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 파이썬 도커 이미지에 대한 최적화에 대해서 알아봅니다. 회사에서 운영중인 서비스의 분석 서버는 파이썬으로 작성된 플래스크 기반의 웹 애플리케이션입니다. 여러가지 방식으로 배포하던 애플리케이션을 Elastic Beanstalk 환경을 통해 배포하는 구조로 통합하기 위해서 파이썬 애플리케이션을 Elastic Beanstalk의 도커 플랫폼으로 전환하기 위한 작업을 진행했습니다. 파이썬 플랫폼이 아닌 도커 플랫폼을 활용하는 이유는 도커 이미지로 구동하는 쿠버네티스 환경을 준비하고 있기 때문으로 동일하게 도커 이미지를 사용하여 애플리케이션을 배포하고자 결정하였습니다.</p>
<h2 id="파이썬-도커-이미지"><a href="#파이썬-도커-이미지" class="headerlink" title="파이썬 도커 이미지"></a>파이썬 도커 이미지</h2><p>파이썬으로 작성된 애플리케이션을 도커 이미지화하는 과정에서 발견한 문제에 대하여 몇가지 개선 작업을 진행한 것을 공유하고자 합니다. </p>
<h3 id="로컬-환경의-Dockerfile"><a href="#로컬-환경의-Dockerfile" class="headerlink" title="로컬 환경의 Dockerfile"></a>로컬 환경의 Dockerfile</h3><p>먼저, 로컬 환경에서 애플리케이션을 구동해보기 위해서 간단하게 작성하여 사용중이던 Dockerfile을 다시 만들어야 했습니다.</p>
<figure class="highlight docker"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./src /www</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /www</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">ENV</span> <span class="keyword">ENV</span> <span class="string">&quot;dev&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> python3 -m venv .venv</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x ./.venv/bin/activate</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ./.venv/bin/activate</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> python3 -m pip install --upgrade pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install Flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> gunicorn main:app -b 0.0.0.0:5000 -w 1 -t=50 -k gevent --preload</span></span><br></pre></td></tr></table></figure>

<p>Dockerfile이 정리되어있지 않고 불필요한 명령어를 수행하는 것도 있지만 제일 크다고 생각한 문제점은 <a href="https://gunicorn.org/">Gunicorn WSGI 서버</a>에 대해 다양한 옵션을 적용하기 힘들다는 점이었습니다. 웹 요청을 애플리케이션 마스터 프로세스에 전달하는 워커 프로세스의 개수를 지정하는 옵션 만큼은 이미지를 빌드하는 시점 이후에도 쉽게 변경할 수 있게 적용하는게 좋을 것 같았습니다.</p>
<figure class="highlight docker"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /app/logs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> PORT=<span class="number">8000</span></span><br><span class="line"><span class="keyword">ARG</span> MAIN=application</span><br><span class="line"><span class="keyword">ARG</span> MAIN_APP=application</span><br><span class="line"><span class="keyword">ARG</span> WORKERS=application</span><br><span class="line"><span class="keyword">ARG</span> WORKERS=<span class="number">2</span></span><br><span class="line"><span class="keyword">ARG</span> WORKERCLASS=gevent</span><br><span class="line"><span class="keyword">ARG</span> TIMEOUT=<span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PORT $&#123;PORT&#125;</span><br><span class="line"><span class="keyword">ENV</span> MAIN $&#123;MAIN&#125;</span><br><span class="line"><span class="keyword">ENV</span> MAIN_APP $&#123;MAIN_APP&#125;</span><br><span class="line"><span class="comment"># This number should generally be between 2-4 workers per core in the server.</span></span><br><span class="line"><span class="keyword">ENV</span> WORKERS $&#123;WORKERS&#125;</span><br><span class="line"><span class="comment"># one of sync, eventlet, gevent, tornado, gthread</span></span><br><span class="line"><span class="keyword">ENV</span> WORKERCLASS $&#123;WORKERCLASS&#125;</span><br><span class="line"><span class="keyword">ENV</span> TIMEOUT $&#123;TIMEOUT&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> entrypoint.sh entrypoint.sh</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src/ .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install gunicorn gevent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> $&#123;PORT&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://docs.gunicorn.org/en/stable/run.html</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;chmod&quot;</span>, <span class="string">&quot;+x&quot;</span>, <span class="string">&quot;./entrypoint.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="string">&quot;./entrypoint.sh&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>다시 작성한 Dockerfile에서는 <strong>ARG 키워드로 빌드 시점에 옵션을 적용</strong>하고 <strong>ENV 키워드를 사용하여 도커 컨테이너를 실행하는 시점</strong>에 환경 변수로 다양한 옵션을 적용할 수 있도록 하였습니다.</p>
<h3 id="터무니없는-빌드된-이미지-크기"><a href="#터무니없는-빌드된-이미지-크기" class="headerlink" title="터무니없는 빌드된 이미지 크기"></a>터무니없는 빌드된 이미지 크기</h3><p>Dockerfile을 다시 작성하면서 꽤 깔끔해졌지만 또 다른 문제가 내재되어있었습니다. 그것은 빌드된 이미지의 크기가 3.7GB라는 터무니 없는 크기를 가지고 있던 것이었습니다. </p>
<p><img data-src="/images/posts/python-docker-image-optimization/python-docker-image-optimization-01.png" alt="3.71GB"></p>
<p>분석 서버를 개발하시는 실장님도 파이썬을 전문으로 하는 개발자가 아니었기 때문에 이러한 이미지 크기가 정상적인 것 같다고 하셨으나 <strong>requirements.txt에 정의된 패키지에 의해 설치된 용량이 무려 2.8GB</strong>인 것을 확인하고 requirements.txt에 <strong>정의된 패키지 중 사용하지 않는 패키지들을 제거</strong>하는 작업을 수행하고보니 <strong>97개의 패키지가 39개로 축소</strong>되었습니다.</p>
<p><img data-src="/images/posts/python-docker-image-optimization/python-docker-image-optimization-02.png" alt="1.28GB"></p>
<p>축소된 requirements.txt에 의해 설치된 패키지의 용량은 2.8GB에서 368MB로 줄어든 것으로 확인되었습니다.</p>
<h3 id="파이썬-기반-이미지-변경"><a href="#파이썬-기반-이미지-변경" class="headerlink" title="파이썬 기반 이미지 변경"></a>파이썬 기반 이미지 변경</h3><p>그럼에도 불구하고 아직 1.28GB라는 상당히 무거운 이미지 사이즈를 가지고 있었습니다. 그 이유는 기본 파이썬 이미지에서 이미 많은 패키지가 설치되기 때문입니다.</p>
<p><img data-src="/images/posts/python-docker-image-optimization/python-docker-image-optimization-03.png"></p>
<p>일반적으로 도커 이미지를 줄이기 위해서 알파인 리눅스 기반으로 만들어진 이미지를 사용하는 것으로 변경합니다. 그런데 알파인 리눅스로 된 파이썬 이미지를 사용하면 <a href="https://jonnung.dev/docker/2020/04/08/optimizing-docker-images/">도커 이미지 잘 만드는 방법</a>에서 확인할 수 있듯이 <strong>빌드 소요시간이 15분 이상 걸리는 현상</strong>을 보였습니다.</p>
<figure class="highlight docker"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim-buster</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash"> gcc libpq-dev</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>결국 알파인 리눅스 기반 이미지 대신에 <code>3.8-slim-buster</code>을 기반의 이미지로 변경하였고 PostgreSQL 모듈을 설치할 때 오류가 발생하여 gcc 와 libpg-dev 패키지를 설치하였습니다.</p>
<p><img data-src="/images/posts/python-docker-image-optimization/python-docker-image-optimization-04.png"></p>
<p><strong>1.28GB의 도커 이미지가 655MB의 용량을 가지는 이미지로 축소</strong>되었습니다. 결과적으로 약 3.14GB의 크기를 줄이게 되었고 <strong>캐시되지 않은 상태에서 약 40초 정도의 시간이 소요됨</strong>을 확인했습니다. </p>
<h3 id="Dockerfile-키워드-순서-변경"><a href="#Dockerfile-키워드-순서-변경" class="headerlink" title="Dockerfile 키워드 순서 변경"></a>Dockerfile 키워드 순서 변경</h3><p><strong>도커 이미지 잘 만드는 방법</strong>을 참고하면 애플리케이션 소스는 패키지를 설치하고나서 복사하는 것이 빌드 시간을 단축한다는 것을 보고 COPY 키워드 순서를 변경하였습니다.</p>
<figure class="highlight docker"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src/requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install gunicorn gevent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> entrypoint.sh entrypoint.sh</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src/ .</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>먼저, requirements.txt을 우선적으로 복사하고 패키지를 설치한 뒤 애플리케이션 실행을 위한 엔트리포인트 스크립트 파일과 애플리케이션 소스 폴더를 복사하도록 변경했습니다.</p>
<h3 id="Gunicorn-설정-개선"><a href="#Gunicorn-설정-개선" class="headerlink" title="Gunicorn 설정 개선"></a>Gunicorn 설정 개선</h3><p>다시 작성한 Dockerfile을 살펴보니 ARG와 ENV 키워드가 많아 쓸데없이 파일이 지저분해보였습니다. ARG와 ENV 키워드들은 용량을 차지하지 않으므로 이미지 크기에 영향을 주지는 않으나 Gunicorn의 여러가지 옵션을 하나의 환경 변수로 지원하도록 추가 개선하였습니다.</p>
<figure class="highlight docker"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim-buster</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash"> gcc libpq-dev</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /app/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build Arguments</span></span><br><span class="line"><span class="keyword">ARG</span> PORT=<span class="number">8000</span></span><br><span class="line"><span class="keyword">ARG</span> MAIN=application</span><br><span class="line"><span class="keyword">ARG</span> MAIN_APP=application</span><br><span class="line"><span class="keyword">ARG</span> GUNICORN_ARGS=--preload</span><br><span class="line"></span><br><span class="line"><span class="comment"># Environoment Variables</span></span><br><span class="line"><span class="keyword">ARG</span> PORT $&#123;PORT&#125;</span><br><span class="line"><span class="keyword">ENV</span> MAIN $&#123;MAIN&#125;</span><br><span class="line"><span class="keyword">ENV</span> MAIN_APP $&#123;MAIN_APP&#125;</span><br><span class="line"><span class="keyword">ENV</span> GUNICORN_ARGS $&#123;GUNICORN_ARGS&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install gunicorn gevent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> gunicorn.conf.py gunicorn.conf.py</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> entrypoint.sh entrypoint.sh</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src/ .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> $&#123;PORT&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://docs.gunicorn.org/en/stable/run.html</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;chmod&quot;</span>, <span class="string">&quot;+x&quot;</span>, <span class="string">&quot;./entrypoint.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="string">&quot;./entrypoint.sh&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>다음과 같이 기본 옵션이 정의된 <strong>gunicorn.conf.py</strong> 파일을 적용하였습니다.</p>
<figure class="highlight py"><figcaption><span>gunicorn.conf.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://docs.gunicorn.org/en/stable/settings.html</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">bind = <span class="string">&#x27;0.0.0.0:8000&#x27;</span></span><br><span class="line">workers = multiprocessing.cpu_count() * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">worker_connections = <span class="number">1000</span></span><br><span class="line">worker_class = <span class="string">&#x27;gevent&#x27;</span></span><br><span class="line">threads = <span class="number">1</span></span><br><span class="line">max_requests = <span class="number">0</span></span><br><span class="line">timeout = <span class="number">30</span></span><br><span class="line">keepalive = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>그리고 기본으로 적용된 옵션을 하나로 통합된 <strong>GUNICORN_ARGS</strong> 환경 변수를 통해 자유롭게 옵션을 재정의하도록 하였습니다.</p>
<p><strong>requirements.txt에 정의된 패키지 정리</strong>하고 <strong>slim-buster 기반의 이미지로 변경</strong> 그리고 <strong>Dockerfile 키워드 순서를 변경</strong>함으로써 파이썬 애플리케이션에 대한 도커 이미지를 최적화하는 것을 알아보았습니다. 결과적으로 도커 이미지 사이즈를 많이 줄이게되어 이미지 용량에 대한 부담과 빌드 및 배포하기까지의 시간을 단축하게되어 다행이라고 생각합니다.</p>
<p>감사합니다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="http://blog.hwahae.co.kr/all/tech/tech-tech/5567/">gunicorn 설정의 A to Z</a></li>
<li><a href="https://jonnung.dev/docker/2020/04/08/optimizing-docker-images/">도커 이미지 잘 만드는 방법</a>  </li>
<li><a href="https://kimeuichan.github.io/posts/deploy-docker-more-faster/">자주 변경되는 도커 이미지 빠르게 배포하기</a>  </li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>프리마커 템플릿으로 이메일 발송하기</title>
    <url>/sending-mail-with-freemarker-template/</url>
    <content><![CDATA[<p><img data-src="https://javatutorial.net/wp-content/uploads/2017/12/spring-featured-image.png#compact"></p>
<h3 id="스프링-프레임워크의-이메일-지원"><a href="#스프링-프레임워크의-이메일-지원" class="headerlink" title="스프링 프레임워크의 이메일 지원"></a>스프링 프레임워크의 이메일 지원</h3><p>스프링 프레임워크에서는 이메일을 발송할 수 있도록 <code>org.springframework.mail</code> 패키지를 제공한다.</p>
<p><code>MailSender</code> 인터페이스는 메일 발송 기능을 가지는 최상위 인터페이스이며 스프링 프레임워크는 이 보다 더 좋은 기능을 제공하도록 확장한 <code>JavaMailSender</code> 인터페이스를 포함한다.</p>
<h4 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h4><p>스프링 프레임워크에서 메일을 발송할 때 사용되는 의존성은 다음과 같다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile(<span class="string">&#x27;org.springframework:spring-context-support:4.3.7.RELEASE&#x27;</span>)</span><br><span class="line">compile(<span class="string">&#x27;javax.mail:mail:1.4.7&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="JavaMailSenderImpl"><a href="#JavaMailSenderImpl" class="headerlink" title="JavaMailSenderImpl"></a>JavaMailSenderImpl</h5><p>스프링 프레임워크는 <code>JavaMailSender</code> 인터페이스의 구현체인 <code>JavaMailSenderImpl</code> 클래스를 제공하며</p>
<p>우리는 굳이 JavaMailSender 구현체를 만들지 않아도 이 JavaMailSenderImpl를 사용하여 메일을 발송하는 기능을 만들 수 있다.</p>
<h5 id="MimeMessageHelper"><a href="#MimeMessageHelper" class="headerlink" title="MimeMessageHelper"></a>MimeMessageHelper</h5><p>스프링 프레임워크는 <code>javax.mail.internet.MimeMessage</code> 클래스에 각종 설정들(제목이나 첨부파일 등)을 쉽게 지정할 수 있도록 헬퍼 클래스를 제공한다.</p>
<h3 id="이메일-발송을-위한-SMTP-서버"><a href="#이메일-발송을-위한-SMTP-서버" class="headerlink" title="이메일 발송을 위한 SMTP 서버"></a>이메일 발송을 위한 SMTP 서버</h3><p>이메일을 송수신하는 서버를 SMTP(Simple Mail Transfer Protocol) 서버라고 한다.</p>
<p>그러나, 스프링 프레임워크가 자체적으로 SMTP 서버를 제공해주지는 않기 때문에 실제로 이메일을 발송하기 위해서는 SMTP 서버를 구축해야만 한다.</p>
<p>SMTP 메일 서버를 구축하는 것 대신에 우리가 많이 사용하는 구글이나 네이버 이메일 계정으로 SMTP 메일 서버를 이용할 수 있다.</p>
<p>본 포스트 에서는 구글 이메일 계정으로 SMTP 메일 서버를 이용해보겠다.</p>
<blockquote>
<p><a href="https://github.com/ChangemakerStudios/Papercut%EC%99%80">https://github.com/ChangemakerStudios/Papercut와</a> 같은 개발용 SMTP 서버도 있다.</p>
</blockquote>
<h4 id="구글-SMTP-활성화"><a href="#구글-SMTP-활성화" class="headerlink" title="구글 SMTP 활성화"></a>구글 SMTP 활성화</h4><p>구글 SMTP 서버를 이용하기 위해서는 구글 이메일 계정의 <a href="https://myaccount.google.com/lesssecureapps"><code>보안 수준이 낮은 앱의 액세스</code></a>를 허용해야 한다.</p>
<p><img data-src="/spring/images/google-less-secure-apps.png"></p>
<p>이후 <a href="https://support.google.com/mail/answer/7126229?visit_id=636885550269950209-1570087438&rd=1">SMTP 서버 이용시 필요한 정보</a>는 다음과 같다.</p>
<ul>
<li>SMTP Host : smtp.gmail.com</li>
<li>SMTP Username : $email</li>
<li>SMTP Password : $password</li>
<li>SMTP Post : 465</li>
<li>SSL Enable : true</li>
</ul>
<h3 id="이메일-발송-기능-구현"><a href="#이메일-발송-기능-구현" class="headerlink" title="이메일 발송 기능 구현"></a>이메일 발송 기능 구현</h3><p>구글 SMTP 서버를 이용할 수 있도록 설정을 완료하였으니 이메일 발송 기능을 구현하도록 하자.</p>
<h4 id="JavaMailSender-빈-등록"><a href="#JavaMailSender-빈-등록" class="headerlink" title="JavaMailSender 빈 등록"></a>JavaMailSender 빈 등록</h4><p>우리가 가장 먼저 해야할 일은 JavaMailSender 인터페이스 구현체를 빈으로 등록하는 것이다.</p>
<p>간단하게 앞서 소개한 JavaMailSenderImpl을 구현체로 사용하고 프로퍼티에 존재하는 정보를 불러와 값을 설정한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaMailSender <span class="title">javaMailSender</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JavaMailSenderImpl mailSender = <span class="keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">    mailSender.setHost(env.getProperty(<span class="string">&quot;spring.mail.host&quot;</span>));</span><br><span class="line">    mailSender.setPort(Integer.valueOf(env.getProperty(<span class="string">&quot;spring.mail.port&quot;</span>)));</span><br><span class="line">    mailSender.setProtocol(env.getProperty(<span class="string">&quot;spring.mail.protocol&quot;</span>));</span><br><span class="line">    mailSender.setUsername(env.getProperty(<span class="string">&quot;spring.mail.username&quot;</span>));</span><br><span class="line">    mailSender.setPassword(env.getProperty(<span class="string">&quot;spring.mail.password&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Properties javaMailProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">    javaMailProperties.load(applicationContext.getResource(<span class="string">&quot;classpath:mail.properties&quot;</span>).getInputStream());</span><br><span class="line">    mailSender.setJavaMailProperties(javaMailProperties);</span><br><span class="line">    <span class="keyword">return</span> mailSender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JavaMailProperties를 프로퍼티에서 불러와 직접 값을 넣어주거나 ApplicationContext 대신에 ClassPathResource를 사용해도 무방하다.</p>
</blockquote>
<h5 id="메일-발송-프로퍼티"><a href="#메일-발송-프로퍼티" class="headerlink" title="메일 발송 프로퍼티"></a>메일 발송 프로퍼티</h5><p>위 JavaMailSender에서 사용된 프로퍼티 값을 설정한다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spring.mail.host=smtp.gmail.com</span><br><span class="line">spring.mail.port=465</span><br><span class="line">spring.mail.username=</span><br><span class="line">spring.mail.password=</span><br><span class="line"></span><br><span class="line"><span class="comment"># mail.properties</span></span><br><span class="line">mail.smtp.ssl.enable=<span class="literal">true</span></span><br><span class="line">mail.smtp.auth=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="프리마커-이메일-템플릿"><a href="#프리마커-이메일-템플릿" class="headerlink" title="프리마커 이메일 템플릿"></a>프리마커 이메일 템플릿</h3><p>본 포스트의 목표는 단순 이메일 발송이 아닌 프리마커 템플릿을 활용해서 이메일 내용을 구성해서 발송하는 것이다.</p>
<p>많은 템플릿 중에서 프리마커를 사용하려는 이유는 가장 설정이 쉽고 이메일 내용을 구성할 때 편리하다는 개인적인 판단 때문이다.</p>
<blockquote>
<p>대부분은 Thymeleaf를 사용하는 것으로 예제를 소개하고 있다.</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile(<span class="string">&#x27;org.freemarker:freemarker:2.3.28&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>의존성을 추가하였다면 <code>freemarker.template.Configuration</code> 클래스를 빈으로 등록한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> freemarker.template.<span class="function">Configuration <span class="title">freeMarkerConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TemplateException </span>&#123;</span><br><span class="line">    FreeMarkerConfigurationFactory freeMarkerConfigurationFactory = <span class="keyword">new</span> FreeMarkerConfigurationFactory();</span><br><span class="line">    freeMarkerConfigurationFactory.setTemplateLoaderPath(<span class="string">&quot;classpath:/templates/mails&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> freeMarkerConfigurationFactory.createConfiguration();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>설정은 끝났다(응?)</p>
<p>메일 본문을 넣는 코드에서 다음과 같이 템플릿으로 가져오면 된다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> freemarker.template.Configuration engine;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Template template = engine.getTemplate(mailBuilder.getTemplate().getContentPath(), locale);</span><br><span class="line">helper.setText(FreeMarkerTemplateUtils.processTemplateIntoString(template, context), <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>프리마커 템플릿으로 내용을 구성하는 방법은 본 포스트의 목적이 아니므로 생략한다.</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://support.google.com/mail/answer/7126229?visit_id=636885550269950209-1570087438&rd=1">다른 이메일 클라이언트에서 Gmail을 확인할 수 있도록 IMAP 사용</a></li>
<li><a href="https://www.baeldung.com/freemarker-in-spring-mvc-tutorial">Introduction to Using FreeMarker in Spring MVC</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>스프링 부트 액세스 로그를 엘라스틱서치에 기록하기</title>
    <url>/spring-boot-accesslog-with-elasticsearch/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>애플리케이션 서버로 요청되는 정보를 기록하는 <a href="https://d2.naver.com/helloworld/3585246">액세스 로그</a>는 애플리케이션 운영과 장애 대응에 있어서 상당히 중요한 정보입니다. 아마존 웹 서비스에서도 <a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/enable-server-access-logging.html">Amazon S3 서버 액세스 로깅 활성화</a>처럼 액세스 로그를 기록할 수 있는 기능을 제공하죠. 스프링 부트는 <strong>톰캣(Tomcat)</strong> 이나 <strong>언더토우(Undertow)</strong> 와 같은 WAS에 대하여 액세스 로그를 파일로 저장할 수 있는 기능을 기본적으로 포함하고 있습니다.</p>
<p>만약, 언더토우를 사용하고 있다면 다음과 같이 액세스 로그를 활성화하고 패턴을 지정할 수 있습니다.</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.undertow.accesslog.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.pattern</span>=<span class="string">common</span></span><br></pre></td></tr></table></figure>

<h2 id="스프링-부트-로깅"><a href="#스프링-부트-로깅" class="headerlink" title="스프링 부트 로깅"></a>스프링 부트 로깅</h2><p>스프링 부트는 기본적으로 Slf4j 기반의 <a href="https://logback.qos.ch/">로그백(Logback)</a>을 로깅 프레임워크로 사용합니다. 그래서 애플리케이션의 로그를 엘라스틱서치에 기록하기 위해서는 <a href="https://github.com/logfellow/logstash-logback-encoder">Logstash Logback Encoder</a>와 같이 로그백으로 기록되는 로그를 엘라스틱서치로 전달할 수 있게 구현해야합니다.</p>
<h3 id="Logback-Elasticsearch-Appender"><a href="#Logback-Elasticsearch-Appender" class="headerlink" title="Logback Elasticsearch Appender"></a>Logback Elasticsearch Appender</h3><p><a href="https://github.com/internetitem/logback-elasticsearch-appender">Logback Elasticsearch Appender</a>는 ELK 스택이 아니더라도 로그백으로 기록되는 로그를 엘라스틱서치로 전달하는 기능을 제공합니다. 오늘은 이것을 활용하여 스프링 부트 애플리케이션에서 발생하는 액세스 로그를 엘라스틱서치에 기록해보고자 합니다. </p>
<p><img data-src="/images/posts/spring-boot-accesslog-with-elasticsearch/logback-elasticsearch-appender-01.png"></p>
<p>그리고 위 처럼 <a href="https://logback.qos.ch/access.html">Logback Access</a>에 대한 Appender를 포함하고 있으므로 액세스 로그를 쉽게 엘라스틱서치로 전달할 수 있게 됩니다.</p>
<h3 id="Logback-Access-Spring-Boot-Starter"><a href="#Logback-Access-Spring-Boot-Starter" class="headerlink" title="Logback Access Spring Boot Starter"></a>Logback Access Spring Boot Starter</h3><p><a href="https://github.com/akkinoc/logback-access-spring-boot-starter">logback-access-spring-boot-starter</a>는 로그백 엑세스 설정에 대한 스프링 부트 스타터입니다. 언더토우까지 지원하므로 언더토우에 대해 로그백 엑세스 설정을 위한 <a href="https://gist.github.com/cdmatta/2a4536ab687bf7a92482faf031e8a0b5">커스터마이저</a>를 직접 구현하지 않아도 됩니다.</p>
<h3 id="따라하기"><a href="#따라하기" class="headerlink" title="따라하기"></a>따라하기</h3><p>스프링 부트 프로젝트를 만들고 저는 언더토우를 선호하므로 톰캣 모듈을 제외하고 언더토우 스타터를 추가했습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    exclude <span class="attr">module:</span> <span class="string">&#x27;spring-boot-starter-tomcat&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-undertow&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.internetitem:logback-elasticsearch-appender:1.6&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;dev.akkinoc.spring.boot:logback-access-spring-boot-starter:3.2.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>로그백 엑세스 스타터는 언더토우 뿐만 아니라 톰캣도 지원하므로 설정에 대한 차이는 없습니다.</p>
</blockquote>
<p>그리고 다음과 같이 로그백 엑세스를 위한 설정 파일을 클래스패스에 추가합니다. 설정 파일을 불러오는 <a href="https://github.com/akkinoc/logback-access-spring-boot-starter#priority-order">우선순위</a>에 따라 설정 파일명은 logback-access-spring.xml 이라고 생성하겠습니다.</p>
<p><strong>logback-access-spring.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;elasticsearch_uris&quot;</span> <span class="attr">source</span>=<span class="string">&quot;spring.elasticsearch.uris&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;http://localhost:9200&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELASTIC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.internetitem.logback.elasticsearch.ElasticsearchAccessAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>$&#123;elasticsearch_uris&#125;/_bulk<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">index</span>&gt;</span>application-accesslog-%date&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">index</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>Content-Type<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">headers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELASTIC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>스프링 부트 애플리케이션을 실행하고 브라우저 또는 클라이언트 도구를 통해 액세스 기록을 남겨보고 엘라스틱서치에 잘 저장되는지 확인해봅니다.</p>
<p><img data-src="/images/posts/spring-boot-accesslog-with-elasticsearch/elasticsearch-devtools-01.png"></p>
<p>인덱스는 생성되었지만 액세스 로그에 대한 정보가 없습니다. 액세스 로그 정보를 기록하기 위해서는 <a href="https://logback.qos.ch/manual/layouts.html#logback-access">Logback Access conversion words</a>를 참고해서 프로퍼티를 설정해야합니다. 앞서 생성한 로그백 엑세스 설정 파일에 다음과 같이 프로퍼티 항목을 추가로 정의하겠습니다.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;elasticsearch_uris&quot;</span> <span class="attr">source</span>=<span class="string">&quot;spring.elasticsearch.uris&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;http://localhost:9200&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELASTIC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.internetitem.logback.elasticsearch.ElasticsearchAccessAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>$&#123;elasticsearch_uris&#125;/_bulk<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">index</span>&gt;</span>application-accesslog-%date&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">index</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>contentLength<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>remoteHost<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%h<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>protocol<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%H<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>referer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%i&#123;Referer&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>userAgent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%i&#123;User-Agent&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>requestMethod<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%m<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>statusCode<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>elapsedTime<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%D<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>date<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%t&#123;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%u<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>queryString<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%q<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>requestURI<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>%U<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>Content-Type<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">headers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELASTIC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>미리 정의된 패턴인 combined를 참고하여 리퍼러와 유저 에이전트 헤더를 포함하도록 프로퍼티를 설정했습니다.</p>
</blockquote>
<p><img data-src="/images/posts/spring-boot-accesslog-with-elasticsearch/elasticsearch-devtools-02.png"></p>
<p>위 처럼 프로퍼티를 설정하였으므로 요청된 액세스에 대한 로그를 통해 유저 에이전트가 포스트맨이며 요청된 경로는 액추에이터인 것을 확인할 수 있게 되었습니다. 따라하시는 여러분은 다양한 항목에 대해서도 기록해보시면 좋을 것 같습니다.</p>
<h4 id="액세스-로그-인덱스-템플릿"><a href="#액세스-로그-인덱스-템플릿" class="headerlink" title="액세스 로그 인덱스 템플릿"></a>액세스 로그 인덱스 템플릿</h4><p>생성된 액세스 로그에 대한 인덱스 매핑 정보를 조회하면 동적 매핑에 의해서 엘라스틱서치가 필드 유형을 임의대로 지정한 것을 확인할 수 있습니다. 동적 매핑은 저장되는 도큐먼트의 필드 정보를 알기 어려울 때는 편리한 기능이지만 지금처럼 액세스 로그에 저장되는 필드가 고정되어있고 필드 유형을 파악할 수 있다면 정적 매핑을 정의해두는 것이 좋습니다.</p>
<p><img data-src="/images/posts/spring-boot-accesslog-with-elasticsearch/elasticsearch-devtools-03.png"></p>
<p>액세스 로그에 기록되는 정보가 명확하므로 동적 매핑을 수행하지 않고 미리 정의된 매핑을 사용하도록 인덱스 템플릿을 정의해두겠습니다. </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;index_patterns&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;applicaiton-accesslog-*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;template&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;path_analyzer&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;path_hierarchy&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@timestamp&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;contentLength&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;date&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;date_hour_minute_second || epoch_millis&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;elapsedTime&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;protocol&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;referer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;remoteHost&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ip&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;requestMethod&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;requestURI&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;path_analyzer&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;statusCode&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;short&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;userAgent&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>현재 조직에서는 엘라스틱서치에 애플리케이션의 로그 및 액세스 로그를 기록하지는 않고 있습니다만, 엘라스틱서치를 학습하기 위한 샘플 데이터가 없어서 간단하게나마 액세스 로그를 기록해보면 어떠할까 생각해서 시도해보았습니다. 현재 대량의 <a href="https://github.com/kdevkr/elasticsearch/blob/main/sample/access.q">랜덤 액세스 로그</a>를 만들기 위해서 컬럼형 시계열 데이터베이스인 KDB를 활용해보고는 있습니다만 쉽지는 않네요. 이 부분에 대해서는 많이 시도해보고 정리하여 공유해보겠습니다.</p>
</blockquote>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Elasticsearch</tag>
        <tag>Access Log</tag>
      </tags>
  </entry>
  <entry>
    <title>스프링 부트 MQTT 클라이언트 메시지 채널 구성하기</title>
    <url>/spring-boot-integration-mqtt/</url>
    <content><![CDATA[<p>제주 전기차 실증 시스템을 개발하면서 전기차 OBD 데이터를 수집하기 위하여 MQTT(Message Queuing Telemetry Transfer) 클라이언트를 구성하고 토픽에 대한 메시지 페이로드를 수신하는 것을 처음 구성하였습니다.</p>
<p>본 글에서는 스프링 MQTT를 통해 MQTT 클라이언트와 메시지 구독 또는 발행하는 채널을 구성하는 것을 설명합니다.</p>
<h2 id="의존성"><a href="#의존성" class="headerlink" title="의존성"></a>의존성</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-integration&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework.integration:spring-integration-mqtt&#x27;</span></span><br></pre></td></tr></table></figure>

<p>스프링 MQTT는 <a href="https://www.eclipse.org/paho/">Eclipse Paho MQTT Client</a> 라이브러리를 사용합니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">org.springframework.<span class="attr">integration:</span>spring-integration-<span class="attr">mqtt:</span><span class="number">5.3</span><span class="number">.2</span>.RELEASE</span><br><span class="line">  org.eclipse.<span class="attr">paho:</span>org.eclipse.paho.client.<span class="attr">mqttv3:</span><span class="number">1.2</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>

<h2 id="Inbound-Channel-Configuration"><a href="#Inbound-Channel-Configuration" class="headerlink" title="Inbound Channel Configuration"></a>Inbound Channel Configuration</h2><p>토픽 메시지 구독을 위한 인바운드 채널 구성은 <code>MqttPahoMessageDrivenChannelAdapter</code> 구현체를 통해 가능합니다.</p>
<h3 id="DefaultMqttPahoClientFactory"><a href="#DefaultMqttPahoClientFactory" class="headerlink" title="DefaultMqttPahoClientFactory"></a>DefaultMqttPahoClientFactory</h3><p>기본적으로 <code>DefaultMqttPahoClientFactory</code>를 통해 MQTT 클라이언트를 등록합니다. 그러므로 우리는 MQTT 연결 정보(MqttConnectOptions)을 설정한 DefaultMqttPahoClientFactory를 빈으로 등록합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MQTT_USERNAME = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MQTT_PASSWORD = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MqttConnectOptions <span class="title">connectOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MqttConnectOptions options = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">        options.setCleanSession(<span class="keyword">true</span>);</span><br><span class="line">        options.setUserName(MQTT_USERNAME);</span><br><span class="line">        options.setPassword(MQTT_PASSWORD.toCharArray());</span><br><span class="line">        <span class="keyword">return</span> options;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMqttPahoClientFactory <span class="title">defaultMqttPahoClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMqttPahoClientFactory clientFactory = <span class="keyword">new</span> DefaultMqttPahoClientFactory();</span><br><span class="line">        clientFactory.setConnectionOptions(connectOptions());</span><br><span class="line">        <span class="keyword">return</span> clientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MqttPahoMessageDrivenChannelAdapter"><a href="#MqttPahoMessageDrivenChannelAdapter" class="headerlink" title="MqttPahoMessageDrivenChannelAdapter"></a>MqttPahoMessageDrivenChannelAdapter</h3><p>앞서 등록하였던 MQTT 클라이언트를 통해 메시지를 구독하기 위하여 <code>MqttPahoMessageDrivenChannelAdapter</code>를 통해 메시지 수신을 위한 채널을 구성합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_URL = <span class="string">&quot;tcp://localhost:1883&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MQTT_CLIENT_ID = MqttAsyncClient.generateClientId();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_FILTER = <span class="string">&quot;[PROTECT]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageChannel <span class="title">mqttInputChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProducer <span class="title">inboundChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MqttPahoMessageDrivenChannelAdapter adapter =</span><br><span class="line">                <span class="keyword">new</span> MqttPahoMessageDrivenChannelAdapter(BROKER_URL, MQTT_CLIENT_ID, TOPIC_FILTER);</span><br><span class="line">        adapter.setCompletionTimeout(<span class="number">5000</span>);</span><br><span class="line">        adapter.setConverter(<span class="keyword">new</span> DefaultPahoMessageConverter());</span><br><span class="line">        adapter.setQos(<span class="number">1</span>);</span><br><span class="line">        adapter.setOutputChannel(mqttInputChannel());</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;mqttInputChannel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageHandler <span class="title">inboundMessageHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message -&gt; &#123;</span><br><span class="line">            String topic = (String) message.getHeaders().get(MqttHeaders.RECEIVED_TOPIC);</span><br><span class="line">            System.out.println(<span class="string">&quot;Topic:&quot;</span> + topic);</span><br><span class="line">            System.out.println(<span class="string">&quot;Payload&quot;</span> + message.getPayload());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 MQTT 클라이언트에 의해 수신된 페이로드는 MQTT 클라이언트 ➤ Inbound Channel ➤ MessageChannel ➤ MessageHandler 순으로 이동되어 MessageHandler를 통해 수신된 페이로드를 확인할 수 있습니다.</p>
<h2 id="Outbound-Channel-Configuration"><a href="#Outbound-Channel-Configuration" class="headerlink" title="Outbound Channel Configuration"></a>Outbound Channel Configuration</h2><p>제주 전기차 실증 시스템에서는 MQTT 클라이언트를 통해 메시지를 발행하는 것은 구현하지 않았습니다. 다만, 메시지를 수신하는 채널을 등록하는 것처럼 메시지를 발행하기 위한 채널을 구성하면 됩니다.</p>
<h3 id="MqttPahoMessageHandler"><a href="#MqttPahoMessageHandler" class="headerlink" title="MqttPahoMessageHandler"></a>MqttPahoMessageHandler</h3><p>MQTT 클라이언트는 이미 구성되었으므로 <code>MqttPahoMessageHandler</code>으로 메시지 발행을 위한 채널을 구성합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MQTT_CLIENT_ID = MqttAsyncClient.generateClientId();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageChannel <span class="title">mqttOutboundChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;mqttOutboundChannel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageHandler <span class="title">mqttOutbound</span><span class="params">(DefaultMqttPahoClientFactory clientFactory)</span> </span>&#123;</span><br><span class="line">        MqttPahoMessageHandler messageHandler =</span><br><span class="line">                <span class="keyword">new</span> MqttPahoMessageHandler(MQTT_CLIENT_ID, clientFactory);</span><br><span class="line">        messageHandler.setAsync(<span class="keyword">true</span>);</span><br><span class="line">        messageHandler.setDefaultQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> messageHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 @MessagingGateway 어노테이션을 선언한 메시지 게이트웨이 API를 통해 메시지를 발송합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessagingGateway(defaultRequestChannel = &quot;mqttOutboundChannel&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OutboundGateway</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendToMqtt</span><span class="params">(String payload, <span class="meta">@Header(MqttHeaders.TOPIC)</span> String topic)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MQTT-Events"><a href="#MQTT-Events" class="headerlink" title="MQTT Events"></a>MQTT Events</h2><p>만약, MQTT 클라이언트가 브로커 서버에 연결을 실패하거나 토픽 구독을 감지한 이벤트를 처리하고 싶다면 다음의 링크를 참고하시기 바랍니다.</p>
<p><a href="https://docs.spring.io/spring-integration/reference/html/mqtt.html#mqtt-events">https://docs.spring.io/spring-integration/reference/html/mqtt.html#mqtt-events</a></p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://docs.spring.io/spring-integration/reference/html/mqtt.html">Spring Integration - MQTT Support</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>스프링 부트 애플리케이션을 Vue와 함께 개발하기</title>
    <url>/spring-boot-integration-vuejs/</url>
    <content><![CDATA[<blockquote>
<p>관련 소스코드는 Github <a href="https://github.com/kdevkr/spring-boot-integration-vuejs">spring-boot-integration-vuejs</a> 리포지토리에서 제공합니다.</p>
</blockquote>
<p>최근에는 스프링 프레임워크로 애플리케이션 개발 시 프론트엔드 클라이언트를 Vue를 활용하여 개발하고 배포합니다. 이번 글에서는 스프링 부트 프로젝트를 시작하고 Vue CLI를 통해 프론트엔드 클라이언트를 개발할 때 어떻게 진행하는지 설명합니다. 제가 알려드리는 방법과 구조는 정확한 정답은 아님을 미리 밝히는 바 입니다.</p>
<h2 id="Spring-Initializr"><a href="#Spring-Initializr" class="headerlink" title="Spring Initializr"></a>Spring Initializr</h2><p>스프링 부트 프로젝트는 <a href="https://start.spring.io/">Spring Initializr</a>에서 쉽게 여러분이 스프링 부트 애플리케이션을 시작할 수 있도록 지원합니다. 저는 메이븐(Maven)이 아닌 <code>그래들(Gradle)</code> 프로젝트를 선호하며 언어는 <code>Java</code>로 개발합니다.</p>
<p><img data-src="/images/posts/spring-initializr.png"></p>
<p>그리고 위와 같이 프로젝트에서 사용할 의존성(Dependencies)를 찾아 선택합니다. 이렇게 만들어지는 스프링 부트 프로젝트는 다음과 같은 디렉토리 구조를 가지게 됩니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"> ├─ main</span><br><span class="line"> │ ├─ java</span><br><span class="line"> │ └─ resources</span><br><span class="line">gradle</span><br><span class="line">build.gradle</span><br></pre></td></tr></table></figure>

<h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><p>앞서 <code>Spring Initializr</code>를 통해 스프링 부트 프로젝트를 구성하였습니다. 이제는 스프링 부트 애플리케이션과 함께 개발할 Vue 프로젝트를 구성합니다. Vue 프로젝트는 Vue CLI를 활용하여 쉽게 시작할 수 있습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Vue CLI는 NPM으로 설치합니다.</span></span><br><span class="line">npm i -g @vue/cli</span><br><span class="line"><span class="comment"># 그리고 create 명령어로 프로젝트를 시작합니다.</span></span><br><span class="line">vue create --preset kdevkr/vue-preset [project-name]</span><br></pre></td></tr></table></figure>

<p>위 예시처럼 Vue 프로젝트를 시작할 때 자주 사용하는 플러그인을 프리셋 형태(preset.json)로 구성하여 지정할 수 있습니다. 저의 <a href="https://github.com/kdevkr/vue-preset">kdevkr/vue-preset</a> 프리셋은 다음의 라이브러리들을 포함하는 Vue 프로젝트를 구성합니다.</p>
<ul>
<li>Babel</li>
<li>ESLint + Prettier</li>
<li>SCSS (with dart-sass)</li>
<li>Vuex</li>
<li>Vue Router</li>
<li>Bootstrap Vue</li>
<li>Fontawesome</li>
</ul>
<h3 id="src-main-vue"><a href="#src-main-vue" class="headerlink" title="src/main/vue"></a>src/main/vue</h3><p>보통은 프로젝트 루트 경로에 Vue 프로젝트를 구성해도 상관없으나 저는 <code>src/main/java</code>처럼 <code>src/main/vue</code>로 구성하는 것을 추천합니다. 이제 src/main/vue 폴더에서 프론트엔드 클라이언트 코드를 관리하게 됩니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> src/main</span><br><span class="line">vue create --preset kdevkr/vue-preset vue</span><br></pre></td></tr></table></figure>

<p>Vue CLI에 의해 <a href="https://github.com/kdevkr/spring-boot-integration-vuejs/tree/main/src/main/vue">src/main/vue</a>에 Vue 프로젝트가 만들어집니다.</p>
<h3 id="Vue-Configuration"><a href="#Vue-Configuration" class="headerlink" title="Vue Configuration"></a>Vue Configuration</h3><p>Vue 프로젝트에 대한 설정은 <code>vue.config.js</code>를 통해 변경할 수 있습니다. Vue 프로젝트는 만들었지만 몇가지 설정을 진행해야합니다. 가장 먼저 Vue를 통해 개발할 때는 <a href="https://cli.vuejs.org/config/#devserver">webpack-dev-server</a>를 실행해서 개발합니다.</p>
<p>스프링 부트 애플리케이션은 별다른 설정이 없으면 <code>8080</code> 포트를 사용하게 됩니다. 따라서, Vue 개발용 서버는 <code>8081</code> 포트를 사용하도록 합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8081</span>,</span><br><span class="line">    <span class="attr">proxy</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">    <span class="attr">disableHostCheck</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 <code>http://localhost:8081</code>으로 접속하여 웹 페이지를 개발할 수 있게 되고 프록시 설정을 통해 Vue 개발용 서버가 처리하지 못하는 모든 요청은 8080 포트로 요청합니다. 따라서, Vue 컴포넌트 내에서 스프링 부트 애플리케이션이 제공하는 API를 호출할 수 있게 됩니다.</p>
<blockquote>
<p>API 호출을 위해 <code>jQuery.ajax</code> 또는 <code>axios</code>를 사용하는 것은 본 글의 주된 관심사가 아닙니다.</p>
</blockquote>
<h3 id="Production-build"><a href="#Production-build" class="headerlink" title="Production build"></a>Production build</h3><p>Vue 프로젝트로 개발한 프론트엔드 클라이언트는 <code>build</code> 명령을 사용하여 빌드할 수 있습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>위 명령을 통해 빌드되는 파일은 <code>dist/</code> 폴더에 생성됩니다. 따라서, <code>src/main/vue/dist</code>에 만들어지게 됩니다. 만약, 스프링 부트 애플리케이션을 빌드하여 실행하였다면 해당 파일들은 스프링 부트 애플리케이션이 리소스를 읽어 배포할 수 없게 됩니다.</p>
<p>스프링 부트 애플리케이션이 기본적으로 리소스를 읽어 배포하는 경로는 <a href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/html/appendix-application-properties.html#spring.web.resources.static-locations"><code>spring.web.resources.static-locations</code></a> 프로퍼티로 확인할 수 있습니다. 저는 <code>src/main/resources/static/dist</code>를 Vue 프로젝트의 빌드 경로로 잡고 스프링 부트 애플리케이션에서 해당 빌드 파일을 배포할 수 있게 설정하도록 하겠습니다.</p>
<p>먼저 애플리케이션 프로퍼티에 클래스패스를 기준으로 <code>static/dist</code>의 리소스를 읽을 수 있게 합니다.<br><strong>application.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.web.resources.static-locations</span>=<span class="string">classpath:/META-INF/resources/, classpath:/resources/, classpath:/static/, classpath:/public/, classpath:/static/dist</span></span><br></pre></td></tr></table></figure>

<p>그리고 Vue 프로젝트 빌드 경로는 <code>outputDir</code>로 설정할 수 있습니다.<br><strong>vue.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">outputDir</span>: path.resolve(__dirname, <span class="string">&#x27;../resources/static/dist&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Freemarker-Template-Engine"><a href="#Freemarker-Template-Engine" class="headerlink" title="Freemarker Template Engine"></a>Freemarker Template Engine</h2><p>Vue 프로젝트로 빌드된 프론트엔드 클라이언트를 위한 파일들은 <code>html-webpack-plugin</code>에 의해 만들어지는 <code>index.html</code>에 자동으로 파일들이 포함됩니다. 그런데 스프링 부트 애플리케이션에서 템플릿 엔진을 사용하여 페이지에 대한 정보나 세션 정보를 웹 페이지에 포함시키고 싶을 수 있습니다. 예를 들어, Spring Initializr에서 프리마커를 템플릿 엔진으로 사용하기 위하여 의존성을 추가하였다면 <code>src/main/resources/templates</code> 하위에 위치한 <code>*.ftlh</code>을 View로 제공할 수 있습니다.</p>
<p>따라서, 다음과 같이 <code>indexPath</code>를 설정하여 index.ftlh이 만들어지는 위치를 지정할 수 있습니다.<br><strong>vue.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">indexPath</span>: <span class="string">&#x27;../../templates/index.ftlh&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>앞서 index 파일은 <code>html-webpack-plugin</code>에 의해 만들어진다고 하였습니다. 우리가 위에서 indexPath를 지정한 것은 단순히 확장자를 <code>.ftlh</code>로 바꾼 것과 다를 바 없습니다. 템플릿 엔진을 사용하는 목적은 해당 템플릿 엔진에서 지원하는 문법으로 정보를 표현하기 위함입니다. 이를 위해 플러그인에 대한 옵션을 변경하도록 합니다.</p>
<p>예를 들어, &lt;html&gt; 태그에 lang 속성에 요청에 따른 언어값을 부여하고 싶을 수 있습니다. 그러면 다음과 같이 index.ftlh가 만들어져야 합니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;$&#123;.locale?split(&quot;</span><span class="attr">_</span>&quot;)[<span class="attr">0</span>]&#125;&quot;&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>아쉽게도 html-webpack-plugin은 위 내용을 읽다가 값을 처리할 수 없어 오류를 보여줍니다. 다행스럽게도 약간의 트릭을 쓰면서 플러그인 옵션을 건드려서 가능하게 할 수 있습니다.</p>
<p><strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&lt;%= &#x27;\$&#123;.locale?split(\&quot;</span><span class="attr">_</span>\&quot;)[<span class="attr">0</span>]&#125;&#x27; %&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>vue.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.plugin(<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">        .tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">          args[<span class="number">0</span>].minify = <span class="literal">false</span></span><br><span class="line">          args[<span class="number">0</span>].interpolate = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">return</span> args</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>minify</code> 옵션을 끄는 것은 스프링 부트 애플리케이션이 프리마커 템플릿 엔진으로 <code>index.ftlh</code>을 읽을 때 발생하는 오류를 방지하기 위함입니다.</p>
<p>이제 빌드된 <a href="https://github.com/kdevkr/spring-boot-integration-vuejs/blob/main/src/main/resources/templates/index.ftlh">index.ftlh</a>는 다음과 같이 만들어집니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;$&#123;.locale?split(&quot;</span><span class="attr">_</span>&quot;)[<span class="attr">0</span>]&#125;&quot;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/js/about.d6d714df.js&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/css/app.f94ee837.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/css/chunk-vendors.01c183df.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/js/app.247cb7a3.js&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/js/chunk-vendors.65fb301b.js&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/css/chunk-vendors.01c183df.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/css/app.f94ee837.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We&#x27;re sorry but vue doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/chunk-vendors.65fb301b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/app.247cb7a3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>이제 여러분도 스프링 부트 애플리케이션을 Vue와 함께 개발할 수 있게 되었습니다. 감사합니다. 😀</p>
]]></content>
  </entry>
  <entry>
    <title>스프링 멀티파트 업로드</title>
    <url>/spring-multipart-uploads/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다. 오늘은 스프링 웹 모듈에 포함되어 있는 <strong>멀티파트 리졸버(MultipartResolver)</strong> 에 대한 이야기를 해볼까합니다. 멀티파트 리졸버는 HTTP 요청 페이로드에 포함되는 멀티파트를 쉽게 가져올 수 있도록 지원하기 위한 추상화로 여러분이 파일 업로드 기능을 구현하기 위하여 컨트롤러에 핸들러 함수를 작성할 때 멀티파트 관련 클래스를 사용할 수 있게 도와주는 시작점입니다.</p>
<p>본 글을 통해 멀티파트 폼 데이터가 포함된 요청을 분석하고 처리해주는 멀티파트 리졸버를 알아보고 컨트롤러 핸들러 함수 매개변수에 데이터가 바인딩되기까지의 과정을 이해할 수 있게 도와드리겠습니다.</p>
<p>관련 코드는 <a href="https://github.com/mambo-dev/learning-spring/tree/main/multipart-uploads">mambo-dev/learning-spring/multipart-uploads</a>에서 제공합니다.</p>
<h2 id="멀티파트-폼-데이터"><a href="#멀티파트-폼-데이터" class="headerlink" title="멀티파트 폼 데이터"></a>멀티파트 폼 데이터</h2><p>클라이언트(일반적으로 웹 브라우저)가 HTTP 프로토콜을 사용하여 바이너리 데이터를 보낼때는 HTTP 요청 페이로드에 포함된 데이터가 멀티파트 형식이라고 알려주기 위해서 Content-Type 헤더에 <code>multipart/form-data</code>를 사용하여 전송합니다.</p>
<details class="note info no-icon"><summary><p>multipart/form-data</p>
</summary>
<p><a href="https://stackoverflow.com/questions/4526273/what-does-enctype-multipart-form-data-mean"><strong>What does enctype=’multipart/form-data’ mean?</strong></a></p>

</details>

<p>다음은 HTTP 요청 클라이언트 중 하나인 Postman으로 멀티파트 폼 데이터 형식으로 파일 데이터를 전송할 때 확인할 수 있는 예시입니다.</p>
<p><img data-src="/images/posts/spring-multipart-uploads/spring-multipart-uploads-01.png" alt="멀티파트 폼 데이터 예시"></p>
<h2 id="멀티파트-리졸버"><a href="#멀티파트-리졸버" class="headerlink" title="멀티파트 리졸버"></a>멀티파트 리졸버</h2><p>스프링의 디스패처 서블릿은 HTTP 요청에 대해서 멀티파트 유형의 데이터가 포함된 요청인지 확인하는 멀티파트 필터(MultipartFilter)로 요청에 대한 처리를 위임하며 멀티파트 필터는 멀티파트 리졸버(MultipartResolver)를 사용하여 멀티파트 관련 요청인지 확인하는 과정을 수행합니다.</p>
<figure class="highlight java"><figcaption><span>MultipartResolver</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipartResolver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isMultipart</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">	<span class="function">MultipartHttpServletRequest <span class="title">resolveMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cleanupMultipart</span><span class="params">(MultipartHttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드처럼 멀티파트 리졸버는 인터페이스로 추상화되어있으며 이를 구현한 두개의 MultipartResolver 구현체를 제공합니다. 하나는 서블릿 3.0 이전에 사용하던 Apache Commons FileUpload 라이브러리를 사용하던 CommonsMultipartResolver이며 서블릿 3.0 Part API를 사용하는 StandardServletMultipartResolver입니다.</p>
<ul>
<li><strong>CommonsMultipartResolver</strong><br>Apache Commons FileUpload를 사용하는 멀티파트 리졸버</li>
<li><strong>StandardServletMultipartResolver</strong><br>Servlet 3.0+ Part API를 사용하는 표준 멀티파트 리졸버</li>
</ul>
<p>스프링 3.1에서는 Servlet 3.0 지원을 위한 클래스들이 많이 추가되었습니다. 그 중 하나가 바로 서블릿 표준의 Part API를 사용하는 StandardServletMultipartResolver이며 스프링 3.1 이후에는 굳이 Apache Commons FileUpload 라이브러리에 대한 의존성을 가지지 않아도 멀티파트를 처리할 수 있게 되었습니다.</p>
<p>스프링 5의 웹 모듈을 살펴보면 멀티파트 필터(MultipartFilter)에서 루트 애플리케이션 컨텍스트에 <strong>filterMultipartResolver</strong> 이름의 빈을 찾지 못하는 경우 자체적으로 StandardServletMultipartResolver를 기본적으로 사용하도록 되어있습니다. 따라서, 클라이언트의 HTTP 요청은 멀티파트 필터를 거쳐 StandardServletMultipartResolver에 의해 멀티파트 데이터 유형인지를 확인합니다.</p>
<p><img data-src="/images/posts/spring-multipart-uploads/spring-multipart-uploads-02.png" alt="멀티파트 유형 여부"></p>
<p>앞서 포스트맨 클라이언트에서 요청한 멀티파트 폼 데이터는 컨텐트 타입이 multipart/로 시작하므로 멀티파트 유형의 요청이며 resolveMultipart 함수에 의해 기본 HttpServletRequest가 멀티파트 관련 함수를 제공하는 MultipartHttpServletRequest로 감싸져있는 요청 클래스로 리턴하게됩니다.</p>
<p><img data-src="/images/posts/spring-multipart-uploads/spring-multipart-uploads-03.png" alt="디버그로 확인해본 MultipartHttpServletRequest"></p>
<p>위 그림처럼 멀티파트 리졸버에 의해 래핑된 MultipartHttpServletRequest에서 임베디드 톰캣의 임시 폴더에 저장된 파일을 확인할 수 있습니다. 이렇게 멀티파트 리졸버에 의해 생성된 임시 파일들은 최종적으로 cleanupMultipart 함수에 의해 정리됩니다.</p>
<h2 id="멀티파트-데이터-바인딩"><a href="#멀티파트-데이터-바인딩" class="headerlink" title="멀티파트 데이터 바인딩"></a>멀티파트 데이터 바인딩</h2><p>앞서 알아본 내용에 따르면 멀티파트 리졸버는 멀티파트 유형의 요청인지를 분석하고 멀티파트 관련 함수를 사용할 수 있는 MultipartHttpServletRequest로 래핑하는 역할이 전부입니다. 그렇다면 여러분이 작성하는 컨트롤러의 핸들러 함수에 대한 매개변수에 멀티파트 관련 클래스가 있는 경우 데이터를 주입하는 것은 어디서 수행하는 것 일까요?</p>
<blockquote>
<p>스프링의 핸들러 함수 데이터 바인딩에 대해서 잘 모르시는 분들이 많은 것 같아 이 부분도 따로 정리해보려고 준비중입니다.</p>
</blockquote>
<p>컨트롤러의 핸들러 함수 매개변수 유형에 따라 데이터를 바인딩(주입)하는 것은 HandlerMethodArgumentResolver가 담당하는데요. 스프링 웹 모듈에 포함되어있는 기본 HandlerMethodArgumentResolver 구현체들 중에서 멀티파트(MultipartFile 또는 Part) 유형의 클래스에 대한 데이터 바인딩은 RequestParamMethodArgumentResolver와 RequestPartMethodArgumentResolver 입니다.</p>
<p>위 두개의 HandlerMethodArgumentResolver는 어노테이션과 관련하여 데이터 바인딩을 수행하는데 <code>@RequestParam</code>과 <code>@RequestPart</code> 입니다.</p>
<p><strong>RequestParamMethodArgumentResolver</strong><br>이 리졸버는 @RequestParam이 선언된 매개변수에 데이터 바인딩을 수행하는데 스프링 4.3 부터는 @RequestParam이 선언되지 않은 멀티파트 유형의 매개변수에 대해서 MultipartResolutionDelegate에 의해 멀티파트 요청(MultipartRequest)인지를 확인하고 MultipartRequest에서 MultipartFile을 추출합니다.</p>
<p><strong>RequestPartMethodArgumentResolver</strong><br>이 리졸버는 @RequestPart이 선언된 매개변수에 데이터 바인딩을 수행하며 @RequestParam가 선언되지 않은 멀티파트 유형 매개변수에 대해 MultipartResolutionDelegate로 멀티파트 데이터 바인딩을 수행합니다.</p>
<blockquote>
<p>위 리졸버들에서 MultipartResolutionDelegate에 의해 멀티파트 유형의 매개변수에 대한 데이터 바인딩이 수행될 수 있는 이유는 멀티파트 리졸버에 의해서 MultipartHttpServletRequest로 변환되기 때문입니다.</p>
</blockquote>
<h3 id="데이터-바인딩-우선순위"><a href="#데이터-바인딩-우선순위" class="headerlink" title="데이터 바인딩 우선순위"></a>데이터 바인딩 우선순위</h3><p>위 내용에 따르면 @RequestParam과 @RequestPart가 선언되지 않은 멀티파트 유형의 매개변수에 데이터 바인딩을 수행하는 것을 알 수 있습니다. 그런데 둘다 MultipartResolutionDelegate에 의해서 데이터 바인딩이 수행되는데요. 그러면 어떤 HandlerMethodArgumentResolver에 의해 데이터 바인딩이 수행될까요?</p>
<p>RequestMappingHandlerAdapter에서 기본적으로 적용되는 HandlerMethodArgumentResolver 순서를 보면 RequestParamMethodArgumentResolver가 RequestPartMethodArgumentResolver 보다 우선적으로 추가되는 것을 확인할 수 있습니다. 따라서, RequestPartMethodArgumentResolver는 RequestParamMethodArgumentResolver에 의해 처리되지 않은 매개변수에 대해 데이터 바인딩을 수행하게 됩니다.</p>
<p><img data-src="/images/posts/spring-multipart-uploads/spring-multipart-uploads-04.png" alt="HandlerMethodArgumentResolver 순서"></p>
<p>직접 테스트를 해보면 @RequestParam과 @RequestPart 모두 매개변수에 선언하더라도 RequestParamMethodArgumentResolver에 의해 먼저 처리됨을 확인할 수 있습니다.</p>
<blockquote>
<p>디버깅 시 HandlerMethodArgumentResolverComposite에서 핸들러 함수 매개변수에 대한 HandlerMethodArgumentResolver를 캐시하므로 주의하시기 바랍니다.</p>
</blockquote>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>본 글에서 알아본 내용을 요약해보면서 다시한번 머리속에 숙지해봅시다.</p>
<ol>
<li>HTTP 요청 시 컨텐트 타입이 <code>multipart/</code>로 시작되는 경우를 멀티파트 요청으로 판단한다.</li>
<li>멀티파트 필터가 동작하는 과정해서 멀티파트 리졸버에 의해 멀티파트 관련 함수를 제공하는 <code>MultipartHttpServletRequest</code>로 요청 클래스가 래핑된다.</li>
<li>래핑된 요청 클래스는 RequestMappingHandlerAdapter에서 HandlerMethodArgumentResolver로 핸들러 매개변수에 대한 데이터 바인딩을 시도한다.</li>
<li>@RequestParam는 @RequestPart보다 우선적으로 사용된다.</li>
</ol>
<p>여러분은 본 글을 통해 멀티파트 데이터 바인딩 과정을 이해하였으므로 핸들러 함수 매개변수에 어떻게 멀티파트 데이터를 바인딩하는지 알 수 있으므로 매개변수에 바인딩된 파일 데이터를 저장하는 로직을 작성하여 파일 업로드 기능을 구현할 수 있습니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>MultipartFile</tag>
        <tag>MultipartResolver</tag>
      </tags>
  </entry>
  <entry>
    <title>SonarQube와 Github Action으로 수행하는 정적 분석</title>
    <url>/static-analysis-performed-by-sonarqube-and-github-action/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 SonarQube와 Github Action을 통해 정적 분석을 수행하기 위한 과정을 알아보려고 합니다.</p>
<h2 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h2><p><a href="https://www.sonarqube.org/">소나큐브</a>는 다양한 언어에 대한 코드 품질을 분석하고 취약점을 파악할 수 있는 정적 분석 도구입니다. 회사에서 정적 분석을 수행하고 싶다는 요구사항이 있어 제가 SonarQube를 도입하고 월요일과 금요일마다 프로젝트 코드에 대한 정적 분석을 수행하고 있습니다. 제가 정적 분석을 위해서 소나큐브를 도입한 이유는 다음과 같습니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-00.png" alt="소나큐브 라이센스"></p>
<ol>
<li>GPLv3 라이센스 기반의 오픈소스 버전 지원</li>
<li>IntelliJ 또는 VSCode와 같은 IDE를 위한 SonarLint 지원</li>
<li>소나큐브에 대한 공식 도커 이미지 지원</li>
<li>다양한 언어와 커뮤니티 기반의 규칙 지원</li>
</ol>
<p>회사 개발자들이 주로 사용하는 인텔리제이 IDEA 또는 VSCode에서 사용할 수 있는 SonarLint를 제공하여 별도의 서버 없이도 간단하게 자체적으로 정적 분석을 수행하고 결과를 확인할 수 있으며 공식 도커 이미지를 통해 별다른 설정 없이도 간단하게 소나큐브 시스템을 구성할 수 있습니다.</p>
<h3 id="소나큐브-시스템-구성"><a href="#소나큐브-시스템-구성" class="headerlink" title="소나큐브 시스템 구성"></a>소나큐브 시스템 구성</h3><p>소나큐브는 <a href="https://docs.sonarqube.org/latest/setup/install-server/">직접 설치</a>할 수도 있으며 도커 이미지와 함께 제공하는 도커 컴포즈 문서를 활용할 수 있습니다.</p>
<p><a href="https://github.com/SonarSource/docker-sonarqube/blob/master/example-compose-files/sq-with-postgres/docker-compose.yml">sq-with-postgres/docker-compose.yml</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sonarqube:9.1.0-community</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarnet</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SONAR_JDBC_URL:</span> <span class="string">jdbc:postgresql://db:5432/sonar</span></span><br><span class="line">      <span class="attr">SONAR_JDBC_USERNAME:</span> <span class="string">sonar</span></span><br><span class="line">      <span class="attr">SONAR_JDBC_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarqube_data:/opt/sonarqube/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarqube_extensions:/opt/sonarqube/extensions</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarqube_logs:/opt/sonarqube/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarqube_temp:/opt/sonarqube/temp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarqube_bundled-plugins:/opt/sonarqube/lib/bundled-plugins</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">      <span class="attr">nofile:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">262144</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">262144</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarnet</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">sonar</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgresql:/var/lib/postgresql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgresql_data:/var/lib/postgresql/data</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">sonarnet:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">sonarqube_data:</span></span><br><span class="line">  <span class="attr">sonarqube_extensions:</span></span><br><span class="line">  <span class="attr">sonarqube_logs:</span></span><br><span class="line">  <span class="attr">sonarqube_temp:</span></span><br><span class="line">  <span class="attr">sonarqube_bundled-plugins:</span></span><br><span class="line">  <span class="attr">postgresql:</span></span><br><span class="line">  <span class="attr">postgresql_data:</span></span><br></pre></td></tr></table></figure>

<h4 id="WSL-vm-max-map-count"><a href="#WSL-vm-max-map-count" class="headerlink" title="WSL vm.max_map_count"></a>WSL vm.max_map_count</h4><p>윈도우 환경에서 WSL로 도커 컨테이너를 실행하는 경우 vm.max_map_count로 인하여 소나큐브에서 실행하는 Elasticsearch가 실행되지 않을 수 있습니다. 이 경우 윈도우 터미널에서 WSL로 도커 컨테이너로 접속 후 다음의 명령어를 실행하여 Elasticsearch에서 요구하는 수치로 변경하시면 됩니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span></span><br><span class="line">wsl -d docker-desktop</span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>

<blockquote>
<p>소나큐브의 관리자 계정과 초기 비밀번호는 admin/admin 입니다.</p>
</blockquote>
<h3 id="소나큐브-프로젝트-생성"><a href="#소나큐브-프로젝트-생성" class="headerlink" title="소나큐브 프로젝트 생성"></a>소나큐브 프로젝트 생성</h3><p>소나큐브에 접속하였다면 정적 분석을 수행할 프로젝트를 생성해야합니다. 저는 깃허브 리파지토리 이름을 그대로 사용하는 편입니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-01.png" alt="spring5-web-example 프로젝트"></p>
<p>그리고 소나큐브에 로그인할 수 있는 토큰을 발행합니다. </p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-02.png"></p>
<p>토큰 용도를 구분하기 위한 이름을 지정하는데 저는 Github Action에서 사용할 예정이므로 GITHUB_ACTION을 지정하였습니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-03.png"></p>
<p>저는 로컬 컴퓨터에 소나큐브를 실행하였고 필요할때만 포트포워딩을 수행할 예정이므로 토큰을 공개하겠습니다. (어차피 학습 후에 지움…)</p>
<h3 id="소나큐브-관련-코드-추가"><a href="#소나큐브-관련-코드-추가" class="headerlink" title="소나큐브 관련 코드 추가"></a>소나큐브 관련 코드 추가</h3><p>소나큐브 시스템에 프로젝트를 생성하고 토큰을 발급하였기 때문에 소나큐브와 연계할 수 있도록 프로젝트 폴더에 소나큐브와 관련된 코드를 추가하겠습니다.</p>
<h4 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h4><p>만약, 그래들을 통해 소나큐브와 연동하고 싶다면 build.gradle에 SonarQube 플러그인을 추가해야합니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&quot;org.sonarqube&quot;</span> version <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;jacoco&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sonarqube &#123;</span><br><span class="line">  properties &#123;</span><br><span class="line">    property <span class="string">&quot;sonar.projectKey&quot;</span>, <span class="string">&quot;spring5-web-example&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sonar-project-properties"><a href="#sonar-project-properties" class="headerlink" title="sonar-project.properties"></a>sonar-project.properties</h4><p>sonar-project.properties 파일은 소나큐브에서 참조하게 되는 설정 파일입니다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">sonar.projectKey=spring5-web-example</span></span><br><span class="line"><span class="string">sonar.projectName=spring5-web-example</span></span><br><span class="line"><span class="string">sonar.java.source=1.11</span></span><br><span class="line"><span class="string">sonar.sources=src/main/java</span></span><br><span class="line"><span class="comment">#sonar.tests=src/main/test</span></span><br><span class="line"><span class="string">sonar.java.binaries=build/classes/java/main/com/example</span></span><br><span class="line"><span class="string">sonar.sourceEncoding=UTF-8</span></span><br><span class="line"><span class="string">sonar.exclusions=</span></span><br></pre></td></tr></table></figure>

<h2 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h2><p><a href="https://github.com/kitabisa/sonarqube-action">SonarQube GitHub Action</a>은 Github Action을 통해 소나큐브로 정적 분석을 수행할 수 있도록 지원합니다.</p>
<h3 id="소나큐브-워크플로우-코드-추가"><a href="#소나큐브-워크플로우-코드-추가" class="headerlink" title="소나큐브 워크플로우 코드 추가"></a>소나큐브 워크플로우 코드 추가</h3><p><strong>.github/workflows/sonarqube.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># schedule:</span></span><br><span class="line">    <span class="comment"># - cron: &#x27;0 * * * 1&#x27;</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">SonarQube</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">1.11</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">AdoptOpenJDK/install-jdk@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">        <span class="attr">architecture:</span> <span class="string">x64</span></span><br><span class="line">        <span class="attr">targets:</span> <span class="string">&#x27;JAVA_HOME&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Grant</span> <span class="string">execute</span> <span class="string">permission</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">./gradlew</span> <span class="string">build</span> <span class="string">-x</span> <span class="string">test</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">build/classes</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">sonarQube:</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">build</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">SonarQube</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Donwload</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/download-artifact@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">build/classes</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SonarQube</span> <span class="string">Scan</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">kitabisa/sonarqube-action@master</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SONAR_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">login:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SONAR_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">projectBaseDir:</span> <span class="string">&#x27;/github/workspace&#x27;</span></span><br></pre></td></tr></table></figure>

<p>소나큐브 워크플로우 파일을 깃허브 리파지토리의 메인 또는 마스터 브랜치에 반영하면 깃허브에서 워크플로우를 등록합니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-04.png"></p>
<h3 id="소나큐브-관련-시크릿-생성"><a href="#소나큐브-관련-시크릿-생성" class="headerlink" title="소나큐브 관련 시크릿 생성"></a>소나큐브 관련 시크릿 생성</h3><p>소나큐브 워크플로우에서 사용하는 두가지 시크릿을 깃허브 리파지토리에 설정해야합니다.</p>
<ul>
<li>SONAR_HOST : 소나큐브 호스트 주소</li>
<li>SONAR_TOKEN : 소나큐브에서 발급한 토큰 정보</li>
</ul>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-05.png"></p>
<h3 id="소나큐브-워크플로우-실행"><a href="#소나큐브-워크플로우-실행" class="headerlink" title="소나큐브 워크플로우 실행"></a>소나큐브 워크플로우 실행</h3><p>소나큐브 워크플로우 설정이 완료되었으므로 메인 브랜치를 기준으로 워크플로우를 실행합니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-06.png"></p>
<p>프로젝트 코드에 대한 빌드가 정상적으로 수행되고 소나큐브 서버를 통해 정적 분석을 수행되었다면 다음과 같이 워크플로우가 정상적으로 완료됩니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-07.png"></p>
<h2 id="정적-분석-결과"><a href="#정적-분석-결과" class="headerlink" title="정적 분석 결과"></a>정적 분석 결과</h2><p>소나큐브 시스템에 접속하여 소나큐브 워크플로우를 실행한 프로젝트의 정적 분석 결과를 확인합니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-08.png"></p>
<p>빌드 테스트는 수행하지 않았기 때문에 코드 커버리지는 분석할 수 없었으나 10개의 코드 악취가 발견되었습니다.</p>
<h3 id="코드-악취-검토-및-개선"><a href="#코드-악취-검토-및-개선" class="headerlink" title="코드 악취 검토 및 개선"></a>코드 악취 검토 및 개선</h3><p>정적 분석 결과로 검출된 코드 악취에 대한 내용을 검토하고 이를 개선해보겠습니다.</p>
<h4 id="코드-악취"><a href="#코드-악취" class="headerlink" title="코드 악취"></a>코드 악취</h4><p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-09.png"></p>
<p>첫번째 검출 항목은 연속된 라인을 주석으로 처리한 부분을 제거해야한다는 것입니다. </p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-10.png"></p>
<p>만약, 이렇게 주석되어있는 것이 남아있어야 한다고 가정하면 다음과 같이 프로젝트에 대한 검출 규칙을 변경할 수 있습니다.</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ignore Rules</span></span><br><span class="line"><span class="meta">sonar.issue.ignore.multicriteria</span>=<span class="string">e1,e2</span></span><br><span class="line"><span class="meta">sonar.issue.ignore.multicriteria.e1.ruleKey</span>=<span class="string">java:S125</span></span><br><span class="line"><span class="meta">sonar.issue.ignore.multicriteria.e1.resourceKey</span>=<span class="string">**/*.java</span></span><br><span class="line"><span class="meta">sonar.issue.ignore.multicriteria.e2.ruleKey</span>=<span class="string">java:S1192</span></span><br><span class="line"><span class="meta">sonar.issue.ignore.multicriteria.e2.resourceKey</span>=<span class="string">**/*.java</span></span><br></pre></td></tr></table></figure>

<p>java:S125는 블록으로 된 주석을 남기고 있다는 악취이며 java:S1192는 동일한 문자열을 상수로 취급하지 않는다는 악취입니다. 저는 이것을 악취로 보지 않기 위해서 위와 같이 설정하고 소나큐브 워크플로우를 다시 수행해보겠습니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-11.png"></p>
<p>기존에 검출되었던 코드 악취 중 java:S125와 java:S1192에 해당하는 부분이 제외되어 3개의 코드 악취가 줄어들었음을 확인할 수 있습니다. 이렇게 회사 또는 개발팀에서 프로젝트 코드에 대한 규칙을 검토하는 과정을 거쳐야합니다만 저희 회사는 정작 그러지 않고 있어 아쉬움이 많습니다. 체계가 없다보니 무언가 도입을 원하지만 실제로는 제대로 활용하지 않는게 많은 것 같아요.</p>
<p>아무튼 나머지 코드 악취에 대해서도 리팩토링을 수행하여 없애보도록 하면서 마치겠습니다.</p>
<p><img data-src="/images/posts/sonarqube-and-github-action/sonarqube-12.png"></p>
<h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><p>sonar-project.properties에서 제외되도록 정의한 규칙이 패턴에 의한 것이라면 특정 클래스 또는 함수 단위로 규칙을 제외하고 싶은 경우 @SuppressWarnings을 사용할 수 있습니다. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;squid:S125&quot;,&quot;squid:S1192&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>SonarQube</tag>
        <tag>Github Action</tag>
      </tags>
  </entry>
  <entry>
    <title>프로젝트의 노드 버전 제한하기</title>
    <url>/strict-nodejs-version-for-project/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 함께 일하는 개발자들이 프로젝트마다 사용해야하는 노드 버전을 제한하는 방법에 대하여 공유하려고 해요.</p>
<h2 id="프로젝트-노드-버전-제한"><a href="#프로젝트-노드-버전-제한" class="headerlink" title="프로젝트 노드 버전 제한"></a>프로젝트 노드 버전 제한</h2><p>프로젝트에서 사용하는 패키지마다 지원하는 최소 노드 버전이 다를 수 있습니다. 예를 들어, 다음과 같이 패키지 버전이 업데이트되면서 요구하는 노드 버전이 변경될 수 있습니다.</p>
<ul>
<li><a href="https://webpack.js.org/blog/2020-10-10-webpack-5-release/#minimum-nodejs-version">webpack@5.0.0</a> minimum supported Node.js version is 10.13.0</li>
<li><a href="https://github.com/webpack-contrib/style-loader/releases/tag/v3.0.0">style-loader@3.0.0</a> minimum supported Node.js version is 12.13.0</li>
<li><a href="https://github.com/webpack/webpack-dev-server/blob/master/CHANGELOG.md#400-beta3-2021-05-06">webpack-dev-server@4.0.0-beta.3</a> minimum supported Node.js version is 12.13.0</li>
</ul>
<h3 id="Package-json"><a href="#Package-json" class="headerlink" title="Package.json"></a>Package.json</h3><p>Package.json 파일의 <code>engines</code> 속성으로 프로젝트에서 사용하는 NPM 또는 노드 버전을 명시할 수 있습니다.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;engines&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;npm&quot;</span>: <span class="string">&quot;&gt;=6.4.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;node&quot;</span>: <span class="string">&quot;&gt;=12.13.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="엔진-제한-옵션-활성화"><a href="#엔진-제한-옵션-활성화" class="headerlink" title="엔진 제한 옵션 활성화"></a>엔진 제한 옵션 활성화</h3><p>Package.json 파일에 노드 버전을 명시하더라도 사용자의 엔진을 제한할 수는 없습니다. 이를 별도로 제한하기 위해서는 프로젝트 폴더에 .npmrc 파일을 만들고 <code>engine-strict</code> 옵션을 활성화해야합니다.</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">engine-strict</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h3 id="노드-엔진-제한-여부-확인"><a href="#노드-엔진-제한-여부-확인" class="headerlink" title="노드 엔진 제한 여부 확인"></a>노드 엔진 제한 여부 확인</h3><p>노드 버전을 명시하고 엔진 제한 옵션을 활성화하였으므로 실제로 노드 엔진이 제한되는지 확인해보겠습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm ERR! code ENOTSUP</span><br><span class="line">npm ERR! notsup Unsupported engine <span class="keyword">for</span> @1.0.0: wanted: &#123;<span class="string">&quot;npm&quot;</span>:<span class="string">&quot;&gt;=6.4.1&quot;</span>,<span class="string">&quot;node&quot;</span>:<span class="string">&quot;&gt;=12.13.0&quot;</span>&#125; (current: &#123;<span class="string">&quot;node&quot;</span>:<span class="string">&quot;10.23.0&quot;</span>,<span class="string">&quot;npm&quot;</span>:<span class="string">&quot;6.14.8&quot;</span>&#125;)</span><br><span class="line">npm ERR! notsup Not compatible with your version of node/npm: @1.0.0</span><br><span class="line">npm ERR! notsup Not compatible with your version of node/npm: @1.0.0</span><br><span class="line">npm ERR! notsup Required: &#123;<span class="string">&quot;npm&quot;</span>:<span class="string">&quot;&gt;=6.4.1&quot;</span>,<span class="string">&quot;node&quot;</span>:<span class="string">&quot;&gt;=12.13.0&quot;</span>&#125;</span><br><span class="line">npm ERR! notsup Actual:   &#123;<span class="string">&quot;npm&quot;</span>:<span class="string">&quot;6.14.8&quot;</span>,<span class="string">&quot;node&quot;</span>:<span class="string">&quot;10.23.0&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>현재 사용중인 노드 버전은 10.23.0 이지만 프로젝트에서 요구하는 버전은 12.13.0 이상이므로 오류가 발생하였습니다.</p>
<p>이상으로 프로젝트에서 지원하는 최소 노드 엔진 버전을 명시하고 프로젝트에 참여하는 모든 개발자들이 알맞은 노드 버전을 사용하도록 안내할 수 있게 되었습니다.</p>
<p>감사합니다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://medium.com/@fabian.illner/force-correct-node-js-version-with-npm-a2a57fd12fa">Force correct Node.js version with npm</a>  </li>
<li><a href="https://www.geeksforgeeks.org/how-to-define-the-required-node-js-version-in-package-json/">How to define the required Node.js version in package.json?</a>  </li>
<li><a href="https://reactgo.com/specify-node-version/">Specifying a required Node.js version in Package.json file</a>  </li>
</ul>
]]></content>
      <tags>
        <tag>package.json</tag>
        <tag>npmrc</tag>
        <tag>engines</tag>
      </tags>
  </entry>
  <entry>
    <title>장애는 사소한 것에서 발생한다</title>
    <url>/system-failure-occurs-from-trivial-things/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>갑작스럽게 발생하는 시스템 장애는 늘 개발자를 힘겹게 합니다.<br>오늘은 사소한 것으로부터 발생한 시스템 장애에 대한 경험을 공유하고자 합니다.</p>
<h2 id="시스템-장애"><a href="#시스템-장애" class="headerlink" title="시스템 장애"></a>시스템 장애</h2><p>현재 조직에서는 시계열 데이터에 대한 관리 및 통계를 위해서 컬럼형 시계열 데이터베이스인 <a href="https://kx.com/">KDB+</a>를 사용하고 있습니다. 그리고 분산으로 실행되어있는 애플리케이션에서 RDBMS에서 조회된 일부 데이터를 컬럼형 시계열 데이터베이스로 동기화하는 스케줄이 동작합니다. 그런데 스케줄로 인하여 데이터가 동기화 된 이후에 컬럼형 시계열 데이터베이스에 있는 동기화된 데이터가 조금씩 사라지기 시작하고 동기화된 모든 데이터가 삭제되는 현상이 발생하였습니다.</p>
<h3 id="원인-분석"><a href="#원인-분석" class="headerlink" title="원인 분석"></a>원인 분석</h3><p>처음에는 동기화된 데이터가 저장되는 테이블에 데이터가 없다는 것을 보고받고 시스템 계정으로 접속하여 수동으로 해당 스케줄을 동작하여 데이터를 복구하였습니다. 그러나 해당 스케줄은 5분마다 동작하고 해당 스케줄이 돌게되면 데이터가 점점 없어지는 것을 확인하였습니다. 해당 스케줄이 동작하고나서 <strong>수동으로 동작시키고 난 후에는</strong> 데이터가 사라지는 현상이 나타나지 않았습니다.</p>
<p><img data-src="/images/posts/system-failure-occurs-from-trivial-things/01.gif" alt="똑같은 스케줄 동작인데?..."></p>
<p>결국 시계열 데이터베이스가 설치된 인스턴스로 접속하여 로그를 살펴보니 스케줄이 동작하고 데이터 저장을 완료했다는 로그 이후에 또다른 로그가 기록되더니 무수히 많은 <strong>잘못된 유형(`type)이라는 불친절한 오류 로그</strong>를 확인하게 됩니다. 그리고 이번주 작업으로 특정 컬럼의 유형을 바꾸어야하는 요구사항에 대한 처리를 했다는 것도 인지하게 됩니다. 다만, 이 작업은 개발 환경에서 작업하였고 아직 배포전이므로 실행중인 애플리케이션에는 해당되지 않았습니다.</p>
<h3 id="문제-해결"><a href="#문제-해결" class="headerlink" title="문제 해결"></a>문제 해결</h3><p>그러던 중 스케줄은 환경별로 독립적으로 실행되도록 구성되어있다는 점을 떠올리게 됩니다. 즉, 로컬 환경 프로파일로 실행하면 로컬 환경에서만 독립적이라는 이야기죠. 그리고 누군가 로컬 소스코드 기준으로 (장애가 발생한) 특정 배포 환경에 연결한게 아닌가 의심하였고 조직에서 사용하는 메신저 채널인 슬랙에 알려보았습니다. 슬쩍 손을 드신분은 마침 휴가를 쓰신 팀장님이었고 원격으로 팀장님 컴퓨터에 실행중인 애플리케이션을 중지해달라고 요청했고 장애는 자연스럽게 해결되었습니다.</p>
<p><img data-src="/images/posts/system-failure-occurs-from-trivial-things/02.gif#compact" alt="어쨌든 범인 검거..."></p>
<h3 id="장애-대응-소감"><a href="#장애-대응-소감" class="headerlink" title="장애 대응 소감"></a>장애 대응 소감</h3><p>다행히도 지워지던 데이터는 중요한 데이터가 아니라 프론트엔드에서 통계 표시를 위한 기준 테이블이어서 일부 데이터가 표시되지 않는 사소한 장애였습니다. 그럼에도 불구하고 장애를 판단하고 원인을 분석하여 해결하기까지는 생각보다 쉽지 않았던 것 같습니다. 사실 이 장애는 모니터링 체계를 도입하더라도 검출되지 않는 사소하지 않는 장애이기도 합니다. 그리고 이 장애를 보다보니 유튜브 개발바닥에 공유된 <a href="https://youtu.be/SWZcrdmmLEU">재난급 서버 장애내고 개발자 인생 끝날뻔 한 썰</a>이 떠오르는 것 같습니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>System Failure</tag>
        <tag>Troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>Github의 Git 작업에 대한 토큰 인증 요구 사항</title>
    <url>/token-authentication-requirements-for-git-operations-on-github/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 변경된 사항을 깃허브 저장소에 반영시키기 위하여 깃 명령어를 수행할 때 사용되는 인증 방식을 비밀번호가 아닌 액세스 토큰으로 변경하는 것에 대해서 공유하려합니다. </p>
<p><img data-src="/images/posts/token-authentication-requirements/windows-git-credentials-01.png"></p>
<p>2020년 12월 15일에 깃허브에서는 <a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">Token authentication requirements for Git operations</a>을 통해 2021년 8월 13일에 더이상 비밀번호 인증 방식으로 Git 작업을 수행할 수 없다고 알려주었으며 비밀번호를 사용하는 개발자들에게 지속적으로 Deprecation Notice 메일을 발송해왔습니다.</p>
<p>저는 이 문제에 대하여 당장은 변경하지않아도 무방하다고 생각하여 무시하였지만 이제는 비밀번호를 사용하여 인증할 수 없게되어 우리는 비밀번호가 아닌 깃허브에서 발급받은 토큰을 사용하도록 변경해야합니다.</p>
<h2 id="Git-Credential-Helper"><a href="#Git-Credential-Helper" class="headerlink" title="Git Credential Helper"></a>Git Credential Helper</h2><p>깃에서 사용하는 크레덴셜을 어떻게 저장했는지 기억나지 않으므로 찾아보니 깃 크레덴셜 헬퍼를 사용한다고 합니다. 그리고 윈도우에서 사용하는 크레덴셜 헬퍼는 <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows">Git Credential Manager for Windows</a>에서 <a href="https://github.com/microsoft/Git-Credential-Manager-Core">Git Credential Manager Core</a>되어 크로스 플랫폼으로 통합된 것 같습니다.</p>
<p><img data-src="/images/posts/token-authentication-requirements/windows-git-credentials-02.png"></p>
<p>위 스크린샷에서 확인할 수 있듯이 윈도우에서 크레덴셜 저장소는 <strong>자격 증명 관리자</strong>를 사용한다고 합니다. 제어판에서 자격 증명 관리자를 열어보면 일반 자격 증명 항목에 Github 관련 자격 증명이 있는 것을 확인할 수 있을겁니다.</p>
<p><img data-src="/images/posts/token-authentication-requirements/windows-git-credentials-03.png"></p>
<p>비밀번호가 저장되어있는 Github 자격 증명을 선택해서 삭제하시면 됩니다. </p>
<h3 id="Manager-Core"><a href="#Manager-Core" class="headerlink" title="Manager Core"></a>Manager Core</h3><p>윈도우에 설치된 Git 버전이 2.29 이상이라면 깃 크레덴셜 헬퍼를 초기화하고 Manager Core로 지정하는게 좋다고 생각되므로 다음과 같이 명령어를 수행합니다.</p>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">git -<span class="literal">-version</span></span><br><span class="line">git version <span class="number">2.32</span>.<span class="number">0</span>.windows.<span class="number">2</span></span><br><span class="line"></span><br><span class="line">git config -<span class="literal">-unset</span> credential.helper</span><br><span class="line">git config -<span class="literal">-global</span> credential.helper manager<span class="literal">-core</span></span><br><span class="line">git config -<span class="literal">-global</span> credential.helper</span><br><span class="line">manager<span class="literal">-core</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>이미 깃 크레덴셜 헬퍼가 manager-core로 지정되어있다면 스킵하세요.</p>
</blockquote>
<h3 id="Token-Credential"><a href="#Token-Credential" class="headerlink" title="Token Credential"></a>Token Credential</h3><p>이제 리파지토리 폴더에서 깃허브를 대상으로 깃 명령어를 수행하면 깃허브 주소에 대한 자격 증명이 존재하지 않으므로 다음과 같이 크레덴셜을 요구하는 팝업창이 뜨게 됩니다.</p>
<p><img data-src="/images/posts/token-authentication-requirements/windows-git-credentials-04.png"></p>
<p>깃허브에서 발급받은 토큰을 입력하면 자격 증명 관리자에 깃허브 주소에 대한 자격 증명이 등록되고 성공적으로 깃 명령어를 수행되는 것을 확인할 수 있을겁니다.</p>
<h3 id="SourceTree-Authentication"><a href="#SourceTree-Authentication" class="headerlink" title="SourceTree Authentication"></a>SourceTree Authentication</h3><p>만약, 소스트리를 사용하고 계시다면 설정 &gt; 옵션 &gt; 인증에서 정상적으로 자격 증명을 확인할 수 있는 지 확인해보셔야합니다.</p>
<p><img data-src="/images/posts/token-authentication-requirements/windows-git-credentials-05.png"></p>
<p>이상으로 Github의 Git 작업에 대한 토큰 인증 요구 사항을 마치겠습니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Github</tag>
        <tag>Git Credentials</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsupported allowDuplicateContentLengths in Spring Cloud Gateway of Hoxton Version</title>
    <url>/unsupported-allowduplicatecontentlength-in-spring-cloud-gateway-of-hoxton-version/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 스프링 클라우드 게이트웨이에서 발생하는 Content-Length 헤더의 값이 단일이 아닌 복수로 지정될 때 발생하는 오류에 대해 다루어보려고 합니다.</p>
<h2 id="RFC-7230"><a href="#RFC-7230" class="headerlink" title="RFC 7230"></a>RFC 7230</h2><p><a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2">RFC 7230 - 3.3.2. Content-Length</a>를 참고해보면 다른 헤더들과는 다르게 Content-Length 헤더는 단일로 구성되어야 한다고 규정합니다. 다만, 다음과 내용을 통해 Content-Length 헤더 값이 복수로 구성되는 경우는 수신자가 오류로 처리하거나 단일 값으로 처리해야한다고 설명하고 있습니다.</p>
<blockquote>
<p>If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g., “Content-Length: 42, 42”), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.</p>
</blockquote>
<h2 id="오류-및-원인-분석"><a href="#오류-및-원인-분석" class="headerlink" title="오류 및 원인 분석"></a>오류 및 원인 분석</h2><p>스프링 클라우드 게이트웨이에서 발생한 오류에 대한 내용은 <a href="https://github.com/spring-cloud/spring-cloud-gateway/issues/2465">Multiple Content-Length values found: [229455, 229455]</a>에서 확인할 수 있습니다.</p>
<p>모든 스프링 클라우드 게이트웨이 버전에서 발생하는 상황은 아니었으며 스프링 부트 2.3.x와 호환성이 검증된 스프링 클라우드 Hoxton 릴리즈 트레인으로 관리되는 스프링 클라우드 게이트웨이 서버에서 발생하였습니다. Content-Length 헤더 값이 복수로 지정되는 것은 브라우저에서 실행간으한 wav, mp3, webm 파일을 요청할 때 발생한 것으로 일반적인 curl 또는 Postman을 통해서는 정상적으로 응답이 수행되었습니다.</p>
<h3 id="HttpUtil-normalizeAndGetContentLength"><a href="#HttpUtil-normalizeAndGetContentLength" class="headerlink" title="HttpUtil#normalizeAndGetContentLength"></a>HttpUtil#normalizeAndGetContentLength</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Multiple Content-Length values found: [<span class="number">229455</span>, <span class="number">229455</span>]</span><br><span class="line">	at io.netty.handler.codec.http.HttpUtil.normalizeAndGetContentLength(HttpUtil.java:<span class="number">595</span>) ~[netty-codec-http-<span class="number">4.1</span><span class="number">.65</span>.Final.jar:<span class="number">4.1</span><span class="number">.65</span>.Final]</span><br><span class="line">	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: </span><br><span class="line"><span class="function">Error has been observed at the following <span class="title">site</span><span class="params">(s)</span>:</span></span><br></pre></td></tr></table></figure>

<p>위 스택트레이스 내용에 따르면 Netty 라이브러리의 netty-codec-http 모듈에서 HttpUtil.normalizeAndGetContentLength 함수로 처리될 때 오류가 던져졌음을 확인할 수 있습니다. 또한, netty-codec-http 모듈의 <a href="https://github.com/netty/netty/blob/c08beb543a6b8db0c7f3cee225042361b4025e4c/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java#L555-L560">HttpUtil#normarlizeAndGetContentLength</a>에는 allowDuplicateContentLengths 파라미터를 통해 복수의 동일한 값이 지정되더라도 단일 값으로 처리되도록 구현되어있는 상태입니다.</p>
<h3 id="Reactor-Netty-HttpDecoderSpec"><a href="#Reactor-Netty-HttpDecoderSpec" class="headerlink" title="Reactor Netty - HttpDecoderSpec"></a>Reactor Netty - HttpDecoderSpec</h3><p>이미 allowDuplicateContentLengths 옵션을 지원하는데도 불구하고 스프링 클라우드 Hoxton 버전에서 의존하는 reactor-netty:0.9.x.RELEASE 에서는 HttpDecoderSpec 클래스가 allowDuplicateContentLengths 옵션을 지원하지 않았습니다.</p>
<p>더 자세한 정보를 찾아본 결과 HttpDecoderSpec에서 allowDuplicateContentLengths 옵션이 지원되는 것은 <a href="https://github.com/reactor/reactor-netty/pull/1638/commits/978ba8a737f26376d1caab4806e25420e7aac7b7">Add HttpDecoderSpec#allowDuplicateContentLengths(boolean) #1638</a>으로 처리되었으며 <a href="https://github.com/reactor/reactor-netty/releases/tag/v1.0.8">Reactor Netty 1.0.8</a>에서부터 추가되어 반영되었음을 확인할 수 있었습니다. 그러나 위 반영 내용은 Reactor Netty 0.9.x 사용자들을 위한 Dysprosium 릴리즈 트레인에서 <a href="https://github.com/reactor/reactor-netty/releases/tag/v0.9.25.RELEASE">Reactor Netty 0.9.25.RELEASE</a>로 릴리즈 계획이 종료되기까지 반영되지 않은 사항입니다. </p>
<blockquote>
<p>Reactor Netty 0.9.x 사용자들을 위해 allowDuplicateContentLengths 옵션 지원을 반영할 수 있는지 <a href="https://github.com/reactor/reactor-netty/issues/1942">allowDuplicateContentLengths for Reactor Netty 0.9.x users #1942</a> 이슈를 등록해두었습니다. 이 이슈가 처리되기전까지는 HttpDecoderSpec에서 allowDuplicateContentLengths 파라미터를 활성화할 수 없습니다.</p>
</blockquote>
<h2 id="해결방안"><a href="#해결방안" class="headerlink" title="해결방안"></a>해결방안</h2><p>Content-Length 헤더에 중복된 동일한 값이 설정되는 문제를 해결하기 위해서는 allowDuplicateContentLengths 옵션이 적용될 수 있도록 해야만합니다. 스프링 클라우드 게이트웨이 서버 스타터에서 자동 구성할 때 HttpClient에 대한 HttpClientCustomizer를 지원함에도 불구하고 의존하고 있는 HttpDecoderSpec에서 allowDuplicateContentLengths를 적용할 수 있어야만 합니다. 따라서, Reactor Netty 의존성 버전을 1.0.8 이상으로 변경할 수 밖에 없습니다.</p>
<h3 id="첫번째-시도-Reactor-Bom-변경"><a href="#첫번째-시도-Reactor-Bom-변경" class="headerlink" title="첫번째 시도 - Reactor Bom 변경"></a>첫번째 시도 - Reactor Bom 변경</h3><p>혹시나 Reactor Netty 의존성 버전을 변경하여 가능할지도 모른다는 생각으로 버전 업그레이드를 시도해보았습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    set(<span class="string">&#x27;springCloudVersion&#x27;</span>, <span class="string">&#x27;Hoxton.SR12&#x27;</span>),</span><br><span class="line">    set(<span class="string">&#x27;reactorNettyVersion&#x27;</span>, <span class="string">&#x27;2020.0.8&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">    imports &#123;</span><br><span class="line">        mavenBom <span class="string">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span></span><br><span class="line">        mavenBom <span class="string">&quot;io.projectreactor:reactor-bom:$&#123;reactorNettyVersion&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reactor Netty 버전을 변경하기 위해 Reactor Bom을 적용해본 결과 다음과 같이 reactor.netty.tcp.ProxyProvider를 클래스로더에서 찾을 수 없는 상태가 되었습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: reactor/netty/tcp/ProxyProvider$Builder</span><br><span class="line">	at java.base/java.lang.Class.getDeclaredMethods0(Native Method) ~[na:na]</span><br><span class="line">	at java.base/java.lang.Class.privateGetDeclaredMethods(Class.java:<span class="number">3166</span>) ~[na:na]</span><br><span class="line">	at java.base/java.lang.Class.getDeclaredMethods(Class.java:<span class="number">2309</span>) ~[na:na]</span><br><span class="line">	at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:<span class="number">463</span>) ~[spring-core-<span class="number">5.2</span><span class="number">.15</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.15</span>.RELEASE]</span><br><span class="line">	... <span class="number">19</span> common frames omitted</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: reactor.netty.tcp.ProxyProvider$Builder</span><br><span class="line">	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:<span class="number">581</span>) ~[na:na]</span><br><span class="line">	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:<span class="number">178</span>) ~[na:na]</span><br><span class="line">	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">522</span>) ~[na:na]</span><br><span class="line">	... <span class="number">23</span> common frames omitted</span><br></pre></td></tr></table></figure>

<p>이러한 문제가 발생하는 이유는 <a href="https://github.com/reactor/reactor-netty/releases/tag/v1.0.0">Reactor Netty 1.0.0</a>에서부터 reactor.netty.tcp.ProxyProvider가 reactor.netty.transport.ProxyProvider로 변경되었기 때문입니다. 스프링 클라우드 Hoxton에서는 Reactor Netty 0.9.x의 클래스들을 사용하기 때문에 단순하게 Reactor Netty 의존성 버전을 변경할 수는 없습니다.</p>
<h3 id="두번째-시도-Spring-Cloud-버전-업그레이드"><a href="#두번째-시도-Spring-Cloud-버전-업그레이드" class="headerlink" title="두번째 시도 - Spring Cloud 버전 업그레이드"></a>두번째 시도 - Spring Cloud 버전 업그레이드</h3><p>Reactor Netty 1.0.8을 사용하기 위해서는 스프링 클라우드 2020.0.x aka Ilford 릴리즈 트레인의 스프링 클라우드와 함께 스프링 부트 2.4.x로 업그레이드해야합니다. 테스트 중인 프로젝트에서는 그래들 멀티 프로젝트로 구성되어 스프링 클라우드 게이트웨이 서버와 애플리케이션 서버가 동일한 스프링 부트 버전을 사용하고 있었습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;rog.springframework.boot&#x27;</span> version <span class="string">&#x27;2.4.13&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">ext &#123;</span><br><span class="line">    set(<span class="string">&#x27;springCloudVersion&#x27;</span>, <span class="string">&#x27;2020.0.0&#x27;</span>),</span><br><span class="line">    set(<span class="string">&#x27;reactorNettyVersion&#x27;</span>, <span class="string">&#x27;2020.0.8&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">    imports &#123;</span><br><span class="line">        mavenBom <span class="string">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span></span><br><span class="line">        mavenBom <span class="string">&quot;io.projectreactor:reactor-bom:$&#123;reactorNettyVersion&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>스프링 부트 2.4 부터 변경된 사항에 대해서 검토하여야합니다.</p>
</blockquote>
<p>아쉽게도 스프링 부트 버전과 스프링 클라우드 버전을 업그레이드 하고나서는 Content-Length에 복수로 설정되던 파일들이 정상적으로 단일 값으로 처리되어 allowDuplicateContentLengths 적용이 필요하지 않은 상태가 되었습니다. 만약, allowDuplicateContentLengths 적용이 필요하다면 다음과 같이 HttpClientCustomzier를 통해 구성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyHttpClientCustomizer</span> <span class="keyword">implements</span> <span class="title">HttpClientCustomizer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpClient <span class="title">customize</span><span class="params">(HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> httpClient.httpResponseDecoder(decoderSpec -&gt; </span><br><span class="line">            decoderSpec</span><br><span class="line">                .allowDuplicateContentLengths(<span class="keyword">true</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 내용은 Okky 커뮤니티에 <a href="https://okky.kr/article/1122985">Spring Cloud Hoxton의 Spring Cloud Gateway에서는 allowDuplicateContentLengths을 지원하지 않음</a>로 공유되었음을 알려드리며 마치도록 하겠습니다.</p>
<p>감사합니다.</p>
<blockquote>
<p><a href="https://github.com/reactor/reactor-netty/issues/1942">https://github.com/reactor/reactor-netty/issues/1942</a><br>Reactor Netty 측에 0.9.x 사용자들을 위해 수정 요청하였으나 업데이트 중단된 버전인 사유로 거부되었습니다.</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc7230">RFC 7230</a>  </li>
<li><a href="https://spring.io/projects/spring-cloud">Spring Cloud Release train Spring Boot compatibility</a></li>
<li><a href="https://github.com/spring-cloud/spring-cloud-gateway">spring-cloud/spring-cloud-gateway</a></li>
<li><a href="https://github.com/reactor/reactor-netty/releases/tag/v1.0.8">Reactor Netty 1.0.8 Release</a></li>
</ul>
]]></content>
      <tags>
        <tag>Spring Cloud Gateway</tag>
        <tag>RFC 7230</tag>
        <tag>Reactor Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Pushgateway를 활용하여 사설망 인스턴스 모니터링하기</title>
    <url>/using-pushgateway-to-monitor-private-network-instance/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다. 오늘은 Promethues의 Pushgateway를 왜 사용해야하는지에 대해서 알아보려고 합니다.</p>
<p>프로메테우스(Promethues)는 기본적으로 매트릭 지표를 제공하는 서버에게 주기적으로 요청하여 매트릭을 수집하도록 되어있습니다. 그래서 매트릭을 수집하기 위해서는 프로메테우스가 수집해야할 설정 파일에 매트릭 수집을 위한 주소를 입력해야합니다. 하지만 모든 인스턴스가 외부 인터넷망을 통해 접근할 수 있는 공인 IP를 할당하지는 않습니다. 또한, 클라우드를 통해 애플리케이션을 운영하는 경우에도 외부로 나가는 트래픽은 허용하지만 외부에서 내부로 들어오는 트래픽은 특정 IP 대역에서만 접근할 수 있도록 보안 규칙을 설정하기도 합니다.</p>
<p>사설망에 있는 인스턴스는 내부 아이피만 할당되어있고 외부 인터넷망과의 통신은 별도의 장비를 통해 수행합니다. 이 경우 인스턴스에는 공인 IP가 할당되어있지 않기 때문에 프로메테우스에 주소를 입력할 수 없는 상황이 됩니다. 그래서 Polling 방식이 아닌 프로메테우스에 매트릭을 Push 할 수 있도록 해야합니다. 매트릭을 푸시할 수 있도록 지원하는게 바로 <code>Pushgateway</code> 입니다.</p>
<h2 id="Pushgateway"><a href="#Pushgateway" class="headerlink" title="Pushgateway"></a>Pushgateway</h2><p>프로메테우스에서 제공하는 <a href="https://github.com/prometheus/pushgateway">Pushgateway</a>는 매트릭을 푸시할 수 있도록 지원하며 푸시된 매트릭을 프로메테우스에서 가져갈 수 있도록 중개자 역할을 수행합니다. 따라서, Pushgateway에 푸시된 매트릭을 프로메테우스에서 가져갈 수 있습니다.</p>
<h3 id="How-to-install-Pushgateway"><a href="#How-to-install-Pushgateway" class="headerlink" title="How to install Pushgateway"></a>How to install Pushgateway</h3><p>Pushgateway는 운영체제별 바이너리 파일을 받아 설치할 수 있습니다. 저는 운영체제에 상관없이 실행하기 위하여 바이너리 파일이 아닌 도커를 사용하여 Pushgateway를 실행하도록 하겠습니다.</p>
<figure class="highlight yaml"><figcaption><span>pushgateway/docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">pushgateway:</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">pushgateway</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">prom/pushgateway:latest</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">9091</span><span class="string">:9091</span></span><br></pre></td></tr></table></figure>

<h4 id="Optinal-Listening-Port"><a href="#Optinal-Listening-Port" class="headerlink" title="(Optinal) Listening Port"></a>(Optinal) Listening Port</h4><p>Pushgatway는 기본적으로 9091 포트를 할당합니다.<br>만약, 9091 포트가 이미 사용중이라면 <code>web.listen-address</code> 플래그를 설정해야합니다.</p>
<h4 id="Optional-Enable-Persistence-Mode"><a href="#Optional-Enable-Persistence-Mode" class="headerlink" title="(Optional) Enable Persistence Mode"></a>(Optional) Enable Persistence Mode</h4><p>기본적으로 Pushgateway는 푸시된 매트릭을 저장하지 않습니다.<br>만약, Pushgateway가 예기치 못하게 중단되더라도 푸시된 매트릭을 유지하고 싶다면 <code>persistence.file</code> 플래그로 푸시된 매트릭을 저장할 파일을 지정해야합니다.</p>
<h4 id="Optional-TLS-and-basic-authentication"><a href="#Optional-TLS-and-basic-authentication" class="headerlink" title="(Optional) TLS and basic authentication"></a>(Optional) TLS and basic authentication</h4><p>Pushgateway는 TLS 및 기본 인증을 지원합니다. 이를 설정하기 위해서는 <code>web.config.file</code> 플래그에 <a href="https://github.com/prometheus/exporter-toolkit/blob/master/docs/web-configuration.md">Web Configuration</a> 파일을 지정하세요.</p>
<h3 id="Run-Pushgateway"><a href="#Run-Pushgateway" class="headerlink" title="Run Pushgateway"></a>Run Pushgateway</h3><figure class="highlight cmd"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>도커 컴포즈 명령어로 Pushgateway를 실행하고 브라우저를 통해 127.0.0.1:9091로 접근할 수 있습니다.</p>
<p><img data-src="/images/posts/using-pushgateway/pushgateway-01.png" alt="Pushgateway"></p>
<h3 id="How-to-push-metrics"><a href="#How-to-push-metrics" class="headerlink" title="How to push metrics"></a>How to push metrics</h3><p>Pushgateway로 매트릭을 푸시하는 것은 HTTP로 수행할 수 있습니다. 다음의 HTTP 요청 예시를 살펴보시죠.</p>
<figure class="highlight sh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;some_metric 3.14&quot;</span> | curl --data-binary @- http://127.0.0.1:9091/metrics/job/some_job</span><br></pre></td></tr></table></figure>

<p><code>curl</code>과 같은 HTTP 요청 도구로 매트릭을 쉽게 푸시할 수 있으며 윈도우 환경에서는 <a href="https://curl.se/windows/">curl</a>을 다운로드하여 설치하거나 Powershell의 Invoke-WebRequest 명령어로 HTTP 요청을 수행할 수도 있습니다.</p>
<figure class="highlight cmd"><figcaption><span>명령 프롬프트</span></figcaption><table><tr><td class="code"><pre><span class="line">powershell -Command &quot;Invoke-WebRequest -Uri http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9091</span>/metrics/job/some_job -Method POST -Body \&quot;some_metric <span class="number">3</span>.<span class="number">14</span>`n\&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Push-Examples"><a href="#Push-Examples" class="headerlink" title="Push Examples"></a>Push Examples</h3><p>앞서 HTTP 요청을 통해 매트릭을 푸시할 수 있음을 확인했으므로 node_exporter 또는 windows_exporter와 같은 OS 매트릭을 제공하는 Promethues Exporter에서 매트릭을 받아서 Pushgateway에 매트릭을 보내보도록 하겠습니다.</p>
<p>다음처럼 curl를 사용하여 매트릭을 쉽게 Pushgateway로 보낼 수 있습니다.</p>
<figure class="highlight cmd"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">curl -s http://localhost:<span class="number">9100</span>/metrics | curl --data-binary @- http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9091</span>/metrics/job/node-exporter/instance/<span class="number">1</span></span><br><span class="line">curl -s http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9182</span>/metrics | curl --data-binary @- http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9091</span>/metrics/job/windows-exporter/instance/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node Exporter"></a>Node Exporter</h4><p><a href="https://github.com/prometheus/node_exporter">prometheus/node_exporter</a>는 리눅스 커널을 사용하는 OS에 대한 매트릭을 제공합니다. 바이너리 뿐만 아니라 도커 이미지를 제공하므로 컨테이너로 실행할 수 있습니다.</p>
<figure class="highlight yaml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">node-exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/prometheus/node-exporter:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;--path.rootfs=/host&#x27;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">pid:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/:/host:ro,rslave&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Windows-Exporter"><a href="#Windows-Exporter" class="headerlink" title="Windows Exporter"></a>Windows Exporter</h4><p><a href="https://github.com/prometheus-community/windows_exporter">prometheus-community/windows_exporter</a>는 윈도우 머신에 대한 매트릭을 제공합니다. windows_exporter는 파일을 다운로드 받아서 설치하거나 실행해야합니다.</p>
<figure class="highlight cmd"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">.\windows_exporter-<span class="number">0</span>.<span class="number">16</span>.<span class="number">0</span>-<span class="number">386</span>.exe --collectors.enabled &quot;cpu,<span class="built_in">net</span>,cs&quot;</span><br></pre></td></tr></table></figure>

<p>명령어가 정상적으로 수행되었다면 Pushgateway에서 다음과 같이 Exporter로 부터 받은 매트릭이 보내졌음을 확인할 수 있습니다.<br><img data-src="/images/posts/using-pushgateway/pushgateway-03.png"></p>
<h3 id="Pushgateway-with-TTL"><a href="#Pushgateway-with-TTL" class="headerlink" title="Pushgateway with TTL"></a>Pushgateway with TTL</h3><p>Pushgateway는 푸시된 매트릭을 지우지 않습니다. 따라서, 매트릭이 다시 푸시되지 않는다면 Pushgateway는 이전에 푸시된 매트릭을 현재 매트릭 정보로 제공합니다. </p>
<p>몇몇 사용자들이 일정시간이 지나면 매트릭을 지우는 옵션을 적용해달라고 요청하였지만 Pushgateway 개발팀은 적용하지 않는게 맞다고 판단하였습니다.</p>
<blockquote>
<p>A while ago, we decided to not implement a “timeout” or TTL for pushed metrics because almost all proposed use cases turned out to be anti-patterns we strongly discourage.</p>
</blockquote>
<p>만약, 푸시된 매트릭이 일정시간 이후에 지워져야한다면 푸시된 매트릭을 지우도록 DELETE API를 호출하는 배치 작업을 만들어야합니다. 배치를 만들고 싶지 않고 최신 버전을 사용하지 않아도 괜찮다면 Pushgateway를 포크하여 TimeToLive 옵션을 추가한 <a href="https://github.com/dinumathai/pushgateway">pushgateway-ttl</a>을 사용하시는 것을 추천합니다.</p>
<figure class="highlight yaml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">pushgateway-ttl:</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">pushgateway-ttl</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">dmathai/prom-pushgateway-ttl:latest</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">9091</span><span class="string">:9091</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--metric.timetolive=60s&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Promethues-Scrap-Configs"><a href="#Promethues-Scrap-Configs" class="headerlink" title="Promethues Scrap Configs"></a>Promethues Scrap Configs</h3><p>우리는 사설망의 인스턴스에서 Pushgateway로 매트릭을 푸시할 수 있음을 확인하였습니다. 이제는 Pushgateway에 푸시된 매트릭을 프로메테우스에서 가져갈 수 있도록 설정해야합니다. <a href="https://github.com/prometheus/pushgateway#configure-the-pushgateway-as-a-target-to-scrape">Configure the Pushgateway as a target to scrape</a></p>
<figure class="highlight yaml"><figcaption><span>promethues.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;pushgateway&#x27;</span></span><br><span class="line">    <span class="attr">honor_labels:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;pushgateway:9091&#x27;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>honor_labels</code> 항목이 true로 설정되어야한다는 점에 주의하시기 바랍니다.</p>
</blockquote>
<p>프로메테우스가 Pushgateway로부터 매트릭을 수집하였다면 다음과 같이 매트릭을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/using-pushgateway/pushgateway-04.png"></p>
<h3 id="Grafana-Dashboard"><a href="#Grafana-Dashboard" class="headerlink" title="Grafana Dashboard"></a>Grafana Dashboard</h3><p>위 화면에서 확인한 windows_net_bytes_total 매트릭은 windows_expoter로 수집된 매트릭으로 이를 그라파나로 시각화하기 위해 <a href="https://grafana.com/grafana/dashboards/14694">Windows Exporter Dashboardby girb90</a>를 추가하면 다음과 같이 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/using-pushgateway/pushgateway-05.png"></p>
<p>이로써 Pushgateway를 활용해 사설망에 위치한 인스턴스에 대한 모니터링을 수행할 수 있음을 알게되었습니다. 감사합니다.</p>
]]></content>
      <tags>
        <tag>Promethues</tag>
        <tag>Pushgateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 5 기반의 Vue 개발 환경</title>
    <url>/webpack5-for-vue/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 <strong>Webpack 5 기반의 Vue 개발 환경</strong>에 대해서 알아보는 시간을 가져보도록 하겠습니다.<br>본 글에서 설명한 내용에 대한 코드는 <a href="https://github.com/kdevkr/webpack5">kdevkr/webpack5</a>에서 제공합니다.</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>반드시 그런 것은 아니지만 많은 분들이 <a href="https://create-react-app.dev/">Create React App</a> 또는 <a href="https://cli.vuejs.org/">Vue CLI</a>라는 도구를 통해서 프론트엔드 개발 환경에 대한 기본 프리셋을 기반으로 학습을 시작하거나 개발 환경을 구축합니다. 이 도구들은 여러가지 사항에 대한 웹팩 구성을 기본적으로 제공함으로써 웹팩에 대한 내용을 알지 못하더라도 쉽게 리액트 또는 뷰에 대한 학습을 진행할 수 있게 도와주는 유용한 도구입니다. </p>
<p>그럼에도 불구하고, 실무 환경에서는 이 도구들을 사용하지 않고 직접 웹팩 설정에 대해 구성하여 사용합니다. 또한, Vue CLI는 안타깝게도 웹팩 4에 대한 구성을 제공하므로 이 도구로 만들어지는 환경은 무조건 웹팩 4로 제한되는 문제점을 가지고 있습니다. <a href="https://webpack.js.org/blog/2020-10-10-webpack-5-release/">2020년 10월에 릴리즈된 웹팩 5</a> 기반의 개발 환경을 만들기 위해서는 직접 웹팩 구성을 수행할 수 있어야만 합니다.</p>
<h3 id="요구사항"><a href="#요구사항" class="headerlink" title="요구사항"></a>요구사항</h3><p>시작하기에 앞서, 웹팩 5는 노드 10.13.0 이상의 버전을 요구하며 함께 개발 프록시 서버로 활용할 수 있는 webpack-dev-server@4 에서는 노드 12.13.0 이상을 요구합니다. </p>
<ul>
<li>Webpack5 required v10.13.0+</li>
<li>webpack-dev-server@4 v12.13.0+</li>
</ul>
<h4 id="프로젝트-노드-버전-제한"><a href="#프로젝트-노드-버전-제한" class="headerlink" title="프로젝트 노드 버전 제한"></a>프로젝트 노드 버전 제한</h4><p>위 요구사항에 따라 프로젝트에서 사용할 수 있는 노드 버전을 제한하는 것이 좋습니다. 제가 이전에 공유한 <a href="https://kdevkr.github.io/strict-nodejs-version-for-project/">프로젝트의 노드 버전 제한하기</a>를 참고하여 노드 엔진 버전을 12.13.0 이상으로 설정해두는 것을 추천하는 바입니다.</p>
<h3 id="커밋별로-확인하는-구성"><a href="#커밋별로-확인하는-구성" class="headerlink" title="커밋별로 확인하는 구성"></a>커밋별로 확인하는 구성</h3><p>각 커밋 단위의 Browser Files를 통해 어떻게 구성이 변화하는지를 참고하시면 좋습니다.</p>
<h4 id="Add-webpack-config-js-for-default-configuration"><a href="#Add-webpack-config-js-for-default-configuration" class="headerlink" title="Add webpack.config.js for default configuration"></a><a href="https://github.com/kdevkr/webpack5/commit/3f858c2702720088b8647bdb55a9f830d54a8d91">Add webpack.config.js for default configuration</a></h4><p>기본 구성을 위한 webpack.config.js 파일을 만들고 node-env 값에 따라 번들 파일명을 다르게 지정할 수 있음을 보여줍니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx webpack --node-env production <span class="comment"># 모드를 지정하지 않았지만 node-env 값에 의해 처리됩니다.</span></span><br></pre></td></tr></table></figure>

<h4 id="Add-vue-loader"><a href="#Add-vue-loader" class="headerlink" title="Add vue-loader"></a><a href="https://github.com/kdevkr/webpack5/commit/3ca2fc1de5573ae339b0271ea482a73bf3dac397">Add vue-loader</a></h4><p>Vue SFC 파일을 처리하기 위한 vue-loader를 추가하고 Vue 개발 환경을 준비하고 간단한 샘플 HTML 파일을 만들어서 Vue 코드가 정상적으로 변환되었음을 확인합니다.</p>
<h4 id="Add-sass-postcss"><a href="#Add-sass-postcss" class="headerlink" title="Add sass, postcss"></a><a href="https://github.com/kdevkr/webpack5/commit/68ffce2b18c64e67b944a383b216c2e6fe784396">Add sass, postcss</a></h4><p>Vue SFC의 스타일 블록의 언어를 SCSS로 사용하기 위해서 sass 및 postcss에 대한 설정을 추가합니다. </p>
<h4 id="Add-stylelint"><a href="#Add-stylelint" class="headerlink" title="Add stylelint"></a><a href="https://github.com/kdevkr/webpack5/commit/7e1e00735738e9106033c6df675977846b159552">Add stylelint</a></h4><p>반드시 필요한 설정은 아니지만 CSS에 대한 린트를 적용하기 위해 stylelint를 postcss 플러그인으로 추가합니다.</p>
<h4 id="Add-eslint"><a href="#Add-eslint" class="headerlink" title="Add eslint"></a><a href="https://github.com/kdevkr/webpack5/commit/f7f566314fd675e18d3f7b3dd35283317c5891ae">Add eslint</a></h4><p>자바스크립트에 대한 린트를 적용하기 위해 eslint를 추가합니다.</p>
<h4 id="Add-babel"><a href="#Add-babel" class="headerlink" title="Add babel"></a><a href="https://github.com/kdevkr/webpack5/commit/c5211b28ab8176e8c5c9fb39c755083679cb24df">Add babel</a></h4><p>ES6+ 문법을 지원하지 않는 브라우저를 위해 ES5 문법으로 변환하기 위한 babel을 추가합니다. babel 7 부터는 폴리필 적용 방식이 변경되었음을 주의해야합니다. 바벨 폴리필에 대해서는 다음의 두 링크를 참고하시면 좋습니다.</p>
<ul>
<li><a href="https://poiemaweb.com/babel-polyfill">폐지된 @babel/polyfill 대신 @babel/plugin-transform-runtime을 사용해 폴리필 추가하기</a></li>
<li><a href="https://tech.kakao.com/2020/12/01/frontend-growth-02/">Babel7과 corejs3 설정으로 전역 오염 없는 폴리필 사용하기</a></li>
</ul>
<h4 id="Add-browserslist"><a href="#Add-browserslist" class="headerlink" title="Add browserslist"></a><a href="https://github.com/kdevkr/webpack5/commit/c911ef73aa85ebde4d9c738c07999300c05bfaf8">Add browserslist</a></h4><p>postcss의 autoprefixer 또는 babel에서 참고할 타겟 정보를 위해 browserslist를 추가합니다.</p>
<h4 id="Add-prettierrc"><a href="#Add-prettierrc" class="headerlink" title="Add prettierrc"></a><a href="https://github.com/kdevkr/webpack5/commit/b5c8e20ebdb2224f1268b431aafb82a6b49e7b3a">Add prettierrc</a></h4><p>불필요한 포맷팅을 방지하기 위한 prettier 옵션을 조정합니다.</p>
<h4 id="Add-asset"><a href="#Add-asset" class="headerlink" title="Add asset"></a><a href="https://github.com/kdevkr/webpack5/commit/1ba05ff066806fb2c7b59eace748e04e73756243">Add asset</a></h4><p>이미지 또는 폰트 등을 위한 에셋 모듈을 추가합니다.</p>
<h4 id="Apply-strict-npm-engines"><a href="#Apply-strict-npm-engines" class="headerlink" title="Apply strict npm engines"></a><a href="https://github.com/kdevkr/webpack5/commit/1b768c5881db9d8348d54f926a11e537a50050ac">Apply strict npm engines</a></h4><p>지금까지 설치된 패키지에서 최소로 요구하는 노드 버전을 명시하고 제한되도록 설정합니다.</p>
<h4 id="Apply-settings-for-vscode"><a href="#Apply-settings-for-vscode" class="headerlink" title="Apply settings for vscode"></a><a href="https://github.com/kdevkr/webpack5/commit/9008824470873ce172e52294ddac7eee8304c256">Apply settings for vscode</a></h4><p>VSCode를 사용하는 경우 저장될 때 ESLint가 동작하도록 설정합니다.</p>
<h4 id="Add-project-version-in-output-filename"><a href="#Add-project-version-in-output-filename" class="headerlink" title="Add project version in output filename"></a><a href="https://github.com/kdevkr/webpack5/commit/769171d627bb1f4bfbb4bacce62dc067ff9b617a">Add project version in output filename</a></h4><p>(Optional) package.json에 정의된 프로젝트 버전을 번들 파일명에 포함시킬 수 있음을 보여줍니다.</p>
<h4 id="Apply-optimization"><a href="#Apply-optimization" class="headerlink" title="Apply optimization"></a><a href="https://github.com/kdevkr/webpack5/commit/bab1505c643b4ae3ea5e7a86bdc90317f4afe470">Apply optimization</a></h4><p>프로덕션 환경을 위한 최적화 구성을 조정합니다.</p>
<h4 id="Add-manifest"><a href="#Add-manifest" class="headerlink" title="Add manifest"></a><a href="https://github.com/kdevkr/webpack5/commit/7d0cd27b85a8f1df757e16c3ddb6ad32b8f7b39e">Add manifest</a></h4><p>매니페스트 파일이 생성할 수 있도록 플러그인을 추가합니다. </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx webpack --node-env production --env manifest</span><br></pre></td></tr></table></figure>

<h4 id="Add-bootstrap-vue"><a href="#Add-bootstrap-vue" class="headerlink" title="Add bootstrap-vue"></a><a href="https://github.com/kdevkr/webpack5/commit/c3da5f586c6ec368778e2c90478196e4af037a82">Add bootstrap-vue</a></h4><p>BootstrapVue를 추가해보고 <a href="https://kdevkr.github.io/no-emit-deprecation-warnings-of-dart-sass/">최신 버전의 Sass에서 출력되는 Deprecation 경고가 출력되지 않도록</a> 설정합니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Webpack5</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerInterceptor은 언제 사용하나요?</title>
    <url>/when-do-i-use-the-handler-interceptor/</url>
    <content><![CDATA[<p><img data-src="../images/logo/spring.png#compact"></p>
<p>안녕하세요 Mambo입니다. 오늘은 스프링 MVC 모듈에 포함되어있는 HandlerInterceptor 인터페이스를 언제 사용하는가에 대해서 알아보겠습니다.</p>
<h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><blockquote>
<p>A HandlerInterceptor gets called before the appropriate HandlerAdapter triggers the execution of the handler itself. This mechanism can be used for a large field of preprocessing aspects, e.g. for authorization checks, or common handler behavior like locale or theme changes. Its main purpose is to allow for factoring out repetitive handler code.</p>
</blockquote>
<p><strong>HandlerInterceptor</strong>는 컨트롤러 핸들러 함수에 대한 전처리 동작을 수행할 수 있는 방법을 제공합니다. 필터도 전처리 동작을 수행할 수 있지만 web.xml에 정의되는 필터와 다르게 HandlerInterceptor는 애플리케이션 컨텍스트에서 관리하므로 요청 정보를 분석하여 사용자를 인증하거나 응답 뷰를 렌더링하기 전에 부가 데이터를 주입하는 동작을 수행할 수 있습니다.</p>
<p>예를 들어, 기본으로 제공되는 HandlerInterceptor 구현체인 <strong>LocaleChangeInterceptor</strong>는 로케일 파라미터에 따라 현재 로케일을 변경하는 동작을 수행하죠.</p>
<h3 id="정적-리소스-패턴-제외"><a href="#정적-리소스-패턴-제외" class="headerlink" title="정적 리소스 패턴 제외"></a>정적 리소스 패턴 제외</h3><p><strong>ResourceHandlerRegistry</strong>는 정적 리소스를 배포하기 위한 핸들러를 등록하는 것을 지원하는 클래스입니다. 이때, 리소스 핸들러가 처리할 경로를 매칭하기 위하여 AntPathMatcher 또는 PathPattern을 사용하게 되는데 Ant 스타일의 패턴 매칭을 사용하므로 특정 패턴을 제외하기 위한 Regex 같은 방식을 사용할 수 없습니다. </p>
<p>리소스 핸들러가 처리하는 경로에 대해서 특정 패턴을 제외하기 위해서는 해당 패턴을 처리하지 않도록 패턴별로 등록하여야합니다. 하지만, 이렇게 올바른 패턴마다 리소스 핸들러를 등록하는 것은 불편합니다.</p>
<figure class="highlight java"><figcaption><span>ResourceHandlerRegistry</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/images/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/static/images/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예시는 <strong>/images/</strong>** 패턴의 경로에 대해서 클래스패스의 <strong>static/images</strong> 폴더에 있는 정적 리소스로 처리하기 위한 핸들러를 등록합니다. images 폴더에는 이미지 파일만 있다고 가정했으나 개발자의 실수로 images 폴더에 이미지가 아닌 동영상 파일이나 오디오 파일이 들어있다면 해당 리소스도 처리하게 됩니다.</p>
<p>이렇게 특정 패턴을 방지해야하는 경우에 HandlerInterceptor를 등록하여 요청을 분석하여 리소스를 응답하지 않도록 전처리 동작을 구현할 수 있습니다.</p>
<p>다음과 같이 <strong>이미지 파일 패턴이 아니라면 요청을 404 Not Found로 처리</strong>하는 동작을 수행할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(onlyServeImagesHandlerInterceptor()).addPathPatterns(<span class="string">&quot;/images/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/images/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/static/images/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">OnlyServeImagesHandlerInterceptor <span class="title">onlyServeImagesHandlerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OnlyServeImagesHandlerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlyServeImagesHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String requestURI = request.getRequestURI();</span><br><span class="line">            <span class="keyword">if</span>(!requestURI.matches(<span class="string">&quot;.*\\/.*\\.(jpg|jpeg|png|gif)&quot;</span>)) &#123;</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 인터셉터가 정말로 이미지 파일에 대해서만 처리할 수 있게 사전 처리를 수행하는지 확인해보겠습니다.</p>
<p><img data-src="/images/posts/handler-interceptor-01.gif"></p>
<p>위 결과를 보면 이미지 파일은 정적 리소스로 배포되도록 처리되었지만 동영상 파일은 처리되지 않게 된걸 확인할 수 있습니다. </p>
<h3 id="뷰-응답-시-부가-정보-주입"><a href="#뷰-응답-시-부가-정보-주입" class="headerlink" title="뷰 응답 시 부가 정보 주입"></a>뷰 응답 시 부가 정보 주입</h3><p>두번째로는 뷰를 응답하는 핸들러 함수에 대하여 <strong>부가 정보를 주입</strong>하는데에 사용할 수 있습니다. </p>
<p>다음의 코드는 뷰를 응답하게되는 핸들러 함수에 사용 가능한 언어와 함께 현재 로케일에 대한 메시지 코드 목록을 주입하는 인터셉터 예시입니다.</p>
<figure class="highlight java"><figcaption><span>InjectionLocalesInterceptor</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectionLocalesInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessagePool messagePool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(modelAndView != <span class="keyword">null</span> &amp;&amp; messagePool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Locale locale = messagePool.getLocale();</span><br><span class="line">            <span class="keyword">if</span>(locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">                locale = Locale.getDefault();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;lang&quot;</span>, locale.getLanguage());</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;locale&quot;</span>, locale.toString());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">                HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">                Class&lt;?&gt; beanType = handlerMethod.getBeanType();</span><br><span class="line">                Controller controller = beanType.getAnnotation(Controller.class);</span><br><span class="line">                <span class="keyword">if</span>(controller != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    modelAndView.addObject(<span class="string">&quot;locales&quot;</span>, messagePool.getLocales());</span><br><span class="line">                    modelAndView.addObject(<span class="string">&quot;messages&quot;</span>, messagePool.getMessagesInJson().toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 템플릿 엔진에서 주입된 부가 정보를 사용하여 렌더링을 할 수 있게 됩니다.</p>
<h3 id="인증을-위한-인터셉터"><a href="#인증을-위한-인터셉터" class="headerlink" title="인증을 위한 인터셉터"></a>인증을 위한 인터셉터</h3><p>또 다른 인터셉터의 활용 방안은 인증 처리입니다. 사용자에게 이메일 또는 카카오톡 메시지등을 발송하여 어떤 행동을 할 수 있는 링크를 주게 된다고 가정해보면 해당 링크를 통해 들어오는 사용자은 인증을 수행하기 전일 수 있습니다. 이때 주어지는 링크에 임시적으로 인증에 사용할 수 있는 만료성 토큰 파라미터를 포함시킴으로써 사용자를 인증하는 로직을 추가할 수 있습니다.</p>
<p><img data-src="https://s3.amazonaws.com/cdn.freshdesk.com/data/helpdesk/attachments/production/31015797034/original/89mawYXJeO_K082-5HF52bd73j_SN60nLQ.png" alt="코인원의 이메일 인증하기 버튼"></p>
<p>위 예시 이미지의 이메일 인증하기 버튼에 대한 링크에는 코인원에서 분석할 수 있는 어떠한 파라미터에 인증을 위한 식별 정보가 있을거라 추측합니다.</p>
<p>다음은 토큰 파라미터 유무를 확인하고 토큰 파라미터를 분석하여 인증을 수행하는 인터셉터 구현의 예시입니다.</p>
<figure class="highlight java"><figcaption><span>TokenBasedAuthenticationInterceptor</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBasedAuthenticationInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_PARAMETER_NAME = <span class="string">&quot;token&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String parameter = request.getParameter(TOKEN_PARAMETER_NAME);</span><br><span class="line">        <span class="keyword">if</span>(parameter != <span class="keyword">null</span> &amp;&amp; !parameter.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> 토큰 파라미터 분석 및 검증</span></span><br><span class="line">            String token = analyticsToken(parameter);</span><br><span class="line">            <span class="keyword">boolean</span> valid = validateToken(token);</span><br><span class="line">            <span class="keyword">if</span>(valid) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> 토큰 기반 인증 처리</span></span><br><span class="line">                authenticationByToken(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> valid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>일정 시간이 만료</strong>되면 해당 토큰으로는 인증할 수 없고 이미 인증을 수행하여 <strong>사용이 완료된 토큰</strong>으로 확인하는 것은 토큰 파라미터 분석 및 검증 로직에 포함될겁니다.</p>
<p>간단하게 HandlerInterceptor의 활용 방안 3가지를 확인해보았습니다. 애플리케이션 마다 요구사항이 다르고 무궁무진 하기 때문에 HandlerInterceptor는 더 다양한 방식으로 활용할 수 있을 겁니다. 이상으로 HandlerInterceptor은 언제 사용하나요?를 마치겠습니다. 감사합니다.</p>
]]></content>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>갑자기 애플리케이션 배포에 실패한 이유</title>
    <url>/why-fail-deploy-application/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 얼마전까지만 해도 잘 동작하던 배포 프로세스가 갑자기 실패하는 이유에 대해서 이야기 해보려고 합니다.</p>
<h2 id="빌드-및-배포-환경"><a href="#빌드-및-배포-환경" class="headerlink" title="빌드 및 배포 환경"></a>빌드 및 배포 환경</h2><p>회사에서 운영중인 서비스는 Elastic Beanstalk 환경의 자바 SE 플랫폼으로 스프링 부트 애플리케이션을 배포하고 있습니다. 자바 SE 플랫폼에서는 <strong>애플리케이션을 실행가능한 WAR 파일로 패키징하여 Procfile을 통해 실행</strong>할 수 있도록 구성할 수 있습니다. 예를 들어, 다음과 같이 실행가능하도록 패키징된 애플리케이션 파일을 실행하도록 Procfile을 만들고 Beanstalk 환경을 확장하기 위한 설정 파일들을 하나의 애플리케이션 소스 번들로 만들 수 있습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task procfile(<span class="attr">dependsOn:</span> bootJar) &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        project.file(<span class="string">&quot;build/libs/Procfile&quot;</span>).text = <span class="string">&quot;web: java -Xmx3g -Dfile.encoding=UTF-8 -jar $&#123;bootJar.archiveFileName&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task awsbuild(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> procfile) &#123;</span><br><span class="line">    println(<span class="string">&#x27;Build Version: &#x27;</span> + rootProject.version)</span><br><span class="line"></span><br><span class="line">    from (<span class="string">&#x27;beanstalk/.ebextensions&#x27;</span>) &#123; into <span class="string">&#x27;.ebextensions&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;beanstalk/.platform&#x27;</span>) &#123;into <span class="string">&#x27;.platform&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        include <span class="string">&#x27;Procfile&#x27;</span></span><br><span class="line">        include <span class="string">&quot;$&#123;bootJar.archiveFileName&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    archiveBaseName.set(<span class="string">&#x27;beanstalk&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="실패한-이유-1"><a href="#실패한-이유-1" class="headerlink" title="실패한 이유 1"></a>실패한 이유 1</h3><p>그런데 오늘 갑자기 정상적으로 수행되던 배포 프로세스 과정에서 다음과 같이 오류가 발생하여 애플리케이션 배포가 실패하였습니다.</p>
<p><img data-src="/images/posts/why-fail-deploy-application/reason-01.png"></p>
<p>위 오류가 발생하였을 때 태스크는 다음과 같이 작성되어있었습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task awsbuild(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> procfile) &#123;</span><br><span class="line">    from (<span class="string">&#x27;beanstalk/.ebextensions&#x27;</span>) &#123; into <span class="string">&#x27;.ebextensions&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;beanstalk/.platform&#x27;</span>) &#123;into <span class="string">&#x27;.platform&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        include(<span class="string">&#x27;Procfile&#x27;</span>)</span><br><span class="line">        include(bootJar.archiveName)</span><br><span class="line">    &#125;</span><br><span class="line">    baseName = <span class="string">&#x27;beanstalk&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데 최종적으로 만들어지는 애플리케이션 소스 번들을 확인해보니 <strong>bootJar.archiveName</strong>으로 포함시킨 애플리케이션 패키징 파일이 존재하지 않았습니다. 갑자기 왜 포함되지 않는 것 일까요? 이것저것 확인해보던 중 해결방법은 아주 간단하였는데요. 바로 다음과 같이 include 코드를 수정하는 것이었습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task awsbuild(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> procfile) &#123;</span><br><span class="line">    from (<span class="string">&#x27;beanstalk/.ebextensions&#x27;</span>) &#123; into <span class="string">&#x27;.ebextensions&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;beanstalk/.platform&#x27;</span>) &#123;into <span class="string">&#x27;.platform&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        include <span class="string">&#x27;Procfile&#x27;</span></span><br><span class="line">        include <span class="string">&quot;$&#123;bootJar.archiveName&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    baseName = <span class="string">&#x27;beanstalk&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>아무리봐도 무슨 차이인지는 모르겠으나 간단히 해결되었습니다. 한가지 의심이 되는 부분은 Gradle Warpper 버전이 <strong>gradle-7.1-all</strong>로 변경되었다는 것 입니다. </p>
<h3 id="실패한-이유-2"><a href="#실패한-이유-2" class="headerlink" title="실패한 이유 2"></a>실패한 이유 2</h3><p>간신히 패키징된 애플리케이션 파일을 애플리케이션 소스 번들에 포함하여 다시 배포 프로세스를 수행했지만 다시 다음과 같은 오류가 발생하면서 배포가 실패했습니다.</p>
<p><img data-src="/images/posts/why-fail-deploy-application/reason-02.png"></p>
<p>애플리케이션 소스 번들은 비어있거나 524288000 바이트를 넘을 수 없다는 오류입니다. 실제로 Elastic Beanstalk 문서에는 다음과 같이 애플리케이션 소스 번들은 최대 512MB로 제한된다는 내용이 있습니다.</p>
<p><img data-src="/images/posts/why-fail-deploy-application/reason-03.png"></p>
<p>만들어진 애플리케이션 소스 번들이 비어있을 이유가 없었기에 용량을 확인해보니 560MB를 넘고 있었습니다. 애플리케이션 소스 번들의 파일이 이렇게 클 이유가 없었는데 의아했습니다. 패키징된 애플리케이션 파일 자체 용량이 520MB를 넘고 있음을 확인하고 패키징된 애플리케이션 파일을 풀어서 내용을 살펴보니 다음과 같이 라이브러리가 포함된 폴더의 용량이 상당한 것을 확인했습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">total 964904</span><br><span class="line">-rw-r--r--  1 user  staff    14M Sep 24 11:31 ec2-2.17.29.jar</span><br><span class="line">-rw-r--r--  1 user  staff    11M Aug  9 12:29 elasticsearch-7.3.2.jar</span><br><span class="line">-rw-r--r--  1 user  staff   7.8M Aug  9 12:30 poi-ooxml-lite-5.0.0.jar</span><br><span class="line">-rw-r--r--  1 user  staff   7.2M Sep 24 11:31 sagemaker-2.17.29.jar</span><br><span class="line">-rw-r--r--  1 user  staff   5.7M Aug  9 12:30 bcprov-jdk15on-1.68.jar</span><br><span class="line">-rw-r--r--  1 user  staff   5.3M Sep 24 11:31 iot-2.17.29.jar</span><br><span class="line">-rw-r--r--  1 user  staff   5.1M Aug  9 12:30 org.eclipse.persistence.core-2.7.4.jar</span><br><span class="line">-rw-r--r--  1 user  staff   4.7M Sep 24 11:31 ssm-2.17.29.jar</span><br><span class="line">-rw-r--r--  1 user  staff   4.3M Aug  9 12:30 groovy-2.4.8.jar</span><br><span class="line">-rw-r--r--  1 user  staff   4.2M Sep 24 11:31 glue-2.17.29.jar</span><br><span class="line">-rw-r--r--  1 user  staff   4.2M Sep 24 11:31 rds-2.17.29.jar</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>패키징에 포함된 라이브러리와 연관된 파일이 모두 <strong>964904개</strong>로 출력되었습니다. 어떤 의존성 때문에 이렇게 많은 라이브러리 파일들이 포함되었을까요? 의심되는 부분은 <strong>sagemaker-2.17.29.jar와 같이 실제로는 사용하지 않는 라이브러리</strong> 였습니다. <strong>gradle dependencies</strong> 명령어를 수행하면 의존성 목록을 확인할 수 있다는 팀장님의 말씀을 듣고 검토해보니 다음과 같이 아마존 SDK에 대한 의존성이었습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;software.amazon.awssdk:aws-sdk-java:2.17.45&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.amazonaws:aws-java-sdk:1.12.73&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>com.amazonaws:aws-java-sdk 기존에 가지고 있던 <strong>아마존 SDK v1에 대한 의존성</strong>으로 확인되었고 software.amazon.awssdk:aws-sdk-java는 신규 기능 및 전환을 위해 새롭게 개발하고 테스트 중인 <strong>아마존 SDK v2에 대한 의존성</strong>입니다. </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyManagement &#123;</span><br><span class="line">    imports &#123;</span><br><span class="line">        mavenBom <span class="string">&#x27;com.amazonaws:aws-java-sdk-bom:1.12.73&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"><span class="comment">//    implementation &#x27;com.amazonaws:aws-java-sdk:1.12.73&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.amazonaws:aws-java-sdk-s3&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.amazonaws:aws-java-sdk-sqs&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.amazonaws:aws-java-sdk-cognitoidentity&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.amazonaws:aws-java-sdk-lambda&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.amazonaws:aws-java-sdk-autoscaling&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>개인적으로 공부할 때는 아마존 SDK 전체를 의존성으로 추가하지 않았기에 아마존 SDK 전체를 추가하는 경우와 실제로 사용하는 라이브러리만 추가한 경우를 비교해보니 다음과 같이 요약되었습니다.</p>
<table>
<thead>
<tr>
<th>의존성</th>
<th>용량</th>
</tr>
</thead>
<tbody><tr>
<td>아마존 SDK v1 전체</td>
<td>214MB</td>
</tr>
<tr>
<td>아마존 SDK v1 개별</td>
<td>15.8MB</td>
</tr>
<tr>
<td>아마존 SDK v2 전체</td>
<td>268MB</td>
</tr>
<tr>
<td>아마존 SDK v2 개별</td>
<td>25.1MB</td>
</tr>
<tr>
<td>아마존 SDK v1 + v2 전체</td>
<td>471MB</td>
</tr>
<tr>
<td>아마존 SDK v1 + v2 개별</td>
<td>32.4MB</td>
</tr>
</tbody></table>
<p>위 상황처럼 아마존 SDK v1과 v2 모두를 의존성에 추가하는 경우 무려 <strong>471MB</strong>라는 어마어마한 용량을 가지게 되는 것을 확인할 수 있었습니다. 사용하지도 않는 라이브러리를 포함하여 쓸데없이 애플리케이션만 무거워졌던 것이죠. </p>
<p><img data-src="/images/posts/why-fail-deploy-application/reason-04.png"></p>
<p>패키징된 애플리케이션 파일 용량이 줄어들어 정상적으로 배포 프로세스가 수행되었습니다. 그리고 이러한 사항에 대해 개발팀에 아마존 SDK 추가 시 사용하려는 라이브러리를 추가하는 것이 좋다고 전달하였습니다. 이 글을 보시는 분들도 아마존 SDK 전체를 추가한 상태라면 실제로 사용하는 라이브러리를 개별적으로 추가하시기 바랍니다.</p>
<h3 id="그래들-태스크-개선"><a href="#그래들-태스크-개선" class="headerlink" title="그래들 태스크 개선"></a>그래들 태스크 개선</h3><p>Deprecated된 속성 또는 함수를 사용하는 것을 추가적으로 개선해 보았습니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task procfile(<span class="attr">dependsOn:</span> bootJar) &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        project.file(<span class="string">&quot;build/libs/Procfile&quot;</span>).text = <span class="string">&quot;web: java -Xmx3g -Dfile.encoding=UTF-8 -jar $&#123;bootJar.archiveFileName&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task awsbuild(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> procfile) &#123;</span><br><span class="line">    from (<span class="string">&#x27;beanstalk/.ebextensions&#x27;</span>) &#123; into <span class="string">&#x27;.ebextensions&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;beanstalk/.platform&#x27;</span>) &#123;into <span class="string">&#x27;.platform&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        include <span class="string">&#x27;Procfile&#x27;</span></span><br><span class="line">        include <span class="string">&quot;$&#123;bootJar.archiveFileName&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    archiveBaseName.set(<span class="string">&#x27;beanstalk&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Beanstalk</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>클라이언트 HTTP 요청부터 스프링 애플리케이션 응답하기까지의 과정</title>
    <url>/http-requests-from-client-to-response-from-spring/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다. 오늘은 <strong>클라이언트의 HTTP 요청부터 스프링 애플리케이션의 응답까지의 과정</strong> 에 대하여 이야기를 해보려고합니다. 제가 진행하는 공부방식 중 하나는 <a href="https://okky.kr/articles/questions">OKKY</a>에 올라오는 질문들을 살펴보면서 문제점을 파악하고 해결책을 찾아보는 과정을 진행하는 것입니다. 그런데 OKKY에 등록되는 질문들 중 대부분이 <code>AJAX</code>으로 데이터를 보내고 <code>스프링 컨트롤러</code>에서 데이터를 받는게 안된다는 유형이 많은 편입니다. 해당 질문 작성자들은 스프링 경험이 많지 않은 초보 개발자 이거나 스프링에 대한 이해없이 빠르게 예제를 통해 학습한 국비지원 수강생으로 보입니다.</p>
<blockquote>
<p>국비지원에 대한 비하로 느껴질 수 있으시겠습니다만, 스프링은 여러가지 프로그래밍 개념이 복합적으로 이루어진 프레임워크로 일반적으로 컴퓨터 공학과에서 배우는 전공 지식과는 별개로 쉽게 이해하기에는 어렵습니다. 그러니까 비전공자이기 때문에 어려운 것이 아니라 개념적으로 어려운 것이니 우울해하지 않으셔도 됩니다.</p>
</blockquote>
<p>4년 동안 스프링 기반으로 웹 애플리케이션을 개발하고 있는 저 또한 스프링을 제대로 이해하지는 못했습니다. 처음에 토비님이 작성하신 <code>토비의 스프링 3.1</code> 서적을 앞에서 읽다가 뒤부터 읽다가 이해가 안되서 대충이라도 최소한 4번은 읽은 것 같습니다. </p>
<p>그런데 앞서 언급한 질문들은 스프링의 개념을 이해를 못했다기보다는 HTTP 웹 요청 과정에 대한 이해가 부족하기 때문에 발생하는 문제라고 볼 수 있습니다. 스프링에 포함된 여러가지 모듈 중 웹 요청과 관련된 모듈은 <code>spring-web</code>과 <code>spring-webmvc</code> 인데요. 이 모듈들은 여러분이 스프링 기반의 웹 애플리케이션을 작성하는데 도움을 제공하는 클래스들이 포함되어있습니다. </p>
<p>이 글의 주요 내용인 클라이언트의 HTTP 요청부터 스프링 애플리케이션의 응답까지의 과정을 위 두개의 모듈이 제공하는 클래스들의 연관성을 찾아가면 쉽게 이해할 수 있습니다. 이 글을 통해 HTTP 요청과 응답 과정을 이해하신다면 제가 예전에 작성하였던 <a href="https://okky.kr/article/374594">초보 및 신입 개발자들을 위한 spring to ajax에 대한 정리</a>의 여러가지 케이스를 좀 더 쉽게 받아들일 수 있을거라 봅니다.</p>
<blockquote>
<p>관련 코드 : <a href="https://github.com/kdevkr/spring-demo-ajax">kdevkr/spring-demo-ajax</a></p>
</blockquote>
<h2 id="HTTP-요청"><a href="#HTTP-요청" class="headerlink" title="HTTP 요청"></a>HTTP 요청</h2><p>먼저, 웹 브라우저와 같은 클라이언트에서 HTTP 요청을 수행하는 과정을 이해해야합니다. MDN 개발자 문서에서는 <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Messages">HTTP 메시지</a>에 대해 자세하게 설명해주고 있습니다.</p>
<h3 id="HTTP-메시지"><a href="#HTTP-메시지" class="headerlink" title="HTTP 메시지"></a>HTTP 메시지</h3><p><img data-src="https://mdn.mozillademos.org/files/13827/HTTPMsgStructure2.png" alt="출처 : MDN HTTP Messages"></p>
<p>위 그림에서처럼 여러분이 웹 브라우저를 통해 어떤 웹 사이트로 접근하는 것도 위와 같은 메시지를 요청하고 응답받습니다. 예를 들어, OKKY 사이트에 접속하기 위해서 <code>okky.kr</code> 주소를 입력하면 웹 브라우저가 대신해서 다음과 같은 정보로 HTTP 메시지를 보내고 응답을 받은 것을 브라우저에서 보여주는 것입니다.</p>
<p><img data-src="/images/posts/http-requests-responses/http-requests-responses-01.png" alt="[GET] okky.kr"></p>
<blockquote>
<p>지금 이 글을 보고 계시니까 이 과정은 다 이해하실테지요 :)</p>
</blockquote>
<h3 id="HTTP-Headers"><a href="#HTTP-Headers" class="headerlink" title="HTTP Headers"></a>HTTP Headers</h3><p>앞선 그림에서 웹 브라우저는 요청 헤더(Request Headers)에 무언가 많이 포함하고 있는 것을 볼 수 있을겁니다. 이 HTTP 요청 헤더는 HTTP 요청에 대한 부가정보를 제공한다고 볼 수 있는데요. 여러가지 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">헤더</a>를 통해서 요청자를 식별할 수 있게 하거나 인증 정보를 포함하기도 하고 서버에게 요청에 대해 내가 응답받으려는 형태를 알려주기도 합니다.</p>
<p>Accept, Accept-Encoding, Accept-Language는 <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation">컨텐츠 협상(Content negotiation)</a>이라고 해서 HTTP 요청에 대하여 응답하는 서버가 어떤 형태로 내려주는게 가장 알맞는 것인지 알려주는 역할을 합니다. 그리고 HTTP 요청을 통해 데이터를 포함해서 보낼때 포함되는 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type">컨텐트 타입(Content-Type)</a>도 있고 파일 다운로드할 때 사용되는 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition">Content-Disposition</a> 헤더도 있죠.</p>
<p>우선 기본적으로 알고 있어야하는 요청 헤더는 <code>Accept</code>, <code>Content-Type</code> 이라고 할 수 있습니다. Accept 헤더는 서버가 응답하기 위해 HTTP 메시지를 구성할 때 알맞는 형태로 제공해달라는 정보이고 Content-Type 헤더는 HTTP 메시지에 포함된 데이터가 어떤 형태로 구성되는지를 서버에게 알려주는 역할을 합니다. 따라서, 클라이언트에서 HTTP 요청할 때 HTTP 메시지에 포함되는 메시지 형태에 따라 Content-Type 헤더를 제공해야하고 서버로부터 특정 메시지 형태로 받고 싶다면 Accept 헤더에 알맞는 값을 지정해야하죠.</p>
<blockquote>
<p>위 예시에서 OKKY 서버는 웹 브라우저가 요청한 Accept 헤더 중 첫번째인 text/html으로 HTTP 메시지를 응답했습니다.</p>
</blockquote>
<h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>Accept 헤더의 값은 <code>&lt;MIME_type&gt;/&lt;MIME_subtype&gt;</code> 형태로 구성하는데 대부분 <code>*/*</code> 으로 지정하여 서버가 알아서 응답 메시지 형태를 구성하거나 AJAX으로 요청하는 경우 <code>application/json</code>으로 설정하기도 하죠.</p>
<p>다음은 주로 사용되는 Accept 값이며 이외에도 많으니 한번 찾아보시는 것을 추천드립니다.</p>
<ul>
<li>text/plain, text/html, text/css, text/javascript</li>
<li>image/png, image/jpeg</li>
<li>application/json, application/xml, application/octet-stream</li>
</ul>
<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>Content-Type 헤더는 HTTP 메시지에 포함된 데이터의 형태를 알려주는 값이라고 했습니다. OKKY에 로그인하기 위해서 구글 OAuth 인증에 대한 HTTP 요청 정보를 확인해보면 다음과 같이 구성됨을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/http-requests-responses/http-requests-responses-02.png" alt="구글 계정으로 인증 시 요청 메시지"></p>
<p>구글 계정으로 인증 시 포함하는 요청 데이터가 <code>폼 데이터</code> 형태로 구성되어있다는 것을 알려주기 위해서 Content-Type에 <code>application/x-www-form-urlencoded</code>을 지정하였습니다.</p>
<p><img data-src="/images/posts/http-requests-responses/http-requests-responses-03.png" alt="구글 계정으로 인증 시 응답 메시지"></p>
<p>구글 인증 서버는 구글 계정 인증에 대한 결과가 JSON 형태의 문자열인 것을 알려주기 위해서 Content-Type에 <code>application/json</code>을 지정한 것을 확인할 수 있습니다. 이렇게 서버로 어떤 데이터가 포함되어야하는 요청이라면 요청 메시지를 구성하고 메시지 형태에 따라 Content-Type을 지정해야함을 알 수 있습니다.</p>
<h2 id="스프링-웹-모듈"><a href="#스프링-웹-모듈" class="headerlink" title="스프링 웹 모듈"></a>스프링 웹 모듈</h2><p>스프링 5부터는 리액티브 스택 기반의 애플리케이션을 작성할 수 있는 모듈이 있지만 일반적으로 사용되는 서블릿 기반의 <code>spring-webmvc</code> 모듈을 통해 HTTP 요청을 어떻게 처리하는지 알아보도록 합시다. 모듈 이름에서 확인할 수 있듯이 서블릿 기반의 웹 애플리케이션은 MVC 아키텍처 형태로 동작합니다. 스프링 웹 모듈에는 모든 HTTP 요청의 진입점이 되는 DispatcherServlet 클래스가 있으며 HTTP 요청에 대한 핸들러를 찾아 처리를 위임하게 됩니다.</p>
<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>다음은 DispatcherServlet 클래스의 doDispatch 함수의 일부분입니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        noHandlerFound(processedRequest, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>굉장히 단순한 코드라고 할 수 있는데요. 현재 처리중인 요청에 대한 핸들러가 존재하지 않는 경우 noHandlerFound 함수를 호출해서 오류를 발생시킬 지 404 NotFound 응답을 제공할지 결정하고 현재 요청을 처리할 수 있는 핸들러가 있다면 해당 핸들러에 대한 핸들러 어댑터를 찾아 처리를 수행하죠. 핸들러를 찾았지만 다시 핸들러 어댑터를 찾아 처리가 되도록하는 이유가 궁금하지 않으신가요? 그럼 핸들러 어댑터(HandlerAdapter)를 찾아가보도록 합시다.</p>
<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><p>HandlerAdapter는 인터페이스로 추상화되어있으니 실제 동작을 수행하는 구현체를 찾아야 합니다.</p>
<p><img data-src="/images/posts/http-requests-responses/http-requests-responses-04.png" alt="HandlerAdapter 구현체"></p>
<p>다른 클래스와 달리 AbstractHandlerMethodAdapter는 추상클래스로 되어있으니 한번 더 클래스를 찾아봅니다.</p>
<p><img data-src="/images/posts/http-requests-responses/http-requests-responses-05.png" alt="RequestMappingHandlerAdapter"></p>
<p>한번이라도 스프링의 컨트롤러를 작성하신분들이라면 눈에 들어오는 것이 있습니다. 바로 <code>RequestMapping</code> 어노테이션입니다. RequestMappingHandlerAdapter 클래스의 주석을 살펴보면 핸들러 함수에 선언된 RequestMapping을 지원하는 AbstractHandlerMethodAdapter의 <code>확장</code>이라고 합니다. 그러니까 여러분이 @RequestMapping이나 @GetMapping, @PostMapping등의 어노테이션을 선언하여 컨트롤러의 핸들러 함수를 작성하면 RequestMappingHandlerAdapter를 통해 처리가 수행된다는 거죠.</p>
<p>직접 찾아보시는 분들이라면 RequestMappingHandlerAdapter의 수많은 함수 중에서 handleInternal으로 요청이 처리됨을 확인할 수 있을겁니다. 그리고 invokeHandlerMethod를 호출해서 여러분이 작성한 핸들러 함수를 실행합니다. </p>
<p><img data-src="/images/posts/http-requests-responses/http-requests-responses-06.png" alt="Spring 4.2+ invokeHandlerMethod"></p>
<blockquote>
<p>위 invokeHandlerMethod는 스프링 5 기준의 코드인데 스프링 4.2가 명시되어있는 것을 보면 이전에는 다른 함수를 호출했을 것 같습니다. 스프링 4.2 이전 버전으로 개발하고 있으신 분들이라면 직접 찾아보시기 바랍니다. 귀찮아요…ㅠㅠ</p>
</blockquote>
<p>RequestMappingHandlerAdapter는 스프링 3.1부터 추가되었으니 RequestMappingHandlerAdapter를 바로 찾으시면 됩니다. </p>
<p>여러분이 작성한 컨트롤러의 핸들러 함수를 호출하는 부분이므로 코드를 좀 자세히 보도록 하겠습니다.</p>
<figure class="highlight java"><figcaption><span>invokeHandlerMethod</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">        ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">        modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">        asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">        asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">        asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">        asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">            Object result = asyncManager.getConcurrentResult();</span><br><span class="line">            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">            asyncManager.clearConcurrentResult();</span><br><span class="line">            LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">                String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>아직까지 용도는 모르겠으나 핸들러 함수를 기반으로 WebDataBinderFactory, ModelFactory, ServletInvocableHandlerMethod를 구성하고 ServletInvocableHandlerMethod를 통해 ServletWebRequest와 ModelAndViewContainer로 핸들러 함수를 실행하고 처리하는 것을 확인할 수 있습니다.</p>
<p>처리하는 부분이 ServletInvocableHandlerMethod로 감싸져있는 것 같으니 다시 찾아가봅시다.</p>
<figure class="highlight java"><figcaption><span>ServletInvocableHandlerMethod.invokeAndHandle</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeForRequest 함수로 요청을 처리하고 리턴된 값을 returnValueHandlers로 다시 처리하는 것을 확인할 수 있습니다. 코드의 순서를 볼때 invokeForRequest가 여러분이 작성한 핸들러 함수가 호출되는 부분이고 핸들러 함수에서 리턴한 값을 스프링에서 returnValueHandlers로 다시 처리하는 거라고 예상할 수 있습니다.</p>
<p>returnValueHandlers 유형을 찾아보면 <code>HandlerMethodReturnValueHandlerComposite</code>인 것을 확인할 수 있습니다. HandlerMethodReturnValueHandlerComposite는 <code>HandlerMethodReturnValueHandler</code> 구현체로 HandlerMethodReturnValueHandler의 목록을 통해 여러분이 핸들러 함수에서 리턴한 유형에 따라 HandlerMethodReturnValueHandler으로 처리하도록 구현되어있습니다.</p>
<figure class="highlight java"><figcaption><span>HandlerMethodReturnValueHandlerComposite</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="params"><span class="function">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그러면 여러분이 핸들러 함수에서 리턴한 값에 따라 처리를 담당하는 HandlerMethodReturnValueHandler 구현체가 있다는 것으로 이해할 수 있습니다. </p>
<h4 id="HandlerMethodReturnValueHandler"><a href="#HandlerMethodReturnValueHandler" class="headerlink" title="HandlerMethodReturnValueHandler"></a>HandlerMethodReturnValueHandler</h4><p>HandlerMethodReturnValueHandler 구현체를 찾아보면 다음과 같이 나옵니다.</p>
<p><img data-src="/images/posts/http-requests-responses/http-requests-responses-07.png" alt="HandlerMethodReturnValueHandler 구현체"></p>
<p>사실 HandlerMethodReturnValueHandler 구현체 목록은 스프링 공식 레퍼런스를 참고하시는 분들이라면 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types">Handler Methods Return Values</a>에서 확인하셨을 겁니다.</p>
<blockquote>
<p>이 글을 보는 대부분의 초보 개발자는 레퍼런스를 참고하지 않을 수 있습니다. 이게 바로 공식 레퍼런스를 참고하는 이유라고 할 수 있겠죠?</p>
</blockquote>
<p>간단하게 정리해보면 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th align="left">Return Value</th>
<th align="left">HandlerMethodReturnValueHandler</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">ViewNameMethodReturnValueHandler</td>
<td align="left">ViewResolver 구현체에 의해 View Name으로 처리</td>
</tr>
<tr>
<td align="left">View</td>
<td align="left">ViewMethodReturnValueHandler</td>
<td align="left">View 인스턴스로 렌더링</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">MapMethodProcessor</td>
<td align="left">Map을 ModelAndView 속성으로 처리</td>
</tr>
<tr>
<td align="left">Model</td>
<td align="left">ModelMethodProcessor</td>
<td align="left">Model을 Map으로 변환하여 ModelAndView 속성으로 처리</td>
</tr>
<tr>
<td align="left">@ResponseBody</td>
<td align="left">AbstractMessageConverterMethodProcessor</td>
<td align="left">리턴 값을 HttpMessageConverter 구현체로 변환해서 응답</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">ModelAndViewMethodReturnValueHandler</td>
<td align="left">ServletResponse 또는 @ResponseStatus로 처리</td>
</tr>
<tr>
<td align="left">ModelAndView</td>
<td align="left">ModelAndViewMethodReturnValueHandler</td>
<td align="left">View, Model Attritube, Response Status로 처리</td>
</tr>
</tbody></table>
<p>여러분이 작성한 컨트롤러 핸들러 함수가 리턴한 값에 <code>@ResponseBody</code> 어노테이션을 명시하는 것은 <code>AbstractMessageConverterMethodProcessor</code>를 통해 메시지 컨버터로 변환해서 응답한다는 것을 의미합니다. 또한, @ResponseBody 없이 <code>Map</code>을 리턴한다는 것은 <code>MapMethodProcessor</code>을 통해 Map에 있는 값들을 ModelAndView의 애트리뷰트로 넣어서 응답한다는 것을 의미하죠.</p>
<p>결국 <code>@ResponseBody</code>를 사용한다는 것은 리턴 값에 대한 <code>메시지 컨버터</code>를 알고 있어야 한다는 것을 의미합니다. 예를 들어, OKKY에 공유한 <a href="https://okky.kr/article/387101">스프링 버전별 Jackson 관련 라이브러리 및 메시지 컨버터 정보</a>에 따르면 스프링 버전에 따라 JSON으로 변환하기 위한 메시지 컨버터 지원이 다르기 때문에 여러분이 사용중인 스프링 버전에 따라 라이브러리를 의존해야하고 알맞는 메시지 컨버터가 등록되어있어야함을 뜻합니다.</p>
<p><code>스프링 4 이상</code>의 버전을 사용중인데 대부분의 블로그에서 제시하는 <code>MappingJacksonHttpMessageConverter</code>는 미지원하기 때문에 <code>org.codehaus.jackson</code> 라이브러리를 의존성에 가지고 있다고 해도 메시지 컨버터는 등록되지 않습니다. 반대로 <code>스프링 4 미만</code>의 버전을 사용중인데 <code>MappingJackson2HttpMessageConverter</code>를 등록하고 <code>com.fasterxml.jackson.core</code> 라이브러리를 의존하는 것도 의미 없는 행위라고 할 수 있죠.</p>
<p>이렇게 스프링 버전에 따라 의존해야하는 라이브러리 버전이 존재함에 따라 의존성 라이브러리 버전을 관리하는 <a href="https://mvnrepository.com/artifact/org.springframework/spring-framework-bom"><br>Spring Framework (Bill of Materials)</a>을 제공하기도 합니다.</p>
<p>여기까지 확인한 바로는 HandlerAdapter로 여러분이 작성한 핸들러를 찾아 호출하고 핸들러 함수의 리턴값에 따라 HandlerMethodReturnValueHandler로 응답하는 것을 확인했습니다. 그런데 눈치 빠르신분들은 한가지 과정을 빼먹었다고 느끼실 것입니다. 바로 HTTP 요청에 포함된 데이터를 가져오는 부분인데 스프링에서는 <code>데이터 바인딩</code>이라고 부르는 과정입니다. 이 데이터 바인딩 과정은 RequestMappingHandlerAdapter의 invokeHandlerMethod에 이미 포함되어있습니다.</p>
<p>바로 WebDataBinderFactory를 만들고 ServletInvocableHandlerMethod에 setHandlerMethodArgumentResolvers로 HandlerMethodArgumentResolverComposite를 설정하는 부분입니다.</p>
<h4 id="WebDataBinder"><a href="#WebDataBinder" class="headerlink" title="WebDataBinder"></a>WebDataBinder</h4><p>WebDataBinder는 HTTP 요청 파라미터를 자바 빈즈 오브젝트로 데이터를 바인딩하는데 여러분이 HTTP 요청 시 데이터를 쿼리 파라미터로 전송하거나 폼 데이터 형식으로 보내는 경우 스프링은 WebDataBinder로 여러분의 도메인 클래스에 데이터를 주입합니다. 이때 <a href="https://www.oracle.com/java/technologies/javase/javabeans-spec.html">JavaBeans 스펙</a>에 따르므로 프로퍼티 표현식과 Getter, Setter에 따라 데이터를 바인딩합니다.</p>
<h4 id="HandlerMethodArgumentResolver"><a href="#HandlerMethodArgumentResolver" class="headerlink" title="HandlerMethodArgumentResolver"></a>HandlerMethodArgumentResolver</h4><p>HandlerMethodReturnValueHandler가 리턴 값에 따라 응답을 처리한다면 HandlerMethodArgumentResolver는 컨트롤러 핸들러 함수에 존재하는 매개변수 유형에 따라 데이터 주입을 해주는 역할을 수행합니다. HandlerMethodArgumentResolver도 인터페이스 이므로 실제로 동작을 수행하는 구현체를 찾아야합니다.</p>
<p>스프링 5 기준의 RequestMappingHandlerAdapter에는 기본적으로 적용되는 HandlerMethodArgumentResolver 목록이 있습니다.</p>
<figure class="highlight java"><figcaption><span>RequestMappingHandlerAdapter.getDefaultArgumentResolvers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type-based argument resolution</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line">    <span class="keyword">if</span> (KotlinDetector.isKotlinPresent()) &#123;</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ContinuationHandlerMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom arguments</span></span><br><span class="line">    <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Catch-all</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> PrincipalMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>여러분이 주로 사용하거나 대부분의 예제에서 사용하는 몇가지 HandlerMethodArgumentResolver 구현체는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th align="left">Argument Type</th>
<th align="left">HandlerMethodArgumentResolver</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@RequestParam</td>
<td align="left">RequestParamMethodArgumentResolver</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">@PathVariable</td>
<td align="left">PathVariableMethodArgumentResolver</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">@ModelAttribute</td>
<td align="left">ServletModelAttributeMethodProcessor</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">@RequestBody</td>
<td align="left">RequestResponseBodyMethodProcessor</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">@RequestPart, MultipartFile, Part</td>
<td align="left">RequestPartMethodArgumentResolver</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">WebRequest, ServletRequest, MultipartRequest, InputStream</td>
<td align="left">ServletRequestMethodArgumentResolver</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">HttpSession, Principal, Locale, TimeZone, ZoneId</td>
<td align="left">ServletRequestMethodArgumentResolver</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ServletResponse, OutputStream, Writer</td>
<td align="left">ServletResponseMethodArgumentResolver</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>예를 들어, <code>@ModelAttribute</code>를 핸들러 함수 매개변수에 선언하는 것은 <code>ServletModelAttributeMethodProcessor</code>에 의해 WebDataBinder로 데이터 바인딩을 수행하는 것이며 <code>@RequestBody</code>를 핸들러 함수 매개변수에 선언하는 것은 <code>RequestResponseBodyMethodProcessor</code>에 의해 HTTP 요청 페이로드를 매개변수 형식으로 메시지 컨버터로 변환한다는 것을 의미합니다.</p>
<p>여기까지 확인함으로써 스프링 웹 애플리케이션에서 HTTP 요청을 처리할 핸들러 함수를 작성하는 것에 따라 어떻게 데이터 바인딩하고 리턴값에 따른 응답을 처리하는 지 알게되었습니다. 상세하게 알아본 것은 아니기 때문에 아쉬움이 있지만 요청과 응답 과정에서 사용되는 클래스만 알아도 무방합니다.</p>
<p>시간이 있다면 각 클래스가 어떤식으로 작성되어있는지를 확인해보시는 것도 여러분의 코드 작성 스타일에 도움이 됩니다. 스프링 프레임워크를 담당하는 개발자들은 여러분보다 확실히 뛰어난 개발자이고 정해진 스타일에 따라 코드를 작성합니다.</p>
<h2 id="요청-응답-케이스"><a href="#요청-응답-케이스" class="headerlink" title="요청 응답 케이스"></a>요청 응답 케이스</h2><p>그냥 마무리하기에는 아쉬움이 많으므로 OKKY에 올라오는 질문글 중 HTTP 요청과 응답에 대한 여러가지 케이스를 정리해보도록 하겠습니다.</p>
<h3 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h3><p>클라이언트 요청에 대하여 서버가 415 오류를 응답하는 경우 핸들러 함수가 클라이언트가 설정한 Content-Type 유형을 처리할 수 없는 것을 말합니다. </p>
<p><a href="https://okky.kr/article/558309">https://okky.kr/article/558309</a></p>
<p>위 질문글의 일차적인 문제점은 컨트롤러 핸들러 함수는 <code>application/x-www-form-urlencoded</code>를 처리하도록 작성해놓고 정작 클라이언트에서는 <code>application/json</code>으로 요청해버렸습니다. 그런데 Content-Type을 정상적으로 설정해도 또 다른 문제점을 내포하고 있었습니다. 이 글에서 다루었던 스프링 버전별 Jackson 라이브러리 의존성이 다르다는 부분입니다. 질문자는 스프링 4 이상부터 사용할 수 있는 Jackson 2 라이브러리를 추가하였고 vernum님이 남기신 링크로 해결하신 것 같아보이는데 해당 링크로 들어가보면 MappingJacksonHttpMessageConverter를 사용하고 org.codehaus.jackson 라이브러리를 의존성에 추가한 것을 확인할 수 있습니다.</p>
<h3 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h3><p>클라이언트 요청에 대하여 서버가 406 오류를 응답하는 경우 클라이언트가 지정한 Accept 헤더에 따라 서버에서 HTTP 메시지를 구성할 수 없음을 말합니다. </p>
<p><a href="https://okky.kr/article/876362">https://okky.kr/article/876362</a><br><a href="https://okky.kr/article/878053">https://okky.kr/article/878053</a><br><a href="https://okky.kr/article/878257">https://okky.kr/article/878257</a></p>
<p>위 질문자님은 무려 3번이나 406 오류에 대한 질문을 하지만 애초에 HTTP 요청과 응답에 대한 이해가 없었기 때문에 답변해주시는 분들이 뭐를 바꿔바라 이걸 지정해라해줘도 바꿔봤는데 안된다는 말만 되풀이하십니다.</p>
<p>핸들러 함수에서 System.out은 잘 출력된다는 것을 보면 핸들러 함수 리턴값을 HTTP 응답으로 변환할 때 클라이언트가 요청한 형식으로 바꾸지 못한다는 것을 예상할 수 있겠습니다. 이 글에서 @ResponseBody를 선언하면 응답 유형에 따른 메시지 컨버터를 찾아 응답으로 변환하는 것을 확인했었습니다. 그래서 메시지 컨버터가 잘 등록되어있는지를 의심해봐야합니다. 이분의 경우 <strong>Jackson 2 라이브러리를 의존</strong> 하고 메시지 컨버터로 <strong>MappingJacksonHttpMessageConverter</strong> 를 사용하고 있기 때문에 잘못된 구성을 하셔서 발생하셨을 겁니다. MappingJacksonHttpMessageConverter는 스프링 웹 모듈이 가지고 있기 때문에 오류는 나지 않겠지만 MappingJacksonHttpMessageConverter가 필요로 하는 Jackson 라이브러리가 없기 때문에 처리할 수 없습니다.</p>
<h3 id="데이터-바인딩-규칙"><a href="#데이터-바인딩-규칙" class="headerlink" title="데이터 바인딩 규칙"></a>데이터 바인딩 규칙</h3><p>스프링 뿐만 아니라 Jackson 이나 Lombok과 같은 라이브러리도 기본적으로 <code>JavaBeans</code> 스펙에 따라 동작합니다. 다시 말해서 HTTP 요청에 포함된 데이터를 자바 도메인 클래스에 주입하기 위한 <code>규칙</code>이 있다는 말인데요. </p>
<p>먼저, 다음 질문을 살펴봅시다.</p>
<p><a href="https://okky.kr/article/532781">https://okky.kr/article/532781</a></p>
<p>위 질문의 경우 @RequestBody 어노테이션을 지정해서 데이터 바인딩을 시도했으나 DTO에 데이터가 주입되지 않은 상황입니다. 그런데 DTO에는 필드명을 UpperCase로 작성하셨습니다. 그런데 Jackson 라이브러리는 기본적으로 일반적인 자바 네이밍 규칙에 따라 소문자로 시작하는 카멜 케이스로 데이터를 바인딩하도록 되어있습니다. 필드명을 바꿔서 해결하신지는 모르겠으나 만약, 필드명을 UpperCase로 하고 데이터 바인딩을 적용하고 싶다면 클래스 단위로 <code>@JsonNaming</code>을 선언하거나 필드에 <code>@JsonProperty</code>를 지정하시면 됩니다.</p>
<p>두번째 데이터 바인딩 규칙은 데이터가 포함되는 위치라고 할 수 있습니다. </p>
<p><a href="https://okky.kr/article/780096">https://okky.kr/article/780096</a></p>
<p>위 질문은 HTTP 요청 페이로드에 데이터를 포함시키고 @Modelattribute를 선언하여 데이터 바인딩을 시도하려고 하신 경우입니다. @Modelattribute는 URL에 포함되는 <code>쿼리 파라미터</code> 또는 <code>폼 데이터</code> 형식으로부터 데이터 바인딩을 수행하기 때문에 HTTP 요청 페이로드가 폼 데이터 형식이 아니므로 <code>@Modelattribute</code>로는 데이터 바인딩을 수행할 수 없습니다.</p>
<p>해당 질문자님도 정말로 @Modelattribute를 사용하고 싶었다면 클라이언트에서 Content-Type을 application/json이 아닌 application/x-www-form-urlencoded 형식으로 보내야겠죠?</p>
<h2 id="끝마치며"><a href="#끝마치며" class="headerlink" title="끝마치며"></a>끝마치며</h2><p>월요일부터 퇴근하고나서 짬짬히 작성한 글이므로 전체적으로 정리가 안되었을 수 있습니다. 이 부분은 양해해주시기 바라며 스프링 경험이 많지 않으신 개발자 분들에게 조금이나마 도움이 되었으면 하는 바램입니다. 이상으로 클라이언트 HTTP 요청부터 스프링 애플리케이션 응답하기까지의 과정을 마치도록 하겠습니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>Content-Type</tag>
        <tag>MediaType</tag>
        <tag>MessageConverter</tag>
      </tags>
  </entry>
  <entry>
    <title>엔진엑스로 알아보는 리버스 프록시</title>
    <url>/reverse-proxy-using-nginx/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p><img data-src="https://digital.com/wp-content/uploads/what-is-nginx.png"></p>
<p>오늘은 웹 서비스 인프라에서 리버스 프록시 구성을 위해 사용되는 Nginx와 함께 리버스 프록시에 대해 알아보고자 합니다.</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx는 정적 파일을 배포할 수 있는 HTTP 웹 서버입니다. 최근 애플리케이션 서버를 배포하는 경우 단독으로 구성하지 않고 Nginx를 함께 사용합니다. 아마존 웹 서비스의 Elastic Beanstalk 환경에서는 리버스 프록시 구성을 위하여 Nginx를 기본적으로 제공하고 있습니다. 이렇게 애플리케이션 서버 앞에서 먼저 트래픽을 처리하도록 구성하는 리버스 프록시를 사용하는 이유는 무엇일까요?</p>
<h3 id="리버스-프록시"><a href="#리버스-프록시" class="headerlink" title="리버스 프록시"></a>리버스 프록시</h3><p>리버스 프록시는 <strong>사용자의 요청에 대한 사후처리를 수행하여 애플리케이션 서버로 트래픽을 전달되도록 하는 것</strong>을 말합니다. 리버스 프록시 구성의 장점은 사용자에게 애플리케이션 서버가 실행되는 아이피 또는 포트를 공개하지 않거나 잘못된 요청을 애플리케이션 서버까지 전달되지 않도록하여 보호할 수 있습니다. </p>
<h3 id="로드-밸런싱"><a href="#로드-밸런싱" class="headerlink" title="로드 밸런싱"></a>로드 밸런싱</h3><p>리버스 프록시를 구성함으로써 사용자는 특정 애플리케이션 서버로 직접 요청하는 구조가 아니므로 동시에 발생하는 수 많은 웹 요청을 1개 이상으로 실행된 다수의 애플리케이션 서버로 <strong>로드밸런싱(트래픽을 분산)</strong> 함으로써 애플리케이션 서버에 대한 부하를 줄일 수 있습니다.</p>
<p>물론, 에픽 게임즈의 <a href="https://www.epicgames.com/fortnite/ko/news/postmortem-of-service-outage-at-3-4m-ccu">340만 동접자 이후 서비스 다운 관련 사후 분석 내용</a>처럼 리버스 프록시를 구성한다고해서 모든 트래픽을 감당할 수 있는 것은 아닙니다.</p>
<h3 id="SSL-오프로드"><a href="#SSL-오프로드" class="headerlink" title="SSL 오프로드"></a>SSL 오프로드</h3><p>Nginx로 리버스 프록시를 구성함으로써 수행할 수 있는 사후처리 중 하나는 <strong>SSL 오프로드</strong>입니다. 리버스 프록시를 수행하는 웹 서버에서 SSL 인증서를 관리하고 <a href="https://www.f5.com/services/resources/glossary/ssl-termination">SSL Termination</a>을 수행함으로써 애플리케이션 서버가 트래픽 암호화를 위해 수행하던 부하와 관리 포인트를 줄일 수 있습니다.</p>
<h3 id="정적-파일-캐시"><a href="#정적-파일-캐시" class="headerlink" title="정적 파일 캐시"></a>정적 파일 캐시</h3><p>애플리케이션 서버가 배포하는 정적 파일에 대해서 Nginx 자체적으로 캐시하여 정적 파일을 응답할 수 있습니다. 애플리케이션 서버로 전달되는 트래픽이 많아질 경우 정적 파일을 응답하기 위한 요청을 처리하는 것도 부담이 될 수 있습니다. 많은 트래픽을 적은 리소스를 사용하여 처리할 수 있는 웹 서버에서 정적 파일에 대한 요청을 처리하여 애플리케이션 서버의 부담을 줄일 수 있게 됩니다.</p>
<p>창천향로님의 <a href="https://jojoldu.tistory.com/60">Nginx Cache 문제 해결 시리즈</a>처럼 캐시를 잘 구성해야할 수 있습니다.</p>
<h2 id="Nginx-도커-컨테이너-학습"><a href="#Nginx-도커-컨테이너-학습" class="headerlink" title="Nginx 도커 컨테이너 학습"></a>Nginx 도커 컨테이너 학습</h2><p>도커는 어떠한 기술을 학습하기 위한 환경을 구성하기에 적합한 도구입니다. 도커를 사용하여 애플리케이션 서버와 함께 리버스 프록시를 구성하는 Nginx를 설정해보며 학습해보도록 하겠습니다.</p>
<p>저의 학습 환경은 다음과 같습니다. 환경이 다른 경우 다른 부분이 존재할 수 있으니 주의해야합니다. </p>
<ul>
<li>Docker version 20.10.8, build 3967b7d  </li>
<li>Nginx 1.21.3  </li>
<li>Amazon Corretto 11  </li>
</ul>
<p>그리고 학습에 활용된 파일들은 <a href="https://github.com/kdevkr/nginx.conf">깃허브</a>에 공유되어있으니 참고하셔도 좋습니다.</p>
<h3 id="기본-컨테이너-환경"><a href="#기본-컨테이너-환경" class="headerlink" title="기본 컨테이너 환경"></a>기본 컨테이너 환경</h3><p>도커 컴포즈를 활용하여 스프링 부트 애플리케이션과 Nginx가 구동되도록 컨테이너 환경을 구성했습니다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.21.3-alpine</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">amazoncorretto:11-alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&#x27;java -jar /etc/app.jar&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./demo-0.0.1-SNAPSHOT.jar:/etc/app.jar</span></span><br></pre></td></tr></table></figure>

<p>도커 컴포즈 명령어로 컨테이너 환경을 실행합니다.</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">docker compose up <span class="literal">-d</span></span><br><span class="line">[+] Running <span class="number">3</span>/<span class="number">3</span></span><br><span class="line"> - Network nginx_default    Created</span><br><span class="line"> - Container nginx_nginx_1  Started</span><br><span class="line"> - Container nginx_app_1    Started</span><br></pre></td></tr></table></figure>

<p>제 컴퓨터 <strong>호스트 파일에 127.0.0.1에 대하여 mambo.kr가 지정</strong>되어있으므로 다음과 같이 Nginx가 80포트에 대한 요청에 대해 기본 페이지를 응답하였습니다.</p>
<p><img data-src="/images/posts/reverse-proxy-using-nginx/nginx-02.png"></p>
<h3 id="기본-Nginx-설정"><a href="#기본-Nginx-설정" class="headerlink" title="기본 Nginx 설정"></a>기본 Nginx 설정</h3><p>도커 컴포즈 명령어로 컨테이너 진입 후 기본으로 적용되어있는 Nginx 설정을 확인해보도록 하겠습니다.</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">docker compose exec nginx sh</span><br><span class="line">/ <span class="comment"># cat /etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/reverse-proxy-using-nginx/nginx-03.png"></p>
<p>80포트를 수신하는 웹 서버 설정은 <strong>/etc/nginx/conf.d/default.conf</strong>에 위치하고 있었습니다. 다음은 default.conf에 정의된 내용 중 일부입니다.</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">/etc/nginx/conf.d <span class="comment"># cat default.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    listen  [::]:<span class="number">80</span>;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server 블록을 통해 80포트를 수신(listen)하였고 루트 경로(/)에 대한 요청을 <strong>/usr/share/nginx/html에 위치한 index.html</strong>이라는 정적 파일을 응답하도록 정의되어있습니다. </p>
<h3 id="사용자-정의-Nginx-설정"><a href="#사용자-정의-Nginx-설정" class="headerlink" title="사용자 정의 Nginx 설정"></a>사용자 정의 Nginx 설정</h3><p>기본으로 적용되어있는 nginx.conf를 볼륨으로 지정하여 사용자 정의할 수 있도록 해보겠습니다. 도커 컴포즈 문서에 Nginx 서비스에 볼륨을 지정하여 로컬 파일로 저장되어있는 nginx.conf를 지정하겠습니다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.21.3-alpine</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">  <span class="comment">#app:</span></span><br><span class="line">  <span class="comment">#  ...</span></span><br></pre></td></tr></table></figure>

<p>호스트의 443포트를 Nginx 서비스에 바인딩하였으므로 443포트를 수신하도록 정의해보겠습니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span> localhost <span class="number">127.0.0.1</span> mambo.kr;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/nginx/server.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/nginx/server.key;</span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://app:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>도커 컴포즈로 컨테이너 환경을 다시 실행하면 정상적으로…</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">nginx: [<span class="type">emerg</span>] no <span class="string">&quot;events&quot;</span> section <span class="keyword">in</span> configuration</span><br></pre></td></tr></table></figure>

<p>오류가 발생했네요. nginx.conf에 events 블록은 필수로 존재해야하는 듯 합니다.</p>
<h4 id="프로세스-및-처리-옵션"><a href="#프로세스-및-처리-옵션" class="headerlink" title="프로세스 및 처리 옵션"></a>프로세스 및 처리 옵션</h4><p>Nginx는 마스터 프로세스와 워커 프로세스로 구성되어 실제로 요청을 처리하는 것은 워커 프로세스가 담당합니다. 사용가능한 CPU 코어 수 만큼 워커 프로세스를 할당하는게 좋으며 워커 프로세스별로 사용할 수 있는 최대 열린 파일 개수 제한을 설정하는 것이 좋습니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/reverse-proxy-using-nginx/nginx-01.png" alt="Optimizations - Event Models"></p>
<p>운영체제별 <a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/optimizations/#event-models">효율적인 연결 처리 방식</a>이 있으며 리눅스 커널 2.6+에서는 <strong>epoll</strong>을 사용할 수 있습니다.</p>
<p>Nginx 서비스 컨테이너가 정상적으로 실행되지 않은 상태이므로 도커 컴포즈로 컨테이너 환경을 실행해야합니다.</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">docker compose up <span class="literal">-d</span></span><br><span class="line">[+] Running <span class="number">2</span>/<span class="number">2</span></span><br><span class="line"> - Container nginx_nginx_1  Started</span><br><span class="line"> - Container nginx_app_1    Running</span><br></pre></td></tr></table></figure>

<p>잘 실행된것으로 보이니 <a href="https://mambo.kr으로/">https://mambo.kr으로</a> 접속해보도록 하겠습니다.</p>
<p><img data-src="/images/posts/reverse-proxy-using-nginx/nginx-04.png"></p>
<p>443 포트로 요청된 트래픽이 Nginx를 경유하여 8080포트로 실행된 애플리케이션 서버로 전달되고 응답을 받았습니다. 바로 이것을 <strong>리버스 프록시</strong>라고 합니다.</p>
<h4 id="리버스-프록시-1"><a href="#리버스-프록시-1" class="headerlink" title="리버스 프록시"></a>리버스 프록시</h4><p>리버스 프록시를 구성하면 애플리케이션 서버는 어디서 요청했는지에 대한 정보를 알 수 없습니다. 그래서 Nginx와 같은 리버시 프록시를 구성하는 웹 서버에서는 프록시 관련 헤더를 함께 전달하여 어디서 요청되었는지를 전달할 수 있도록 설정할 수 있습니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span> localhost <span class="number">127.0.0.1</span> mambo.kr;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/nginx/server.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/nginx/server.key;</span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://app:8080;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="웹소켓-프록시"><a href="#웹소켓-프록시" class="headerlink" title="웹소켓 프록시"></a>웹소켓 프록시</h4><p>HTTP 1.1 프로토콜은 Hop-By-Hop이라고 하는 Upgrade 헤더를 사용하여 커넥션을 변경하는 매커니즘을 제공합니다. <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism#upgrading_to_a_websocket_connection">Upgrading to a WebSocket connection</a>과 <a href="http://nginx.org/en/docs/http/websocket.html">WebSocket proxying</a> 문서를 참고하여 다음과 같이 웹소켓 프록시에 대한 설정을 구성할 수 있습니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> /ws/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade $http_upgrade;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">65s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>프록시 서버는 기본적으로 60초 이내에 전달되는 데이터가 없는 경우 연결을 해지합니다. 예를 들어, 1분마다 웹소켓으로 전달되는 데이터가 있는 경우를 위해 proxy_read_timeout을 조정해야합니다.</p>
</blockquote>
<h4 id="이벤트-스트림-프록시"><a href="#이벤트-스트림-프록시" class="headerlink" title="이벤트 스트림 프록시"></a>이벤트 스트림 프록시</h4><p>리버스 프록시 구성에서 SSE(Server Sent Event)와 같은 이벤트 스트림을 사용하는 경우 버퍼링 옵션을 비활성화 해야합니다.</p>
<ul>
<li><a href="https://stackoverflow.com/questions/13672743/eventsource-server-sent-events-through-nginx">EventSource / Server-Sent Events through Nginx</a></li>
<li><a href="https://serverfault.com/questions/801628/for-server-sent-events-sse-what-nginx-proxy-configuration-is-appropriate">For Server-Sent Events (SSE) what Nginx proxy configuration is appropriate?</a></li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_cache</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTTPS-리다이렉트"><a href="#HTTPS-리다이렉트" class="headerlink" title="HTTPS 리다이렉트"></a>HTTPS 리다이렉트</h4><p>일반 HTTP를 사용하여 80포트로 요청한 것을 HTTPS를 사용하도록 유도하기 위해서 HTTPS 리다이렉트 응답을 적용할 수 있습니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="정적-파일-배포"><a href="#정적-파일-배포" class="headerlink" title="정적 파일 배포"></a>정적 파일 배포</h4><p>추가적으로 정적 파일이 포함된 폴더를 볼륨으로 지정하여 Nginx에서 정적 파일을 응답할 수 있도록 설정하겠습니다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.21.3-alpine</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./server.crt:/etc/nginx/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./server.key:/etc/nginx/server.key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./static:/etc/nginx/static</span></span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> _;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span> localhost <span class="number">127.0.0.1</span> mambo.kr;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/nginx/server.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/nginx/server.key;</span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://app:8080;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /dist/ &#123;</span><br><span class="line">            <span class="attribute">alias</span> /etc/nginx/static/;</span><br><span class="line">            <span class="attribute">limit_except</span> GET &#123;</span><br><span class="line">                <span class="attribute">deny</span> all;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/reverse-proxy-using-nginx/nginx-05.png"></p>
<p>정적 파일까지 응답할 수 있도록 설정하였습니다.</p>
<h3 id="Nginx-설정-최적화"><a href="#Nginx-설정-최적화" class="headerlink" title="Nginx 설정 최적화"></a>Nginx 설정 최적화</h3><p>사용자 정의한 Nginx 설정만으로도 리버스 프록시 및 정적 파일을 배포하는데에는 문제가 없습니다. 그러나 Nginx에서는 더 효율적으로 동작할 수 있도록 다양한 옵션을 제공합니다. 여러가지 옵션들을 적용해보면서 최적화해보도록 합시다.</p>
<p>Nginx 설정 최적화에 대해서는 다음의 글을 참고하면 좋습니다.</p>
<ul>
<li><a href="https://github.com/denji/nginx-tuning/blob/master/README.md">NGINX Tuning For Best Performance</a>  </li>
<li><a href="https://couplewith.tistory.com/m/entry/%EA%BF%80%ED%8C%81-%EA%B3%A0%EC%84%B1%EB%8A%A5-Nginx%EB%A5%BC%EC%9C%84%ED%95%9C-%ED%8A%9C%EB%8B%9D-1-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-IO-%EB%B3%91%EB%AA%A9-%EC%A4%84%EC%9D%B4%EA%B8%B0?category=212810">[꿀팁] 고성능 Nginx를위한 튜닝</a></li>
</ul>
<h4 id="TCP-옵션"><a href="#TCP-옵션" class="headerlink" title="TCP 옵션"></a>TCP 옵션</h4><p><a href="https://thoughts.t37.net/nginx-optimization-understanding-sendfile-tcp-nodelay-and-tcp-nopush-c55cdd276765">Nginx Optimization: understanding sendfile, tcp_nodelay and tcp_nopush</a>에서는 TCP 옵션을 지정하는 이유에 대해서 설명합니다. 네트워크 환경이 빠른 경우 TCP 스택에서 Nagle 알고리즘을 사용하는 것이 비효율적일 수 있다고 합니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="압축-옵션"><a href="#압축-옵션" class="headerlink" title="압축 옵션"></a>압축 옵션</h4><p>웹 요청에 대한 응답 데이터를 압축하는 것은 네트워크 비용을 줄이고 빠르게 응답할 수 있는 좋은 방법입니다. 서버 성능에 따라 압축 레벨을 최대한으로 지정하는 것이 좋습니다. 또한, 작은 크기에 데이터에 대하여 압축을 시도하는 것도 비효율적입니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">9</span>;</span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_disable</span> msie6;</span><br><span class="line">    <span class="attribute">gzip_proxied</span> expired <span class="literal">no</span>-cache <span class="literal">no</span>-store private auth;</span><br><span class="line">    <span class="attribute">gzip_types</span></span><br><span class="line">        <span class="comment"># text/html is always compressed by HttpGzipModule</span></span><br><span class="line">        text/css</span><br><span class="line">        text/javascript</span><br><span class="line">        text/xml</span><br><span class="line">        text/plain</span><br><span class="line">        application/javascript</span><br><span class="line">        application/json</span><br><span class="line">        application/xml</span><br><span class="line">        font/truetype</span><br><span class="line">        font/opentype</span><br><span class="line">        application/vnd.ms-fontobject</span><br><span class="line">        image/svg+xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>일반적으로 텍스트 유형의 데이터를 압축하도록 지정합니다.</p>
<h4 id="로그-옵션"><a href="#로그-옵션" class="headerlink" title="로그 옵션"></a>로그 옵션</h4><p>모든 요청에 대해 액세스 로그를 저장하는 것은 비효율적으로 I/O를 발생시킬 수 있습니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log <span class="literal">crit</span>;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">access_log</span> /var/log/nginx/access.log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="보안-옵션"><a href="#보안-옵션" class="headerlink" title="보안 옵션"></a>보안 옵션</h4><p>많은 사람들이 server_tokens 옵션을 비활성화하여 응답 헤더에 Nginx 버전을 명시하지 않도록 권장합니다. 공격자는 Nginx의 특정 버전을 알 수 없으므로 더 많은 취약점에 대한 공격을 시도해야합니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="클라이언트-옵션"><a href="#클라이언트-옵션" class="headerlink" title="클라이언트 옵션"></a>클라이언트 옵션</h4><p>연결 유지 클라이언트 수와 최대 유지 시간 그리고 클라이언트 요청 크기를 조정할 수 있습니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">keepalive_requests</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">100m</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="리눅스-커널-파라미터"><a href="#리눅스-커널-파라미터" class="headerlink" title="리눅스 커널 파라미터"></a>리눅스 커널 파라미터</h4><p>Nginx 옵션을 지정하더라도 실제로 허용할 수 있는지 리눅스 커널 파라미터를 검토해야할 수 있습니다. </p>
<ul>
<li><a href="https://ma.ttias.be/linux-increase-ip_local_port_range-tcp-port-range/">Linux increase ip_local_port_range TCP port range</a></li>
<li><a href="https://couplewith.tistory.com/entry/%EA%BF%80%ED%8C%81-%EA%B3%A0%EC%84%B1%EB%8A%A5-Nginx%EB%A5%BC%EC%9C%84%ED%95%9C-%ED%8A%9C%EB%8B%9D-3-TCP-%EA%B4%80%EB%A0%A8-%EC%B2%98%EB%A6%AC%EB%9F%89-%EB%8A%98%EB%A6%AC%EA%B8%B0-%EB%A6%AC%EB%88%85%EC%8A%A4%EC%BB%A4%EB%84%90%ED%8A%9C%EB%8B%9D">TCP 관련 처리량 늘리기 - 리눅스 커널 튜닝</a></li>
</ul>
<h3 id="Nginx-설정-마무리"><a href="#Nginx-설정-마무리" class="headerlink" title="Nginx 설정 마무리"></a>Nginx 설정 마무리</h3><p>알아본 내용을 조합하면 다음과 같이 Nginx 설정을 정의할 수 있게 됩니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 프로세스 옵션</span></span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log <span class="literal">crit</span>;</span><br><span class="line"><span class="comment">#thread_pool backend threads=32 max_queue=65536;</span></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> backend &#123;</span><br><span class="line">        <span class="attribute">server</span> app:<span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">keepalive</span> <span class="number">128</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS 리다이렉트</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> _;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS 및 HTTP2 지원</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">        <span class="attribute">server_name</span> localhost <span class="number">127.0.0.1</span> mambo.kr;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/nginx/server.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/nginx/server.key;</span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 리버스 프록시</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#aio threads=backend;</span></span><br><span class="line">            <span class="attribute">access_log</span> /var/log/nginx/access.log;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 리버스 웹소켓 프록시</span></span><br><span class="line">        <span class="attribute">location</span> /ws/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="comment"># hop-by-hop</span></span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Upgrade $http_upgrade;</span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">65s</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /dist/ &#123;</span><br><span class="line">            <span class="attribute">alias</span> /etc/nginx/static/;</span><br><span class="line">            <span class="attribute">limit_except</span> GET &#123;</span><br><span class="line">                <span class="attribute">deny</span> all;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Optimization</span></span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65s</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">100m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TCP 옵션</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Gzip 압축 옵션</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">10k</span>;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">9</span>;</span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_disable</span> msie6;</span><br><span class="line">    <span class="attribute">gzip_proxied</span> expired <span class="literal">no</span>-cache <span class="literal">no</span>-store private auth;</span><br><span class="line">    <span class="attribute">gzip_types</span></span><br><span class="line">        <span class="comment"># text/html is always compressed</span></span><br><span class="line">        text/css</span><br><span class="line">        text/javascript</span><br><span class="line">        text/xml</span><br><span class="line">        text/plain</span><br><span class="line">        application/javascript</span><br><span class="line">        application/json</span><br><span class="line">        application/xml</span><br><span class="line">        font/truetype</span><br><span class="line">        font/opentype</span><br><span class="line">        application/vnd.ms-fontobject</span><br><span class="line">        image/svg+xml;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 파일 리스트 비활성화</span></span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>도커 컴포즈를 사용하여 실행되어있는 Nginx 프로세스에 변경된 설정을 반영하면서 마치도록 하겠습니다.</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">docker compose exec nginx nginx <span class="literal">-t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line"></span><br><span class="line">docker compose exec nginx nginx <span class="literal">-s</span> reload</span><br><span class="line"><span class="number">2021</span>/<span class="number">09</span>/<span class="number">25</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">03</span> [<span class="type">notice</span>] <span class="number">34</span><span class="comment">#34: signal process started</span></span><br></pre></td></tr></table></figure>

<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>벨리데이션 오류 메시지가 사용자 언어로 처리되지 않은 이유</title>
    <url>/spring-validation/</url>
    <content><![CDATA[<blockquote>
<p>스프링 부트 애플리케이션에서 벨리데이션 오류 메시지가 사용자가 언어로 처리되지 않는 사유를 경험하여 이와 같은 문제가 발생한 이유에 대해서 알아보고 스프링에서 제공하는 벨리데이션에 대해서 정리한 글입니다.<br>관련 코드는 <a href="https://github.com/kdevkr/spring-demo-validation">spring-demo-validation</a>에서 확인할 수 있습니다.</p>
</blockquote>
<h2 id="자카르타-벨리데이션"><a href="#자카르타-벨리데이션" class="headerlink" title="자카르타 벨리데이션"></a>자카르타 벨리데이션</h2><p>스프링 부트 애플리케이션에서는 벨리데이션 스타터를 통해 <a href="https://beanvalidation.org/2.0/">자카르타 벨리데이션</a> 기반의 <a href="https://hibernate.org/validator/">하이버네이트 벨리데이터</a>를 사용하여 벨리데이션을 수행할 수 있는 기능을 제공합니다. 이 스타터가 포함되면 <strong>ValidationAutoConfiguration</strong>이라는 자동 구성 클래스를 통해 기본적인 벨리데이터(Validator)를 사용할 수 있도록 빈으로 등록해줍니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-validation&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그래서 스프링 부트 개발자들은 별도의 설정없이 컨트롤러 핸들러 함수에 전달되는 사용자 요청 정보를 간단하게 검증할 수 있게 됩니다. 또한, 하이버네이트 벨리데이터 라이브러리에는 벨리데이션을 위한 어노테이션에 대한 기본적인 <strong>벨리데이션 메시지 소스 번들</strong> 을 포함하고 있어 한국어나 영어와 같이 주요 국가에서 사용하는 언어에 대해서는 메시지를 처리하여 번역된 메시지를 사용자에게 제공할 수 있습니다.</p>
<p><img data-src="/images/posts/spring-validation/hibernate-validator-01.png" alt="org.hibernate.validator.ValidationMessages"></p>
<h3 id="유효성-검사"><a href="#유효성-검사" class="headerlink" title="유효성 검사"></a>유효성 검사</h3><p><a href="https://meetup.toast.com/posts/223">Validation 어디까지 해봤니?</a>에서 알 수 있듯이 자카르타 벨리데이션의 팩토리 함수를 통해 간단하게 벨리데이터를 생성하고 자바 빈 클래스에 저장된 정보가 올바른지 필드 검증을 쉽게 수행할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Account.Login login)</span> </span>&#123;</span><br><span class="line">        Validator validator = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Account.Login&gt;&gt; constraintViolations = validator.validate(login);</span><br><span class="line">        <span class="keyword">return</span> constraintViolations.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="로케일-이슈"><a href="#로케일-이슈" class="headerlink" title="로케일 이슈"></a>로케일 이슈</h3><p>자카르타 벨리데이션의 팩토리 함수로 만들어지는 벨리데이터는 기본값으로 정의된 설정을 통해서 벨리데이션을 수행하기 때문에 <code>사용자의 언어 정보에 따라 벨리데이션에 대한 오류 메시지가 번역되지 않는 문제</code>가 있습니다. 이러한 문제는 고객의 요구사항에 의해서 CSV 또는 엑셀 파일을 업로드하여 웹 서비스를 이용할 때 필수로 등록되어야하는 과정을 벌크 형식으로 지원해야했고 구현 과정에서 애플리케이션 컨텍스트에 등록된 벨리데이터가 아닌 팩토리 함수로 만들어지는 벨리데이터를 사용해서 벨리데이션을 수행하면서 발견되었습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LoginController : [ConstraintViolationImpl&#123;interpolatedMessage=<span class="string">&#x27;공백일 수 없습니다&#x27;</span>, propertyPath=loginId, rootBeanClass=class com.example.springboot.bean.Account<span class="variable">$Login</span>, messageTemplate=<span class="string">&#x27;&#123;javax.validation.constraints.NotBlank.message&#125;&#x27;</span>&#125;]</span><br><span class="line">LoginController : locale: en_US</span><br></pre></td></tr></table></figure>

<blockquote>
<p>위와 같이 로그인 요청 정보에 대한 벨리데이션을 수행하였고 로그인 요청을 한 사용자의 언어 정보와 함께 벨리데이션 오류에 대한 메시지를 출력해보면 사용자의 언어가 아니라 시스템 로케일 정보인 한국어로 메시지가 번역되어 처리되었음을 확인할 수 있습니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageInterpolator messageInterpolator = Validation.byDefaultProvider().configure().getDefaultMessageInterpolator();</span><br><span class="line"><span class="keyword">if</span> (messageInterpolator <span class="keyword">instanceof</span> ResourceBundleMessageInterpolator) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;defaultMessageInterpolator is ResourceBundleMessageInterpolator&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Validator validator = Validation.byDefaultProvider()</span><br><span class="line">                .configure()</span><br><span class="line">                .messageInterpolator(messageInterpolator)</span><br><span class="line">                .buildValidatorFactory()</span><br><span class="line">                .getValidator();</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Account.Login&gt;&gt; constraintViolations = validator.validate(loginInfo);</span><br></pre></td></tr></table></figure>

<p>기본 메시지 인터폴레이터를 가져와서 ResourceBundleMessageInterpolator 클래스의 인스턴스인지를 비교해보면 위 로그가 출력되는 것을 확인할 수 있습니다. 그리고 동일하게 사용자 언어가 아닌 시스템 로케일을 기반으로 메시지가 처리됨을 보여줍니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoginController : defaultMessageInterpolator is ResourceBundleMessageInterpolator</span><br><span class="line">LoginController : [ConstraintViolationImpl&#123;interpolatedMessage=&#x27;공백일 수 없습니다&#x27;, propertyPath=loginId, rootBeanClass=class com.example.springboot.bean.Account$Login, messageTemplate=&#x27;&#123;javax.validation.constraints.NotBlank.message&#125;&#x27;&#125;]</span><br><span class="line">LoginController : locale: en_US</span><br></pre></td></tr></table></figure>

<h2 id="사용자-언어-기반의-메시지-처리"><a href="#사용자-언어-기반의-메시지-처리" class="headerlink" title="사용자 언어 기반의 메시지 처리"></a>사용자 언어 기반의 메시지 처리</h2><p>기본 벨리데이터는 시스템 로케일을 기반으로 메시지가 처리됨을 확인하였으니 사용자의 언어 정보를 기반으로 메시지를 처리하기 위해서는 어떻게 하여야하는지 알아보도록 하겠습니다. <a href="https://docs.jboss.org/hibernate/validator/3.0/api/org/hibernate/validator/MessageInterpolator.html">MessageInterpolator</a> 인터페이스를 사용하여 메시지를 처리하도록 되어있기 때문에 사용자의 언어 정보를 사용하는 MessageInterpolator를 적용해야합니다.</p>
<p>스프링에서 사용자의 요청에 의한 스레드 내에서는 LocaleContextHolder 클래스를 통해 사용자의 로케일 정보를 쉽게 가져올 수 있도록 제공합니다. 그리고 이 클래스를 사용해서 로케일 정보를 가져와서 메시지를 처리하는 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/beanvalidation/LocaleContextMessageInterpolator.html"><strong>LocaleContextMessageInterpolator</strong></a>를 제공하고 있습니다.</p>
<p>기본 메시지 인터폴레이터인 ResourceBundleMessageInterpolator를 LocaleContextMessageInterpolator의 생성자로 전달하여 MessageInterpolator를 대체하여 적용해보도록 하겠습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageInterpolator messageInterpolator = Validation.byDefaultProvider().configure().getDefaultMessageInterpolator();</span><br><span class="line"><span class="keyword">if</span> (messageInterpolator <span class="keyword">instanceof</span> ResourceBundleMessageInterpolator) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;defaultMessageInterpolator is ResourceBundleMessageInterpolator&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">messageInterpolator = <span class="keyword">new</span> LocaleContextMessageInterpolator(messageInterpolator);</span><br><span class="line"></span><br><span class="line">Validator validator = Validation.byDefaultProvider()</span><br><span class="line">        .configure()</span><br><span class="line">        .messageInterpolator(messageInterpolator)</span><br><span class="line">        .buildValidatorFactory()</span><br><span class="line">        .getValidator();</span><br><span class="line"></span><br><span class="line">Set&lt;ConstraintViolation&lt;Account.Login&gt;&gt; constraintViolations = validator.validate(loginInfo);</span><br></pre></td></tr></table></figure>

<p>그리고 다시 사용자의 로그인 요청을 수행해보고 어떻게 벨리데이션 오류 메시지가 번역되는지 확인해보죠.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LoginController : [ConstraintViolationImpl&#123;interpolatedMessage=<span class="string">&#x27;must not be blank&#x27;</span>, propertyPath=loginId, rootBeanClass=class com.example.springboot.bean.Account<span class="variable">$Login</span>, messageTemplate=<span class="string">&#x27;&#123;javax.validation.constraints.NotBlank.message&#125;&#x27;</span>&#125;]</span><br><span class="line">LoginController : locale: en_US</span><br></pre></td></tr></table></figure>

<blockquote>
<p>앞선 과정을 통해서 벨리데이션에 대한 메시지 처리는 MessageInterpolator를 사용하므로 LocaleContextMessageInterpolator를 적용하면 스프링에서 관리하는 로케일 정보를 사용해서 메시지를 처리할 수 있음을 이해했습니다.</p>
</blockquote>
<h3 id="LocalValidatorFactoryBean"><a href="#LocalValidatorFactoryBean" class="headerlink" title="LocalValidatorFactoryBean"></a>LocalValidatorFactoryBean</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html">LocalValidatorFactoryBean</a>는 벨리데이션 스타터에 의해서 자동으로 등록되는 벨리데이터입니다. 컨트롤러의 핸들러 함수로 전달되는 과정에서 이 벨리데이터를 통해서 사용자의 요청 정보를 검증하며 벨리데이션 오류 메시지를 제공하게 됩니다.</p>
<p>현재 조직에서는 오래전에 공유한 <a href="managing-i18n-messages-with-xml">XML로 다국어 메시지 관리하기</a>에서처럼 XML 파일을 기반으로 다국어 메시지 정보를 관리하고 있으며 이 메시지 소스를 사용하도록 자동 구성이 아닌 LocalValidatorFactoryBean를 직접 벨리데이터 빈으로 등록하여 사용하고 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.MessageSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalValidatorFactoryBean <span class="title">validator</span><span class="params">(CustomMessageSource customMessageSource)</span> </span>&#123;</span><br><span class="line">        LocalValidatorFactoryBean factoryBean = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">        factoryBean.setValidationMessageSource(customMessageSource);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 LocalValidatorFactoryBean를 등록할 때 벨리데이션 메시지 소스를 지정하는 것은 하이버네이트 벨리데이터에 의해 클래스패스에 포함된 ValidationMessages를 사용하지 못한다는 내재된 결함을 가지게 됩니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LoginController : [ConstraintViolationImpl&#123;interpolatedMessage=<span class="string">&#x27;javax.validation.constraints.NotBlank.message&#x27;</span>, propertyPath=loginId, rootBeanClass=class com.example.springboot.bean.Account<span class="variable">$Login</span>, messageTemplate=<span class="string">&#x27;&#123;javax.validation.constraints.NotBlank.message&#125;&#x27;</span>&#125;]</span><br><span class="line">LoginController : locale: en_US</span><br></pre></td></tr></table></figure>

<blockquote>
<p>기본으로 사용되는 ValidationMessages 대신에 벨리데이션 메시지 소스를 지정하였기에 해당 메시지로 처리되지 않았습니다. 왜냐하면 JSR-303 어노테이션에 대한 메시지는 직접 정의하지 않았기 때문이죠.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalValidatorFactoryBean <span class="title">validator</span><span class="params">(CustomMessageSource messageSource)</span> </span>&#123;</span><br><span class="line">    LocalValidatorFactoryBean factoryBean = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">    factoryBean.setValidationMessageSource(messageSource);</span><br><span class="line"></span><br><span class="line">    MessageInterpolator defaultMessageInterpolator = Validation.byDefaultProvider().configure().getDefaultMessageInterpolator();</span><br><span class="line">    LocaleContextMessageInterpolator localeContextMessageInterpolator = <span class="keyword">new</span> LocaleContextMessageInterpolator(defaultMessageInterpolator);</span><br><span class="line">    factoryBean.setMessageInterpolator(localeContextMessageInterpolator);</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>현재 조직처럼 사용자 정의 메시지 소스를 벨리데이션 메시지 소스로도 사용하도록 지정하였다면 위와 같이 MessageInterpolator를 지정하는게 좋습니다. 이때에도 사용자의 언어 정보에 따라 메시지가 처리되도록 LocaleContextMessageInterpolator를 적용해야합니다.</p>
<h4 id="MessageInterpolatorFactory"><a href="#MessageInterpolatorFactory" class="headerlink" title="MessageInterpolatorFactory"></a>MessageInterpolatorFactory</h4><p>LocalValidatorFactoryBean을 자동 구성하는 ValidationAutoConfiguration 클래스를 살펴보면 LocaleContextMessageInterpolator이 아니라 스프링 부트에서 추가된 MessageInterpolatorFactory를 통해 MessageInterpolator를 가져와서 등록하는 것을 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalValidatorFactoryBean <span class="title">defaultValidator</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        LocalValidatorFactoryBean factoryBean = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">        MessageInterpolatorFactory interpolatorFactory = <span class="keyword">new</span> MessageInterpolatorFactory(applicationContext);</span><br><span class="line">        factoryBean.setMessageInterpolator(interpolatorFactory.getObject());</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이를 참고하여 사용자 정의 메시지 소스 번들을 벨리데이션 메시지 소스로 지정하였더라도 MessageInterpolatorFactory를 통해 ResourceBundleMessageInterpolator에 의해서 메시지가 번역되어 처리됨을 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalValidatorFactoryBean <span class="title">validator</span><span class="params">(CustomMessageSource messageSource)</span> </span>&#123;</span><br><span class="line">    LocalValidatorFactoryBean factoryBean = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">    factoryBean.setValidationMessageSource(messageSource);</span><br><span class="line"></span><br><span class="line">    MessageInterpolatorFactory messageInterpolatorFactory = <span class="keyword">new</span> MessageInterpolatorFactory();</span><br><span class="line">    factoryBean.setMessageInterpolator(messageInterpolatorFactory.getObject());</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>그런데 앞선 자카르타 팩토리 함수에 의해 생성된 벨리데이터도 ResourceBundleMessageInterpolator를 사용하였는데 어떻게 LocalValidatorFactoryBean는 사용자 언어 정보에 따라 오류 메시지를 처리해주게 되는 것일까요?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageInterpolator targetInterpolator = <span class="keyword">this</span>.messageInterpolator;</span><br><span class="line"><span class="keyword">if</span> (targetInterpolator == <span class="keyword">null</span>) &#123;</span><br><span class="line">    targetInterpolator = configuration.getDefaultMessageInterpolator();</span><br><span class="line">&#125;</span><br><span class="line">configuration.messageInterpolator(<span class="keyword">new</span> LocaleContextMessageInterpolator(targetInterpolator));</span><br></pre></td></tr></table></figure>

<p>위 코드는 LocalValidatorFactoryBean이 빈으로 등록되고 난 후 afterPropertiesSet 함수에 의해 수행되는 코드 중 일부입니다. LocalValidatorFactoryBean을 빈으로 등록할 때 MessageInterpolatorFactory에 의해 가져온 ResourceBundleMessageInterpolator를 지정하였지만 이를 다시 LocaleContextMessageInterpolator로 변환하여 등록함을 확인할 수 있습니다. </p>
<p>결국 LocalValidatorFactoryBean을 빈으로 등록할 때는 다음과 같이 LocaleContextMessageInterpolator를 전달하지 않아도 됨을 의미합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalValidatorFactoryBean <span class="title">validator</span><span class="params">(CustomMessageSource messageSource)</span> </span>&#123;</span><br><span class="line">    LocalValidatorFactoryBean factoryBean = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">    factoryBean.setValidationMessageSource(messageSource);</span><br><span class="line">    factoryBean.setMessageInterpolator(Validation.byDefaultProvider().configure().getDefaultMessageInterpolator());</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="사용자-정의-메시지"><a href="#사용자-정의-메시지" class="headerlink" title="사용자 정의 메시지"></a>사용자 정의 메시지</h3><p>그렇다면 다음과 같이 ValidationMessages에 정의된 메시지 코드를 정의하면 어떻게 메시지가 처리될까요?</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">messages</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;javax.validation.constraints.NotBlank.message&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ko_KR</span>&gt;</span>&lt;![CDATA[[사용자 정의] 공백일 수 없습니다]]&gt;<span class="tag">&lt;/<span class="name">ko_KR</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">en_US</span>&gt;</span>&lt;![CDATA[[Custom] must not be blank]]&gt;<span class="tag">&lt;/<span class="name">en_US</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">messages</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>NotBlank에 대한 메시지를 정의했지만 ValidationMessages에 정의된 메시지로 처리됨을 확인할 수 있을겁니다. 이렇게 되는 이유는 setValidationMessageSource 함수 동작에 있습니다. setValidationMessageSource 함수의 코드를 살펴보면 파라미터로 전달된 메시지 소스를 기반으로 ResourceBundleMessageInterpolator를 만들어서 MessageInterpolator를 변경하도록 되어있기 때문입니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValidationMessageSource</span><span class="params">(MessageSource messageSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageInterpolator = HibernateValidatorDelegate.buildMessageInterpolator(messageSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateValidatorDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageInterpolator <span class="title">buildMessageInterpolator</span><span class="params">(MessageSource messageSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResourceBundleMessageInterpolator(<span class="keyword">new</span> MessageSourceResourceBundleLocator(messageSource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>결국 setValidationMessageSource와 setMessageInterpolator는 동시에 적용할 수 없으므로 사용자 정의 메시지 소스를 지정한 것이 의미없는 쓰레기 코드가 됩니다.</p>
</blockquote>
<p>스프링 부트 2.6.0 버전부터는 MessageInterpolatorFactory 생성자가 메시지 소스를 받을 수 있도록 수정되었고 생성자에 의해 전달된 메시지 소스가 있다면 MessageSourceMessageInterpolator로 변경하여주는 코드가 추가되어있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageInterpolator <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    MessageInterpolator messageInterpolator = getMessageInterpolator();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageSourceMessageInterpolator(<span class="keyword">this</span>.messageSource, messageInterpolator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> messageInterpolator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="사용자-정의-제약사항"><a href="#사용자-정의-제약사항" class="headerlink" title="사용자 정의 제약사항"></a>사용자 정의 제약사항</h3><p>사용자 정의 메시지 소스를 제공하더라도 메시지 패턴에서 {value}와 같은 파라미터 표현이 불가능합니다. 예를 들어, 다음과 같이 어떤 값에 대한 길이를 제한한다고 가정하여 @Min 어노테이션을 부여했다고 가정하겠습니다.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">messages</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;javax.validation.constraints.Min.message&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ko_KR</span>&gt;</span>&lt;![CDATA[(사용자 정의) &#123;value&#125; 보다 같거나 커야합니다]]&gt;<span class="tag">&lt;/<span class="name">ko_KR</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">en_US</span>&gt;</span>&lt;![CDATA[(Custom) must be greater than or equal to &#123;value&#125;]]&gt;<span class="tag">&lt;/<span class="name">en_US</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">messages</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>사용자 정의 메시지에서 VailidationMessages에 정의된 것처럼 파라미터 표현을 사용해보겠습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.web.util.NestedServletException: Request processing failed; nested exception is javax.validation.ValidationException: HV000149: An exception occurred during message interpolation</span><br><span class="line">...</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: can&#x27;t parse argument number: value</span><br><span class="line">	at java.base/java.text.MessageFormat.makeFormat(MessageFormat.java:1451) ~[na:na]</span><br><span class="line">	at java.base/java.text.MessageFormat.applyPattern(MessageFormat.java:491) ~[na:na]</span><br><span class="line">	at java.base/java.text.MessageFormat.&lt;init&gt;(MessageFormat.java:390) ~[na:na]</span><br><span class="line">...</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: &quot;value&quot;</span><br><span class="line">	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) ~[na:na]</span><br><span class="line">	at java.base/java.lang.Integer.parseInt(Integer.java:652) ~[na:na]</span><br><span class="line">	at java.base/java.lang.Integer.parseInt(Integer.java:770) ~[na:na]</span><br><span class="line">	at java.base/java.text.MessageFormat.makeFormat(MessageFormat.java:1449) ~[na:na]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>이러한 파라미터 표현은 Hibernate Validator에서 지원하는 표현식이므로 MessageFormat가 지원하는 표현식과는 다릅니다. MessageFormat는 {0}, {1} 이렇게 숫자 기반의 표현식을 지원하기 때문에 표현식 제약이 발생합니다. 아쉽지만 사용자 정의 메시지에서 파라미터 표현식을 사용하지 않을 수 밖에 없고 파라미터 표현식을 사용해야한다면 ValidationMessages 리소스 번들을 클래스패스에 재정의해서 사용할 수 밖에 없습니다. </p>
</blockquote>
<p>언어별 메시지가 정의된 프로퍼티 파일을 보완하고자 XML로 메시지를 정의하여 메시지 소스를 만들어서 사용했지만 의도하지 않은 제약이 생겨버렸습니다. 불편하더라도 벨리데이션 메시지는 프로퍼티 파일로 관리해서 ResourceBundleMessageInterpolator에 의해 처리되도록 해야할 것 같습니다.</p>
<p>감사합니다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="/managing-i18n-messages-with-xml">XML로 다국어 메시지 관리하기</a></li>
<li><a href="https://meetup.toast.com/posts/223">Validation 어디까지 해봤니?</a></li>
</ul>
]]></content>
      <tags>
        <tag>Jakarta Bean Validation</tag>
        <tag>Hibernate Validator</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL 인증서</title>
    <url>/ssl-certificate/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 웹사이트 접속 시 필수적으로 사용되는 HTTPS 그리고 SSL 인증서에 대해 이야기하려합니다. 회사에서 운영중인 웹 서비스를 HTTPS로 배포되고있으나 정작 SSL에 대한 부분은 머리속에서 복잡하게 얽혀 제대로 정리되지않은 상태입니다. 이 글을 작성하면서 얽혀있는 부분을 하나씩 풀어나가면서 SSL에 대한 개념을 확립해보고자 합니다.</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>일반 사람들이 브라우저를 이용해서 웹 사이트에 접속할 때 HTTPS가 적용되었는지에 대해서 신경쓰지 않습니다. 하지만, 애플리케이션 서버를 운영하는 사람들에게 HTTPS는 사용자의 민감한 정보를 암호화해서 위조 또는 변조되는 것을 방지할 수 있는 아주 중요한 표준 보안 기술입니다. </p>
<p>크롬과 같은 브라우저에서는 HTTPS와 같은 보안 프로토콜이 적용되었는지를 확인하고 사용자들에게 신뢰할 수 있는 사이트인지를 안내합니다. 브라우저 주소창 옆에 느낌표나 자물쇠 아이콘을 보신적 있으신가요? 여러분의 웹 사이트가 자물쇠 아이콘을 가진다면 보안 프로토콜을 사용하고 있으며 신뢰할 수 있는 사이트라고 할 수 있습니다.</p>
<p>HTTPS는 HTTP라는 전송 프로토콜과 함께 데이터를 암복호화하기 위한 보안 프로토콜을 같이 사용해야하기 때문에 추가적인 오버헤드가 발생하는 부분에 대해서는 감안해야합니다. 하지만, 최근 컴퓨터들의 CPU 성능이 좋아짐에 따라서 암복호화 걸리는 시간은 상당히 미미하며 네트워크 기술의 발전으로 레이턴시도 줄어들었기 때문에 HTTPS을 사용한다고해서 사용자가 요청하고 응답하기까지의 시간이 큰 차이를 보이지는 않습니다.</p>
<h3 id="TLS-핸드쉐이크"><a href="#TLS-핸드쉐이크" class="headerlink" title="TLS 핸드쉐이크"></a>TLS 핸드쉐이크</h3><p>HTTPS가 적용된 애플리케이션 서버와 통신하기 위해서는 클라이언트인 브라우저가 애플리케이션 서버와 TLS 핸드쉐이크 과정을 수행해야합니다.</p>
<p><img data-src="https://images.ctfassets.net/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png" alt="Cloudflare - What is a TLS handshake?"></p>
<p><strong>TLS 핸드쉐이크</strong>는 웹 요청에 대한 신뢰성 여부를 확인하거나 통신 데이터를 암복호화하기 위한 방식을 서로 교환하기 위해 수행하는 과정입니다. 위 클라우드플레어에서 설명하는 TLS 핸드쉐이크 과정을 살펴보면 애플리케이션 서버가 클라이언트에게 인증서(Certificate)를 제공하고 서로 암호화 방식(CipherSpec)을 교환하는 것을 확인할 수 있습니다.</p>
<p>크롬 브라우저의 개발자 도구 중 보안 탭에서 TLS 핸드쉐이크 과정에 의해 결정된 여러가지 사항들을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-01.png" alt="네이버 웹 사이트"></p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-02.png" alt="회사 웹 사이트"></p>
<p>네이버 웹 사이트는 <strong>DigiCert</strong>라는 인증기관에서 발행한 SSL 인증서를 제공하였고 <strong>TLS 1.3</strong> 버전과 함께 <strong><a href="https://en.wikipedia.org/wiki/Curve25519">X25519</a></strong> 방식으로 키를 교환하고 <strong>AES_256_GCM</strong>으로 암호화하며 회사에서 운영중인 웹 서비스는 네이버와 다르게 <strong>TLS 1.2</strong>, <strong>ECDHE_ECDSA</strong>, <strong>AES_128_GCM</strong>을 사용합니다. 여러분들도 HTTPS를 적용한 웹 사이트를 운영중이거나 궁금한 사이트가 있다면 어떤 사항으로 결정되었는지 확인해보시기 바랍니다. TLS 핸드쉐이크 과정에 의해 결정되는 사항들은 애플리케이션 서버가 지원하는 사항들과 클라이언트에 따라 다를 수 있습니다. 이제 우리는 이러한 사항들에 대해서 하나씩 알아보도록 하죠.</p>
<h3 id="TLS-버전"><a href="#TLS-버전" class="headerlink" title="TLS 버전"></a>TLS 버전</h3><p>TLS 버전은 TLS 핸드쉐이크 과정을 수행하는 방식을 말합니다. 당연스럽게도 버전이 높은 TLS 1.3이 TLS 1.2보다 효율적인 방식이라고 할 수 있습니다. 클라이언트는 애플리케이션 서버에서 지원하는 TLS 버전 중 가장 높은 버전으로 TLS 핸드쉐이크를 수행할 수 있습니다. 만약, 클라이언트가 TLS 1.1까지만 사용할 수 있는데 애플리케이션 서버가 TLS 1.2 이상을 요구한다면 일치하는 TLS 버전이 없기 때문에 애플리케이션 서버는 TLS 1.1을 사용하고자하는 클라이언트 요청을 거부하게 됩니다.</p>
<p>크롬 브라우저는 이미 <a href="https://www.chromestatus.com/feature/5759116003770368">TLS 1.0과 TLS 1.1 버전을 사용하지 않기 때문에</a> 여러분의 애플리케이션 서버는 최소한 TLS 1.2 버전을 사용할 수 있도록 지원해야합니다. </p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-12.png"></p>
<p>위는 회사에서 운영중인 애플리케이션 서버의 로그를 살펴본 경우로 <strong>SSLv3, TLSv1.0, TLS v1.1</strong>등의 TLS 버전을 사용하려는 클라이언트 요청이 거부된 것이 오류 로그로 출력된 상황을 보여줍니다. 이 애플리케이션 서버는 AWS Beanstalk와 함께 NLB(Network Load Balancer)를 사용하며 NLB는 TCP 트래픽에 대하여 분산된 애플리케이션 서버로 프록시되도록 구성했기때문에 L4 로드밸런서에서 TLS 핸드쉐이크가 처리되지 않았음을 보여주는 것이기도 합니다.</p>
<blockquote>
<p>NLB에서 TLS 핸드쉐이크를 수행하도록 설정할 수도 있으며 IT 인프라 상 TLS 핸드쉐이크를 애플리케이션 서버에서 수행하는 것이 잘못된 구성은 아닙니다.</p>
</blockquote>
<h4 id="HTTP-3-그리고-QUIC"><a href="#HTTP-3-그리고-QUIC" class="headerlink" title="HTTP/3 그리고 QUIC"></a>HTTP/3 그리고 QUIC</h4><p>통신 프로토콜에 대해서 관심이 있는 분들은 QUIC 이라고하는 전송 프로토콜에 대해서 들어보신 적 있으실 겁니다. TCP가 아닌 오버헤드가 적은 UDP를 사용하는 프로토콜로 구글 웹 사이트에 대해 TLS 핸드쉐이크 과정에 의해 결정된 사항을 확인해보면 다음과 같이 TLS가 아닌 QUIC을 사용한 것으로 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-03.png"></p>
<p>QUIC은 TLS를 기본으로 사용하도록 되어있으며 TLS는 보안 프로토콜이기 때문에 HTTP가 아닌 전송 프로토콜과도 사용할 수 있다는 것을 보여주는 예 입니다. 구글 웹 사이트 뿐만 아니라 여러분이 라이브러리등 정적 컨텐츠를 받아오기 위해 사용하는 CDN 서버를 살펴보면 <strong>h3-29</strong>라고 하는 QUIC의 표준 이름을 확인할 수 있습니다.</p>
<p>아무튼 다시 TLS 버전에 대한 사항을 더 알아보도록 하겠습니다. 국내 개발자 커뮤니티 중 하나인 OKKY 사이트의 애플리케이션 서버에서 지원하는 TLS 버전을 확인해보기 위해 <a href="https://gf.dev/tls-test">Check TLS Version</a>을 수행해본 결과입니다.</p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-04.png"></p>
<p>TLS 1.3을 제외한 나머지 버전을 지원하는 것으로 리포트 되었습니다. 다시 말하지만 크롬 브라우저는 TLS 1.2 이상을 지원하기 때문에 애플리케이션 서버가 TLS 1.3을 지원하지 않더라도 아무런 문제가 없습니다. 사람들이 많이 사용하는 크롬 브라우저에서 TLS 1.2 지원하지않도록 발표하면 애플리케이션 서버에서 TLS 1.3을 지원하도록 변경하는 것은 불가피한 상황이긴 합니다. 물론, 회사에서 운영중인 애플리케이션 서버도 마찬가지인 상황입니다.</p>
<h3 id="암호화-스위트"><a href="#암호화-스위트" class="headerlink" title="암호화 스위트"></a>암호화 스위트</h3><p>암호화 스위트(Cipher Suite)는 <strong>키 교환</strong>, <strong>전자 서명</strong>, <strong>암호화</strong> 그리고 <strong>데이터 무결성</strong>에 대한 알고리즘을 조합한 암호화 방식을 지칭합니다. 앞서 TLS 핸드쉐이크 과정에서 결정된 사항 중 <strong>ECDHE_ECDSA</strong> 그리고 <strong>AES_128_GCM</strong>이 암호화 스위트라고 할 수 있습니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [프로토콜]_[키 교환 알고리즘]_[전자 서명 알고리즘]_WITH_[암호화 알고리즘]_[데이터 무결성]</span></span><br><span class="line">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</span><br></pre></td></tr></table></figure>

<p>암호화 스위트는 위와 같은 구조를 가지도록 조합된 문자열으로 표현하기 때문에 아래와 같이 다시 나열해보겠습니다.</p>
<ul>
<li>TLS : 프로토콜</li>
<li>ECDHE : 타원 곡선 디피 헬만 키 교환</li>
<li>ECDSA : 타원 곡선 디지털 서명</li>
<li>AES_128_GCM : 128 비트 블록 갈루와/카운트 모드의 AES 암호화</li>
<li>SHA256 : 256비트 해시 알고리즘</li>
</ul>
<p>보안 전문가가 아니라면 ECDHE-ECDSA가 어떤 원리도 동작하는지까지는 알 필요는 없으며 어떻게 키 교환을 하고 어떤 방식으로 서명하며 어떻게 암호화하는지만 구분할 수 있으면 됩니다. 검색해보시더라도 보안 기술을 이해하기는 쉽지 않으실 겁니다. (우리의 시간은 소중하니까요…)</p>
<p>이러한 암호화 스위트는 <a href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/network/create-tls-listener.html">AWS의 ELB(Elastic Load Balancing)의 보안 정책</a>에서도 정책별 지원 여부를 확인할 수 있습니다. </p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-13.png" alt="ELB Security Policy"></p>
<h2 id="SSL-인증서"><a href="#SSL-인증서" class="headerlink" title="SSL 인증서"></a>SSL 인증서</h2><p>TLS 핸드쉐이크 과정에서 클라이언트가 애플리케이션 서버로부터 받는 SSL 인증서는 브라우저 해당 사이트를 신뢰할 수 있는지를 판단할 수 있는 중요한 사항입니다. 브라우저에서는 자체적으로 <strong>신뢰할 수 있는 인증 기관(CA)</strong> 에 대해 관리하거나 운영체제에 등록된 루트 인증 기관에 대한 정보를 활용해서 서버에서 제공하는 SSL 인증서가 신뢰할 수 있는 기관으로부터 발급된 것인지 확인하는 과정을 거치게 됩니다.</p>
<p>일반적으로 서버에서 제공받은 SSL 인증서는 루트 인증 기관(CA)에서 인증하는 <strong>중간 인증 기관(ICA)</strong> 으로부터 발급받은 인증서이며 이를 <strong>체인 인증서</strong>라고 합니다. <a href="https://sectigo.com/">Sectigo</a>와 <a href="https://www.digicert.com/kr/">DigiCert</a> 그리고 <a href="https://www.globalsign.com/en">GlobalSign</a>은 많이 사용되어지는 신뢰할 수 있는 루트 인증 기관입니다. </p>
<p>암호화 스위트 중 ECDSA와 같은 타원 곡선 디지털 서명으로 발급된 인증서를 <strong>ECC 인증서</strong>라고하며 일반적으로 많이 사용해왔던 RSA 기반의 인증서보다 트래픽이 많은 서비스에서 암복호화에 대한 부하를 줄이기 위해 사용하는 인증서입니다.</p>
<p>이 글에서는 타원 곡선형 서명 방식으로 발급하는 ECC 인증서를 만들어볼 예정입니다.</p>
<h3 id="자체-서명-인증서"><a href="#자체-서명-인증서" class="headerlink" title="자체 서명 인증서"></a>자체 서명 인증서</h3><p>자체 서명 인증서는 신뢰할 수 있는 인증 기관으로부터 발급받지 않고 직접 만드는 인증서를 말합니다. 애플리케이션 개발 단계에서 자체 서명 인증서를 발급하여 사용하는 것은 도메인을 구입하고 인증 기관으로부터 인증서를 받기까지의 과정을 당장 수행하지 않아도 되는 좋은 방법입니다.</p>
<p>보유중인 도메인이 있다면 <a href="https://letsencrypt.org/">Let’s Encrypt</a>을 통해 무료로 SSL 인증서를 발급받을수도 있습니다. 저는 보유중인 도메인이 없기 때문에 OpenSSL 또는 자바의 Keystore 도구를 사용해서 자체 서명 인증서를 만들어볼 예정입니다.</p>
<p>이 글에서는 인증 기관에서 애플리케이션 서버에 대한 인증서를 발급할 때 서명해주는 것과 동일하게 자체 서명 CA 인증서를 만들고 이것으로 서명된 서버 인증서를 발급하는 과정을 보여줍니다. 이 과정을 통해 여러분은 발급받은 SSL 서버 인증서가 어떤 과정을 거쳐 발급되었는지를 이해할 수 있습니다.</p>
<h4 id="자체-서명-CA-인증서-발급"><a href="#자체-서명-CA-인증서-발급" class="headerlink" title="자체 서명 CA 인증서 발급"></a>자체 서명 CA 인증서 발급</h4><p>먼저, 로컬 호스트에서는 신뢰할 수 있다고 보장하는 CA 인증서를 발급합니다. 인증서는 <a href="(https://www.sslcert.co.kr/guides/kb/54)">다양한 형식</a>으로 만들어질 수 있으나 OpenSSL 도구를 사용하여 인증서를 만들면 PEM 형식을 가지게 됩니다. 만약, 여러분이 인증 기관으로부터 발급받는 인증서 형식이 다르더라도 다른 형식의 인증서로 변환할 수 있으니 걱정하지 않으셔도 됩니다. 예를 들어, 발급된 PEM 형식의 서버 인증서를 스프링 애플리케이션에서 사용하기 위해 KeyStore 형식의 인증서로 변환해야하는 경우를 말합니다.</p>
<p>OpenSSL으로 자체 서명 CA 인증서를 만들기 위해서는 개인키와 인증서 서명 요청(CSR)을 먼저 생성해야합니다. 앞서 언급했던 것 처럼 일반적으로 발급하는 RSA 기반의 개인키가 아닌 ECC 인증서를 발급하기 위한 <strong>ECDSA 기반의 개인키</strong>를 만들겠습니다.</p>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># ECDSA 기반의 개인키 생성</span></span><br><span class="line"><span class="built_in">PS</span> openssl ecparam <span class="literal">-out</span> ca.key <span class="literal">-name</span> prime256v1 <span class="literal">-genkey</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 인증서 서명 요청(CSR) 생성</span></span><br><span class="line"><span class="built_in">PS</span> openssl req <span class="literal">-new</span> <span class="literal">-sha256</span> <span class="literal">-subj</span> /C=KO/ST=None/L=None/O=None/CN=CA <span class="literal">-key</span> ca.key <span class="literal">-out</span> ca.csr</span><br></pre></td></tr></table></figure>

<p>위 명령어 예시에서 개인키를 만들때 사용된 <strong>prime256v1</strong>은 타원 곡선형 서명 방식을 지칭하는 이름입니다. 명령어를 수행하고나서 개인키와 인증서 서명 요청 파일이 만들어졌으면 다음의 명령어를 수행해서 자체 서명 CA 인증서를 발급합니다.</p>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> openssl x509 <span class="literal">-req</span> <span class="literal">-sha256</span> <span class="literal">-days</span> <span class="number">1095</span> <span class="operator">-in</span> ca.csr <span class="literal">-signkey</span> ca.key <span class="literal">-out</span> ca.crt</span><br><span class="line">Signature ok</span><br><span class="line">subject=C = KO, ST = None, L = None, O = None, CN = CA</span><br><span class="line">Getting Private key</span><br></pre></td></tr></table></figure>

<p>-days 옵션으로 인해 만들어진 자체 서명 CA 인증서는 3년(1095일)까지 유효하게 됩니다. 일반적으로 인증 기관의 인증서는 서버 인증서보다 긴 만료일자를 가지게 됩니다. 서버 인증서 뿐만 아니라 루트 인증 기관의 CA 인증서가 언제 만료되는지를 확인하는 것도 중요합니다.</p>
<h4 id="자체-서명-서버-인증서-발급"><a href="#자체-서명-서버-인증서-발급" class="headerlink" title="자체 서명 서버 인증서 발급"></a>자체 서명 서버 인증서 발급</h4><p>자체 서명한 CA 인증서가 준비되었으니 CA 인증서로 서명한 서버 인증서를 발급합니다. CA 인증서를 만들때와 동일하게 개인키와 인증서 서명 요청 파일을 생성합니다.</p>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> openssl ecparam <span class="literal">-out</span> server.key <span class="literal">-name</span> prime256v1 <span class="literal">-genkey</span></span><br><span class="line"><span class="built_in">PS</span> openssl req <span class="literal">-new</span> <span class="literal">-sha256</span> <span class="literal">-subj</span> /C=KO/ST=None/L=None/O=None/CN=localhost <span class="literal">-key</span> server.key <span class="literal">-out</span> server.csr</span><br></pre></td></tr></table></figure>

<p>자체 서명 서버 인증서를 만들때는 CA 옵션을 사용해서 서버 인증서가 CA 인증서에 의해 서명되도록 해야합니다. </p>
<p>서버 인증서를 만들기에 앞서 주체 이름인 localhost 대신에 사용할 수 있는 식별 이름인 SAN(Subject Alternative Name)을 적용하기 위한 파일을 만듭니다. SAN을 적용해보는 이유는 하나의 인증서로 여러 도메인을 식별할 수 있음을 확인하기 위함입니다.</p>
<figure class="highlight plaintext"><figcaption><span>san.ext</span></figcaption><table><tr><td class="code"><pre><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">IP.1 = 127.0.0.1</span><br><span class="line">DNS.1 = localhost</span><br><span class="line">DNS.2 = mambo.kr</span><br></pre></td></tr></table></figure>

<p>인증 기관에서 발급하는 SSL 인증서는 유효 기간을 1년으로 설정하므로 398일 동안 유효하도록 만듭니다.</p>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 서버 인증서 발급</span></span><br><span class="line"><span class="built_in">PS</span> openssl x509 <span class="literal">-req</span> <span class="literal">-sha256</span> <span class="literal">-days</span> <span class="number">398</span> <span class="operator">-in</span> server.csr <span class="literal">-CA</span> ca.crt <span class="literal">-CAkey</span> ca.key <span class="literal">-CAcreateserial</span> <span class="literal">-out</span> server.crt <span class="literal">-extfile</span> san.ext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 서버 인증서 조회</span></span><br><span class="line"><span class="built_in">PS</span> openssl x509 <span class="operator">-in</span> server.crt <span class="literal">-text</span> <span class="literal">-noout</span></span><br><span class="line">Certificate:</span><br><span class="line">    <span class="keyword">Data</span>:</span><br><span class="line">        Version: <span class="number">3</span> (<span class="number">0</span>x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            <span class="number">66</span><span class="emoji" alias="ab" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f18e.png?v8">&#x1f18e;</span>bb:ed:<span class="number">19</span>:f3:c7:<span class="number">37</span>:<span class="number">9</span>d:d6:<span class="number">5</span>d:<span class="number">29</span>:da:<span class="number">03</span>:<span class="number">7</span>d:b9:<span class="number">4</span>f:<span class="number">53</span>:<span class="number">7</span>c:b7</span><br><span class="line">        Signature Algorithm: ecdsa<span class="literal">-with</span><span class="literal">-SHA256</span></span><br><span class="line">        Issuer: C = KO, ST = None, L = None, O = None, CN = CA</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Aug <span class="number">27</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">54</span> <span class="number">2021</span> GMT</span><br><span class="line">            Not After : Sep <span class="number">29</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">54</span> <span class="number">2022</span> GMT</span><br><span class="line">        Subject: C = KO, ST = None, L = None, O = None, CN = localhost</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: id<span class="literal">-ecPublicKey</span></span><br><span class="line">                Public<span class="literal">-Key</span>: (<span class="number">256</span> bit)</span><br><span class="line">                pub:</span><br><span class="line">                    <span class="number">04</span>:<span class="number">74</span>:<span class="number">06</span>:a3:<span class="number">39</span>:<span class="number">91</span>:<span class="number">2</span>e:<span class="number">4</span>b:cc:<span class="number">45</span>:<span class="number">40</span>:e8:b0:f8:a3:</span><br><span class="line">                    <span class="number">96</span>:<span class="number">69</span>:<span class="number">91</span>:<span class="number">66</span>:ef:d3:b3:<span class="number">93</span>:<span class="number">8</span>d:e5:<span class="number">09</span>:<span class="number">78</span>:aa:a5:af:</span><br><span class="line">                    <span class="number">67</span>:<span class="number">9</span>d:<span class="number">47</span>:<span class="number">13</span>:<span class="number">78</span>:<span class="number">54</span>:<span class="number">7</span>e:d9:<span class="number">02</span>:ba:e4:ca:aa:d4:<span class="number">9</span>f:</span><br><span class="line">                    <span class="number">8</span>b:f3:be:d7:<span class="number">40</span>:<span class="number">1</span>e:f5:c4:<span class="number">8</span>d:<span class="number">7</span>a:<span class="number">23</span>:<span class="number">5</span>b:<span class="number">09</span>:c3:<span class="number">57</span>:</span><br><span class="line">                    <span class="number">75</span>:<span class="number">38</span>:<span class="number">7</span>e:<span class="number">4</span>d:e6</span><br><span class="line">                ASN1 OID: prime256v1</span><br><span class="line">                NIST CURVE: P<span class="literal">-256</span></span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Authority Key Identifier:</span><br><span class="line">                DirName:/C=KO/ST=None/L=None/O=None/CN=CA</span><br><span class="line">                serial:<span class="number">5</span>D:<span class="number">98</span>:<span class="number">7</span>B:BF:<span class="number">10</span>:<span class="number">35</span>:<span class="number">6</span>B:<span class="number">9</span>C:<span class="number">11</span>:<span class="number">97</span>:<span class="number">2</span>C:<span class="built_in">AC</span>:<span class="number">21</span>:E3:<span class="number">28</span>:C2:FF:AF:<span class="number">2</span>D:<span class="number">3</span>D</span><br><span class="line"></span><br><span class="line">            X509v3 Subject Alternative Name:</span><br><span class="line">                IP Address:<span class="number">127.0</span>.<span class="number">0.1</span>, DNS:localhost, DNS:mambo.kr</span><br><span class="line">    Signature Algorithm: ecdsa<span class="literal">-with</span><span class="literal">-SHA256</span></span><br><span class="line">         <span class="number">30</span>:<span class="number">46</span>:<span class="number">02</span>:<span class="number">21</span>:<span class="number">00</span>:ce:<span class="number">5</span>d:<span class="number">3</span>a:<span class="number">68</span>:e9:<span class="number">04</span>:dc:a9:fd:e6:<span class="number">14</span><span class="emoji" alias="de" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f1e9-1f1ea.png?v8">&#x1f1e9;&#xfe0f;&#x200d;&#x1f1ea;</span>bb:</span><br><span class="line">         <span class="number">11</span>:<span class="number">5</span>c:<span class="number">5</span>a:a1:bf:b4:f9:<span class="number">1</span>a:<span class="number">61</span>:<span class="number">08</span>:<span class="built_in">cd</span>:da:<span class="number">47</span>:d1:b4:<span class="number">68</span>:<span class="number">80</span>:<span class="number">81</span>:</span><br><span class="line">         d1:<span class="number">02</span>:<span class="number">21</span>:<span class="number">00</span>:e7:a1:b4:cb:<span class="number">06</span>:<span class="number">6</span>d:ad:<span class="number">80</span>:d3:<span class="number">89</span>:<span class="number">09</span>:c1:<span class="number">1</span>e:ca:</span><br><span class="line">         <span class="number">6</span>e:c7:<span class="number">2</span>e:<span class="number">14</span>:fd:<span class="number">99</span>:d9:df:<span class="number">44</span>:<span class="number">14</span>:cb:<span class="number">47</span>:<span class="number">39</span>:df:ea:<span class="number">5</span>e:e0:<span class="number">1</span>e</span><br></pre></td></tr></table></figure>

<p>인증서 정보를 확인하는 명령어를 실행하여 CA 인증서로 서명되었고 SAN이 설정되어있는 것을 확인했으므로 자체 서명 인증서 발급이 완료되었다고 할 수 있습니다.</p>
<h2 id="서버-인증서"><a href="#서버-인증서" class="headerlink" title="서버 인증서"></a>서버 인증서</h2><p>앞서, 애플리케이션 서버에서 사용할 자체 서명된 SSL 인증서를 발급했습니다. 웹 서비스를 HTTPS로 운영하기 위해서는 SSL 인증서를 <strong>애플리케이션 서버에 직접 등록</strong>하거나 <strong>Nginx와 같은 L7 로드밸런서에 SSL 인증서를 등록</strong>해야합니다. 스프링 부트 애플리케이션을 만들어서 SSL 인증서를 등록해보고 Nginx 서버를 추가로 구성하여 애플리케이션 서버가 아닌 로드밸런서에서 TLS 핸드쉐이킹을 수행함을 검증해봅니다.</p>
<h3 id="JKS-형식의-인증서로-변환"><a href="#JKS-형식의-인증서로-변환" class="headerlink" title="JKS 형식의 인증서로 변환"></a>JKS 형식의 인증서로 변환</h3><p>스프링 부트 애플리케이션에서 HTTPS를 활성화하기 위해서는 KeyStore 형식의 SSL 인증서를 사용해야합니다. 우리는 OpenSSL을 사용해서 PEM 형식의 인증서를 만들었기 때문에 KeyStore 형식의 인증서로 변환해야합니다. PEM 형식의 인증서를 KeyStore 형식으로 변환하기 위해서는 다음의 과정을 거쳐야합니다.</p>
<ol>
<li>PEM 인증서를 PFX 인증서로 변환</li>
<li>PFX 인증서를 JKS 인증서로 변환 </li>
</ol>
<h4 id="PEM-인증서를-PFX-인증서로"><a href="#PEM-인증서를-PFX-인증서로" class="headerlink" title="PEM 인증서를 PFX 인증서로"></a>PEM 인증서를 PFX 인증서로</h4><p>OpenSSL을 사용해서 다음의 명령어를 수행하면 PEM 형식의 인증서를 PKCS12 형식의 인증서로 변환할 수 있습니다. PKCS12 형식의 인증서로 변환할 때 입력한 비밀번호는 KeyStore 형식의 인증서로 변환할 때 인증용으로 사용됩니다.</p>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> openssl pkcs12 <span class="literal">-export</span> <span class="literal">-inkey</span> server.key <span class="operator">-in</span> server.crt <span class="literal">-out</span> server.pfx</span><br><span class="line">Enter Export Password: [비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line">Verifying - Enter Export Password: [비밀번호 입력:<span class="type">passwd</span>]</span><br></pre></td></tr></table></figure>

<h4 id="PFX-인증서를-JKS-인증서로"><a href="#PFX-인증서를-JKS-인증서로" class="headerlink" title="PFX 인증서를 JKS 인증서로"></a>PFX 인증서를 JKS 인증서로</h4><p>자바의 Keytool 도구를 사용해서 PKCS12 형식의 인증서를 KeyStore 형식의 인증서로 변환할 수 있습니다.</p>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> keytool <span class="literal">-importkeystore</span> <span class="literal">-srckeystore</span> server.pfx <span class="literal">-srcstoretype</span> pkcs12 <span class="literal">-destkeystore</span> server.jks <span class="literal">-deststoretype</span> pkcs12</span><br><span class="line">키 저장소 server.pfx을(를) server.jks(으)로 임포트하는 중...</span><br><span class="line">대상 키 저장소 비밀번호 입력: [비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line">새 비밀번호 다시 입력: [비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line">소스 키 저장소 비밀번호 입력: [<span class="type">PFX</span> 비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line"><span class="number">1</span> 별칭에 대한 항목이 성공적으로 임포트되었습니다.</span><br><span class="line">임포트 명령 완료: 성공적으로 임포트된 항목은 <span class="number">1</span>개, 실패하거나 취소된 항목은 <span class="number">0</span>개입니다.</span><br></pre></td></tr></table></figure>

<h3 id="스프링-부트-애플리케이션"><a href="#스프링-부트-애플리케이션" class="headerlink" title="스프링 부트 애플리케이션"></a>스프링 부트 애플리케이션</h3><p>KeyStore 형식의 서버 인증서가 준비되었으니 스프링 부트 애플리케이션을 만든 후 HTTPS로 실행하기 위한 프로퍼티를 설정하고 애플리케이션을 구동합니다.</p>
<figure class="highlight properties"><figcaption><span>application.properties</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.ssl.protocol</span>=<span class="string">TLS</span></span><br><span class="line"><span class="meta">server.ssl.enabled-protocols</span>=<span class="string">TLSv1.2,TLSv1.3</span></span><br><span class="line"><span class="meta">server.ssl.key-store</span>=<span class="string">classpath:cert/server.jks</span></span><br><span class="line"><span class="meta">server.ssl.key-store-password</span>=<span class="string">passwd</span></span><br><span class="line"><span class="meta">server.ssl.key-store-type</span>=<span class="string">pkcs12</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-06.png"></p>
<p>실행된 애플리케이션 서버는 자체 서명된 서버 인증서이기 때문에 발급자인 CA에 대한 정보를 브라우저가 확인할 수 없습니다. 따라서, 브라우저가 신뢰할 수 없는 사이트라고 알려주는 것은 당연한 부분으로 이 경고를 무시하고 접근할 수도 있지만 우리는 <strong>자체 서명 CA 인증서를 보유하고 있으므로 브라우저가 신뢰할 수 있는 기관으로 등록</strong>하겠습니다.</p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-07.png"></p>
<p><strong>설정 &gt; 개인정보 및 보안 &gt; 보안 &gt; 인증서 관리</strong>로 들어가서 자체 서명된 CA 인증서를 루트 인증 기관으로 등록할 수 있습니다.</p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-08.png"></p>
<p>루트 인증 기관 목록에 자체 서명 CA 인증서를 추가했으므로 다음과 같이 신뢰할 수 없던 애플리케이션 서버 인증서를 신뢰할 수 있게 됩니다. </p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-09.png" alt="127.0.0.1"><br><img data-src="/images/posts/ssl-certificate/ssl-certificate-10.png" alt="mambo.kr"></p>
<p>로컬호스트 대신에 SAN으로 지정하였던 127.0.0.1과 mambo.kr에 대해서도 신뢰하였습니다. 만약, 따라해보고 계시는 분들 중에서 여전히 신뢰할 수 없다고 나오는 경우 브라우저를 종료하고 다시 실행해보시기 바랍니다.</p>
<p>이제 Nginx을 추가적으로 구성하여 애플리케이션 서버가 아닌 Nginx에서 서버 인증서를 등록하여 TLS 핸드쉐이크를 수행하는 지 확인해보겠습니다. 실행했던 애플리케이션 서버는 종료합니다.</p>
<h3 id="PEM-형식의-인증서로-변환"><a href="#PEM-형식의-인증서로-변환" class="headerlink" title="PEM 형식의 인증서로 변환"></a>PEM 형식의 인증서로 변환</h3><p>인증 기관 대행 업체에서 발급해준 인증서가 KeyStore 형식의 인증서라면 PEM 형식의 인증서로 변환해야합니다. 이미 우리는 PEM 형식의 서버 인증서가 있는 상태이지만 없는 상태라고 가정하고 KeyStore 형식의 인증서를 PEM 형식으로 변환해봅니다.</p>
<p>변환 과정은 다음과 같이 KeyStore 인증서로 변환할 때의 반대 과정을 거칩니다.</p>
<ol>
<li>JKS 인증서를 PFX 인증서로 변환</li>
<li>PFX 인증서를 PEM 인증서로 변환</li>
</ol>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># JKS 인증서를 PFX 인증서로 변환</span></span><br><span class="line"><span class="built_in">PS</span> keytool <span class="literal">-importkeystore</span> <span class="literal">-srckeystore</span> server.jks <span class="literal">-destkeystore</span> server.pfx <span class="literal">-deststoretype</span> pkcs12</span><br><span class="line">키 저장소 server.jks을(를) server.pfx(으)로 임포트하는 중...</span><br><span class="line">대상 키 저장소 비밀번호 입력: [비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line">새 비밀번호 다시 입력: [비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line">소스 키 저장소 비밀번호 입력: [<span class="type">JKS</span> 비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line"><span class="number">1</span> 별칭에 대한 항목이 성공적으로 임포트되었습니다.</span><br><span class="line">임포트 명령 완료: 성공적으로 임포트된 항목은 <span class="number">1</span>개, 실패하거나 취소된 항목은 <span class="number">0</span>개입니다.</span><br><span class="line"></span><br><span class="line"><span class="comment"># PFX 인증서에서 PEM 형식의 인증서로 변환</span></span><br><span class="line"><span class="built_in">PS</span> openssl pkcs12 <span class="operator">-in</span> server.pfx <span class="literal">-out</span> server.crt <span class="literal">-clcerts</span> <span class="literal">-nokeys</span></span><br><span class="line">Enter Import Password: [<span class="type">PFX</span> 비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># PFX 인증서에서 개인키 추출</span></span><br><span class="line"><span class="built_in">PS</span> openssl pkcs12 <span class="operator">-in</span> server.pfx <span class="literal">-out</span> server.key <span class="literal">-nocerts</span></span><br><span class="line">Enter Import Password: [<span class="type">PFX</span> 비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line">Enter PEM pass phrase: [비밀번호 입력:<span class="type">passwd</span>]</span><br><span class="line">Verifying - Enter PEM pass phrase: [비밀번호 입력:<span class="type">passwd</span>]</span><br></pre></td></tr></table></figure>

<p>PFX 인증서를 PEM 형식으로 변환하고나서는 부가적인 헤더가 들어가있으므로 PEM 형식에 관련된 부분만 별도로 다시 저장합니다. 예를 들어, 개인키의 경우 -----BEGIN PRIVATE KEY-----으로 시작해서 -----END PRIVATE KEY-----으로 끝나는 부분을 말합니다.</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx와 애플리케이션 서버를 실행하는 환경은 도커 컴포즈로 실행하겠습니다. 먼저, 앞선 스프링 부트 애플리케이션을 실행가능한 JAR 파일로 패키징하여 준비합니다.</p>
<figure class="highlight sh"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">gradle bootJar</span><br><span class="line">&gt; Task :compileJava UP-TO-DATE</span><br><span class="line">&gt; Task :processResources UP-TO-DATE</span><br><span class="line">&gt; Task :classes UP-TO-DATE</span><br><span class="line">&gt; Task :bootJarMainClassName</span><br><span class="line">&gt; Task :bootJar</span><br><span class="line"><span class="comment"># build/libs/demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure>

<p>그리고 다음의 도커 컴포즈 문서를 작성하고 패키징된 애플리케이션과 서버 인증서 그리고 개인키 파일을 복사합니다.</p>
<figure class="highlight yaml"><figcaption><span>docker-compose.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./server.crt:/etc/nginx/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./server.key:/etc/nginx/server.key</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">adoptopenjdk/openjdk11</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&#x27;java -jar /etc/app.jar&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./demo-0.0.1-SNAPSHOT.jar:/etc/app.jar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>도커 컴포즈가 참조하는 Nginx 설정 파일에 443 포트에 SSL을 활성화하고 SSL 인증서를 지정하도록 작성합니다.</p>
<figure class="highlight plaintext"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    access_log      /var/log/nginx/access.log;</span><br><span class="line">    error_log       /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">    include         /etc/nginx/mime.types;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen              443 ssl;</span><br><span class="line">        server_name         localhost 127.0.0.1 mambo.kr;</span><br><span class="line">        ssl_certificate     /etc/nginx/server.crt;</span><br><span class="line">        ssl_certificate_key /etc/nginx/server.key;</span><br><span class="line">        ssl_protocols       TLSv1.2 TLSv1.3;</span><br><span class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass         http://app:8080;</span><br><span class="line">            proxy_redirect     off;</span><br><span class="line">            proxy_set_header   Host $host;</span><br><span class="line">            proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  60;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>도커 컴포즈 명령어로 Nginx와 함께 애플리케이션을 구동합니다.</p>
<figure class="highlight ps"><figcaption><span>Windows Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">docker<span class="literal">-compose</span> up <span class="literal">-d</span></span><br></pre></td></tr></table></figure>

<p>정상적으로 실행되었다면 Nginx의 443 포트를 통해 애플리케이션 서버와의 통신을 수행할 수 있습니다. 그리고 다음 처럼 TLS 핸드쉐이크 과정이 Nginx에 의해 제대로 수행되었음을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/ssl-certificate/ssl-certificate-11.png"></p>
<p>이상으로 SSL 인증서에 대한 정리를 마치도록 하겠습니다. </p>
<p>인프라 구조상 SSL 인증서를 어디에 등록하고 TLS 핸드쉐이킹 과정을 수행하는지도 중요한 부분일 수 있습니다. 운영중인 웹 서비스를 분산 애플리케이션으로 로드밸런싱을 수행하고 있다면 로드밸런싱을 수행하는 Nginx 또는 NLB에서 TLS 핸드쉐이킹을 수행할 수 있도록 SSL 인증서를 등록하는 것이 좋을 수 있습니다. 이렇게 구성하면 애플리케이션 서버에서 지원하지 않는 요청에 대해서 애플리케이션 서버까지 도달하지 않도록 하여 서버 부하를 방지할 수 있습니다. 물론, 로드밸런서에서 TLS 핸드쉐이크를 수행하므로 상대적으로 로드밸런서 서버의 부하가 커지는 것은 감안해야합니다.</p>
<p>감사합니다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/network/create-tls-listener.html">Network Load Balancer를 위한 TLS 리스너</a></li>
<li><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/configuring-https-ssl.html">X509 인증서 생성 및 서명</a></li>
<li><a href="https://www.baeldung.com/java-keystore-convert-to-pem-format">Converting a Java Keystore Into PEM Format</a></li>
<li><a href="https://stackoverflow.com/questions/13732826/convert-pem-to-crt-and-key">Convert .pem to .crt and .key</a></li>
<li><a href="https://www.sslcert.co.kr/guides/SSL-Certificate-Convert-Format">Convert Certificate Format SSL 인증서 변환 가이드</a></li>
<li><a href="https://letsencrypt.org/ko/docs/certificates-for-localhost/">localhost를 위한 인증서</a></li>
</ul>
]]></content>
      <tags>
        <tag>HTTPS</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS 오프로드</title>
    <url>/tls-offload/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>오늘은 로드밸런서를 활용한 TLS 오프로드에 대해서 정리해보고자 합니다. 지난 <a href="../ssl-certificate">SSL 인증서</a>에서는 HTTPS를 웹 서비스에 적용하는 이유와 함께 SSL 인증서를 발급하고 TLS 핸드쉐이크를 어떤 방식으로 수행하는지를 확인했습니다. 이 글에서는 <strong>아마존 웹 서비스의 ELB(Elastic Load Balancing)에서 지원하는 TLS 핸드쉐이크 및 TLS 오프로딩 기능</strong>에 대해 알아보고 참고해야할 정보를 소개합니다.</p>
<h2 id="SSL-오프로드"><a href="#SSL-오프로드" class="headerlink" title="SSL 오프로드"></a>SSL 오프로드</h2><p><strong>TLS(SSL) 오프로드</strong>는 애플리케이션 서버에서 TLS 핸드쉐이크를 수행하지 않고 <strong>트래픽이 전달되기 전 로드밸런서에서 SSL 인증서를 관리하고 TLS 핸드쉐이크를 수행</strong>하는 것을 말합니다. 대부분의 웹 서비스는 애플리케이션 서버를 독립적으로 운용하지 않고 트래픽 규모에 따라 유연하게 확장하고 확장된 애플리케이션 서버에 트래픽을 균등하게 분산시키기 위하여 로드밸런서를 구성합니다. 아마존 웹 서비스의 ELB 로드밸런서 유형 중 NLB와 ALB는 SSL 인증서를 등록하고 클라이언트와 TLS 핸드쉐이크를 수행하여 트래픽이 EC2 인스턴스 또는 컨테이너로 전달하는 <strong>TLS 오프로딩 기능을 지원</strong>합니다.</p>
<h3 id="Mutual-TLS"><a href="#Mutual-TLS" class="headerlink" title="Mutual TLS"></a>Mutual TLS</h3><p>웹 서비스의 요구사항에 따라 애플리케이션 서버에서는 <strong>클라이언트의 X.509 인증서를 토대로 사용자 인증을 수행하고 요청을 처리</strong>할 수 있습니다. 이렇게 클라이언트와 애플리케이션 서버 모두 인증서를 전달하는 것을 <strong>Mutual TLS</strong>라고 합니다. 그리고 자바 기반의 애플리케이션 서버는 <strong>javax.servlet.request.X509Certificate</strong> 속성을 통해 <strong>X.509 인증서</strong>를 가져올 수 있습니다. </p>
<p>그러나 웹 요청이 로드밸런서에 의해 트래픽이 전달되는 경우 클라이언트 인증서를 포함하여 전달하는 것이 보장되지 않습니다. 일반적으로 Nginx를 로드밸런서를 사용하는 경우에는 요청 시 포함된 클라이언트의 인증서 정보가 <strong>X-SSL-CERT</strong>와 같은 <strong>비표준 헤더</strong>로 전달될 수 있도록 설정합니다. 이렇게 요청 헤더로 인증서를 애플리케이션 서버까지 전달하는 것은 애플리케이션 서버에서 클라이언트의 실제 아이피를 알기 위하여 사용되는 표준 헤더 <strong>X-Forwarded-For</strong>와 비슷한 목적으로 사용된다고 볼 수 있습니다.</p>
<h3 id="AWS-NLB"><a href="#AWS-NLB" class="headerlink" title="AWS NLB"></a>AWS NLB</h3><p>아마존 웹 서비스의 <a href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/network/introduction.html">NLB(Network Load Balancer)</a>는 <strong>L4 레벨의 ELB 로드밸런서 유형</strong>입니다. NLB는 L4 레벨에서 로드밸런싱을 수행하며 프로토콜과 포트를 기반으로 지정된 하나 이상의 대상 그룹으로 요청을 전달하기 때문에 대규모 트래픽을 빠르게 EC2 인스턴스로 전달되도록 지원합니다. </p>
<p><a href="https://aws.amazon.com/ko/elasticloadbalancing/features/#Product_comparisons">ELB의 로드밸런서 유형 비교</a>에서 나와있듯이 NLB는 TLS 오프로드를 지원하기 때문에 <strong>로드밸런서에 인증서를 등록하고 TLS 핸드쉐이크를 처리하도록 구성</strong>할 수 있게 됩니다. 다음과 같이 NLB의 리스너 설정 시 <strong>TLS 프로토콜</strong>을 선택하고 <strong>TLS 버전</strong>과 암호화 스위트 목록에 대한 <strong>보안 정책</strong> 그리고 <strong>SSL 인증서</strong>를 등록할 수 있습니다.</p>
<p><img data-src="/images/posts/tls-offload/tls-offload-01.png"></p>
<h4 id="ECC-인증서-미지원"><a href="#ECC-인증서-미지원" class="headerlink" title="ECC 인증서 미지원"></a>ECC 인증서 미지원</h4><p>TLS 오프로드를 지원한다고 나와있지만 <strong>모든 SSL 인증서를 지원하는 것은 아닙</strong>니다. 회사에서 사용중인 인증서와 같은 타원 곡선형 키를 사용하는 ECC 인증서를 등록하게 되면 아마존 웹 서비스로부터 알림을 받게되고 <strong>애플리케이션 서버로 트래픽이 전달되지 않는 상태</strong>가 될 수 있습니다.</p>
<p><img data-src="/images/posts/tls-offload/tls-offload-02.png"></p>
<p>NLB에 대한 리스너 설정 문서를 살펴보면 <strong>2048 이상의 비트를 사용하는 RSA 키 또는 EC 키로된 인증서를 지원하지 않는다</strong>라고 경고하고 있으며 문서를 살펴보기까지 이러한 정보를 확인할 수 있는 곳은 없었습니다.</p>
<p><img data-src="/images/posts/tls-offload/tls-offload-03.png"></p>
<p>의외로 많이 사용하고 있는 <strong>ECC 인증서에 대해서는 NLB에서 TLS 오프로드를 수행할 수 없기</strong> 때문에 애플리케이션 서버에서 SSL 인증서를 관리하고 TLS 핸드쉐이크를 수행해야합니다. 애플리케이션 서버 배포 시 Elastic Beanstalk을 사용하는 경우 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-platform.html">Java SE 플랫폼</a>을 통해 EC2 인스턴스에 <strong>Nginx를 활용하여 역방향 프록시를 구성</strong>할 수 있기 때문에 반드시 애플리케이션 서버에서 TLS 핸드쉐이크를 수행해야하는 것은 아닙니다.</p>
<blockquote>
<p>회사에서 운영중인 웹 서비스는 Nginx를 사용하지 않고 NLB에서 애플리케이션 서버로 트래픽이 전달되도록 구성했었지만 애플리케이션 서버 규모가 커짐으로 인하여 내부적으로 동작하는 작업이 많아짐에 따라 TLS 핸드쉐이크 부하를 애플리케이션 서버에서 분리하기 위하여 Nginx에서 TLS 오프로드를 수행하도록 전환할 예정입니다.</p>
</blockquote>
<h3 id="AWS-ALB"><a href="#AWS-ALB" class="headerlink" title="AWS ALB"></a>AWS ALB</h3><p>ECC 인증서를 지원하지 않는 NLB와 다르게 ALB(Application Load Balancer)는 <strong>4096 비트 키 길이의 RSA 인증서와 ECDSA로 서명된 EC 인증서를 지원</strong>합니다. <strong>회사에서 운영중인 웹 서비스를 NLB에서 ALB로 전환하지 않는 이유</strong>는 완전한 마이크로서비스 아키텍처가 아니므로 <strong>경로 기반</strong>으로 별도의 애플리케이션 서버로 전달해야하는 <strong>요구사항이 없기</strong> 때문입니다. 이러한 이유로 인해 빠르게 로드밸런서에서 애플리케이션 서버로 트래픽이 전달되도록 NLB를 사용하고 있습니다.</p>
<p>IT 분야는 시간이 지나면서 기술이 점차 발전하고 있습니다. 아마존 웹 서비스가 제공하는 서비스 기능도 발전하고 있음을 확인할 수 있는데 2019년에 작성된 <a href="https://lemontia.tistory.com/898">고정 세션 관련 글</a>에서는 NLB가 <strong>고정 세션 기능을 지원하지 않는다</strong>고 나와있지만 현재 ELB의 제품 비교표와 비교해보면 <strong>백엔드 암호화, 고정 세션 뿐만 아니라 다양한 기능을 지원</strong>하고 있습니다.</p>
<h4 id="ELB-TLSv1-3-미지원"><a href="#ELB-TLSv1-3-미지원" class="headerlink" title="ELB TLSv1.3 미지원"></a>ELB TLSv1.3 미지원</h4><p>아마존 웹 서비스의 ELB에서 TLS 오프로드 기능을 지원하지만 <a href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">보안 정책</a>에 따라 TLS 핸드쉐이크를 수행하기 때문에 클라이언트는 TLS 1.3을 사용할 수 없습니다. <strong>TLS 1.3을 지원하기 위한 작업은 아직 진행중</strong>이므로 클라이언트에게 TLS 1.3을 지원하고자하는 경우에는 ELB에서 TLS 오프로드를 수행하도록 구성할 수 없고 NLB의 TCP 리스너를 설정하여 트래픽이 EC2 인스턴스로 전달되도록하고 <strong>EC2 인스턴스에 실행되어있는 Nginx를 통해 TLS 1.3을 사용할 수 있게 구성</strong>할 수 있습니다.</p>
<h2 id="Elastic-Beanstalk-TLS-오프로드"><a href="#Elastic-Beanstalk-TLS-오프로드" class="headerlink" title="Elastic Beanstalk TLS 오프로드"></a>Elastic Beanstalk TLS 오프로드</h2><p>ELB에서는 TLS 1.3을 지원하지 않으며 NLB에서는 ECC 인증서를 사용할 수 없다는 것을 알았으므로 <strong>Elastic Beanstalk</strong>으로 스프링 애플리케이션 배포 시 Nginx에서 SSL 인증서를 관리하고 <strong>클라이언트가 TLS 1.3 버전으로 TLS 핸드쉐이크를 수행할 수 있도록 할 수 있는가를 검증</strong>해보고 마무리 하겠습니다.</p>
<h3 id="Elastic-Beanstalk-Java-SE-플랫폼"><a href="#Elastic-Beanstalk-Java-SE-플랫폼" class="headerlink" title="Elastic Beanstalk Java SE 플랫폼"></a>Elastic Beanstalk Java SE 플랫폼</h3><p>스프링 애플리케이션을 배포하기 위해서는 Java SE 플랫폼 환경을 구성해야합니다. 이때, 샘플 애플리케이션으로 Beanstalk 환경을 시작하는 것이 좋습니다.</p>
<p><img data-src="/images/posts/tls-offload/tls-offload-04.png" alt="웹 서버 환경 선택"></p>
<p><img data-src="/images/posts/tls-offload/tls-offload-05.png" alt="샘플 애플리케이션으로 시작"></p>
<p>Beanstalk 환경 구성 시 로드밸런서를 설정하고 싶은 경우 <strong>추가 옵션 구성</strong>을 통해 사용자 정의 설정을 진행해야 합니다.</p>
<p><img data-src="/images/posts/tls-offload/tls-offload-06.png" alt="JVM 옵션 환경변수"></p>
<blockquote>
<p>배포하고 보니 오타가 있었네요 :)</p>
</blockquote>
<p><img data-src="/images/posts/tls-offload/tls-offload-07.png" alt="로드밸런싱 인스턴스"></p>
<p><img data-src="/images/posts/tls-offload/tls-offload-08.png" alt="NLB 선택 및 리스너 구성"></p>
<p>그리고 EC2 인스턴스 접근을 위한 키를 설정하는 등 부가 설정을 하고 환경을 생성하면 다음과 같이 샘플 애플리케이션이 배포되는 환경이 준비됩니다.</p>
<p><img data-src="/images/posts/tls-offload/tls-offload-09.png" alt="Java SE 플랫폼 환경 생성 완료"></p>
<blockquote>
<p>처음 환경을 구성할 때 오류가 발생하는 경우 Beanstalk에서는 환경 삭제 버튼이 활성화되지 않아 당황할 수 있으나 CloudFormation 서비스로 이동하여 Beanstalk 환경을 구성중인 스택을 삭제할 수 있습니다.</p>
</blockquote>
<h3 id="스프링-애플리케이션-패키징-및-Java-SE-플랫폼-확장"><a href="#스프링-애플리케이션-패키징-및-Java-SE-플랫폼-확장" class="headerlink" title="스프링 애플리케이션 패키징 및 Java SE 플랫폼 확장"></a>스프링 애플리케이션 패키징 및 Java SE 플랫폼 확장</h3><p>애플리케이션을 배포하기 위한 Java SE 플랫폼이 생성되었으니 스프링 애플리케이션을 패키징하여 <strong>Beanstalk에 배포하기 위한 소스 번들</strong> 파일을 만들어야 합니다. 소스 번들에는 패키징된 애플리케이션 Jar 파일과 함께 애플리케이션 실행를 위한 Procfile을 포함시켜야 합니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">task procfile(<span class="attr">dependsOn:</span> bootJar) &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&quot;build/libs&quot;</span>, <span class="string">&quot;Procfile&quot;</span>).text = <span class="string">&quot;web: java -Xmx1g -Dfile.encoding=UTF-8 -jar $&#123;bootJar.archiveName&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task awsbuild(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> procfile) &#123;</span><br><span class="line">    from (<span class="string">&#x27;.beanstalk/.ebextensions&#x27;</span>) &#123; into <span class="string">&#x27;.ebextensions&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;.beanstalk/.platform&#x27;</span>) &#123; into <span class="string">&#x27;.platform&#x27;</span> &#125;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        include(<span class="string">&#x27;Procfile&#x27;</span>)</span><br><span class="line">        include(bootJar.archiveName)</span><br><span class="line">    &#125;</span><br><span class="line">    baseName = <span class="string">&#x27;beanstalk&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>자세한 내용은 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-procfile.html">Procfile을 사용하여 애플리케이션 프로세스 구성</a>을 참고하세요. </p>
</blockquote>
<h4 id="Java-SE-플랫폼-확장-구성"><a href="#Java-SE-플랫폼-확장-구성" class="headerlink" title="Java SE 플랫폼 확장 구성"></a>Java SE 플랫폼 확장 구성</h4><p>Beanstalk는 <strong>.ebextensions</strong>와 <strong>.platform</strong>을 활용하여 EC2 인스턴스 환경을 확장할 수 있는 기능을 지원합니다. 우리는 HTTP로 실행되는 애플리케이션 서버와 함께 TLS 오프로드를 수행할 Nginx를 구성해야하므로 다음과 같이 <strong>구성 및 플랫폼 확장 파일을 생성</strong>합니다.</p>
<p><strong>Nginx에서 사용할 SSL 인증서 파일 생성</strong></p>
<figure class="highlight yaml"><figcaption><span>beanstalk/.ebextensions/nginx-certificates.config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">files:</span></span><br><span class="line">    <span class="string">/etc/nginx/cert/server.crt:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            -----BEGIN CERTIFICATE-----</span></span><br><span class="line"><span class="string">            #### PROTECTED ####</span></span><br><span class="line"><span class="string">            -----END CERTIFICATE-----</span></span><br><span class="line"><span class="string"></span>    <span class="string">/etc/nginx/cert/server.key:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            -----BEGIN EC PARAMETERS-----</span></span><br><span class="line"><span class="string">            #### PROTECTED ####</span></span><br><span class="line"><span class="string">            -----END EC PARAMETERS-----</span></span><br><span class="line"><span class="string">            -----BEGIN EC PRIVATE KEY-----</span></span><br><span class="line"><span class="string">            #### PROTECTED ####</span></span><br><span class="line"><span class="string">            -----END EC PRIVATE KEY-----</span></span><br><span class="line"><span class="string"></span>    <span class="string">/etc/nginx/cert/server-ca-bundle:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000400&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            -----BEGIN CERTIFICATE-----</span></span><br><span class="line"><span class="string">            #### PROTECTED ####</span></span><br><span class="line"><span class="string">            -----END CERTIFICATE-----</span></span><br><span class="line"><span class="string">            -----BEGIN CERTIFICATE-----</span></span><br><span class="line"><span class="string">            #### PROTECTED ####</span></span><br><span class="line"><span class="string">            -----END CERTIFICATE-----</span></span><br><span class="line"><span class="string">            -----BEGIN CERTIFICATE-----</span></span><br><span class="line"><span class="string">            #### PROTECTED ####</span></span><br><span class="line"><span class="string">            -----END CERTIFICATE-----</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">commands:</span></span><br><span class="line">    <span class="attr">00-chain-ca-bundle:</span></span><br><span class="line">        <span class="attr">cwd:</span> <span class="string">/etc/nginx/cert</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            cat server.crt server-ca-bundle &gt; server-ca.pem</span></span><br><span class="line"><span class="string">            chown nginx:nginx server-ca.pem</span></span><br><span class="line"><span class="string">            chmod 400 server-ca.pem</span></span><br><span class="line"><span class="string"></span>    <span class="attr">99-remove-bak:</span></span><br><span class="line">        <span class="attr">cwd:</span> <span class="string">/etc/nginx/cert</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">*.bak</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>회사 도메인에 대한 인증서이므로 인증서 내용은 마스킹 처리하였습니다.</p>
</blockquote>
<p><strong>Nginx 설정 파일 확장</strong></p>
<figure class="highlight nginx"><figcaption><span>beanstalk/.platform/nginx/conf.d/elasticbeanstalk/00_application.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>기본으로 만들어지는 00_application.conf 파일은 80 포트에 대하여 5000 포트로 전달되도록 구성하므로 443 포트로 리다이렉트하도록 확장합니다.</p>
<figure class="highlight nginx"><figcaption><span>beanstalk/.platform/nginx/nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>                    nginx;</span><br><span class="line"><span class="attribute">error_log</span>               /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>                     /var/run/nginx.pid;</span><br><span class="line"><span class="attribute">worker_processes</span>        auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span>    <span class="number">32768</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span>  <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>         /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>    application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>      main    <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                            <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                            <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">map</span> $http_upgrade $connection_upgrade &#123;</span><br><span class="line">      <span class="attribute">default</span>     <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>                <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">access_log</span>            /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">client_header_timeout</span> <span class="number">60</span>;</span><br><span class="line">        <span class="attribute">client_body_timeout</span>   <span class="number">60</span>;</span><br><span class="line">        <span class="attribute">keepalive_timeout</span>     <span class="number">60</span>;</span><br><span class="line">        <span class="attribute">gzip</span>                  <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">gzip_comp_level</span>       <span class="number">4</span>;</span><br><span class="line">        <span class="attribute">gzip_types</span>            text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Include the Elastic Beanstalk generated locations</span></span><br><span class="line">        <span class="attribute">include</span> conf.d/elasticbeanstalk/<span class="regexp">*.conf</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>                   <span class="number">443</span> ssl default_server;</span><br><span class="line">        <span class="attribute">server_name</span>              springboot;</span><br><span class="line">        <span class="attribute">ssl_certificate</span>          /etc/nginx/cert/server-ca.pem;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>      /etc/nginx/cert/server.key;</span><br><span class="line">        <span class="attribute">ssl_protocols</span>            TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span>              HIGH:!aNULL:!MD5;</span><br><span class="line">        <span class="attribute">ssl_verify_client</span>        optional_no_ca;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>          http://127.0.0.1:5000;</span><br><span class="line">            <span class="attribute">proxy_http_version</span>  <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>    Connection          $connection_upgrade;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>    Upgrade             $http_upgrade;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>    Host                $host;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>    X-Real-IP           $remote_addr;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>    X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>    X-SSL-CERT          $ssl_client_escaped_cert;</span><br><span class="line">            <span class="attribute">proxy_buffering</span>     <span class="literal">off</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>자세한 내용은 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/platforms-linux-extend.html">Elastic Beanstalk Linux 플랫폼 확장</a>을 참고하세요. <a href="https://github.com/awsdocs/elastic-beanstalk-samples">elastic-beanstalk-samples</a>처럼 샘플 파일도 공유되어있습니다.</p>
</blockquote>
<p>이제 샘플 애플리케이션 대신 우리가 준비한 애플리케이션 소스 번들을 업로드하면 Benstalk 엔진이 소스 번들을 추출하고 애플리케이션을 실행하게 됩니다. Route 53으로 Beanstalk 환경 주소를 DNS로 연결하고 접속해보면 다음과 같이 TLS 핸드쉐이크가 수행되었음을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/tls-offload/tls-offload-10.png"></p>
<p>NLB는 트래픽을 EC2 인스턴스의 443 포트로 전달했을 뿐 TLS 오프로드는 Nginx에서 수행하는 것으로 구성했기 때문에 브라우저에서는 TLS 1.3 버전으로 TLS 핸드쉐이크를 수행했습니다. 이렇게 <strong>아마존 웹 서비스에서 TLS 1.3을 지원하기 위해서는 NLB의 TCP 리스너와 Nginx의 TLS 오프로드를 활용하면 가능함을 검증</strong>했습니다.</p>
<h4 id="트러블슈팅"><a href="#트러블슈팅" class="headerlink" title="트러블슈팅"></a>트러블슈팅</h4><p>Elastic Beanstalk로 애플리케이션 배포하는 과정에서 생각보다 오류가 많을 수 있습니다. 이 내용은 <strong>Benstalk에서 애플리케이션 배포 시 발생하는 여러가지 문제를 해결하는데 도움이 되는 항목</strong>을 정리한 것입니다. 따라해보는 분들에게 도움이 되셨으면 하는 바램으로 공유합니다.</p>
<table>
<thead>
<tr>
<th>경로</th>
<th>용도</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>/etc/nginx/</td>
<td>Nginx 구성</td>
<td></td>
</tr>
<tr>
<td>/var/app/current</td>
<td>애플리케이션 소스 번들 추출 경로</td>
<td></td>
</tr>
<tr>
<td>/var/log/eb-engine.log</td>
<td>Beanstalk 로그</td>
<td></td>
</tr>
<tr>
<td>/var/log/nginx</td>
<td>Nginx 로그</td>
<td></td>
</tr>
<tr>
<td>/var/log/web.stdout.out</td>
<td>웹 애플리케이션 로그</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Beanstalk 로그</strong>는 Beanstalk 엔진이 플랫폼 확장 파일들을 실행하고 성공했는지 여부를 기록합니다. 이 로그를 통해 어느 단계에서 오류가 발생하여 애플리케이션 배포 및 전환이 실패하였는지 확인할 수 있는 중요한 로그입니다. 그리고 나머지 항목을 통해 설정한 구성 및 확장 파일이 제대로 추출되어 복사되었는지 Nginx가 ELB에 의해 전달된 트래픽을 애플리케이션까지 전달할 수 있는지를 확인할 수 있습니다.</p>
<p>Nginx에 대해서 자세히 아는 것은 아니므로 설정 파일이 잘못된 부분이 있을 수 있으니 양해 바라며 잘못된 점은 패드백 주시면 감사하겠습니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
        <tag>TLS</tag>
        <tag>ELB</tag>
      </tags>
  </entry>
  <entry>
    <title>초보 개발자들을 위한 AJAX에 대한 정리</title>
    <url>/understanding-asynchronos-javascript-and-xml-with-spring/</url>
    <content><![CDATA[<blockquote>
<p>본 글은 <a href="https://github.com/kdevkr/spring-demo-ajax">https://github.com/kdevkr/spring-demo-ajax</a> 에서 제공했던 정보입니다.</p>
</blockquote>
<h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><blockquote>
<p><em>웹 서비스를 만들 때 자주 사용되는 비동기 통신 기술인 AJAX를 스프링 프레임워크와 연계하여 활용하는 다양한 방식에 대해서 알아보고자 합니다.</em>  </p>
</blockquote>
<p>XHR(XMLHttpRequest)를 직접적으로 이용하는 것보다는 JQuery에서 지원하는 AJAX(Asynchronos Javascript And XML)기능을 활용하도록 하는 것이 나을 것 같다는 생각입니다.</p>
<ul>
<li><a href="https://developer.mozilla.org/ko/docs/XMLHttpRequest">XMLHttpRequest, Mozilla Developer Network</a>  </li>
<li><a href="http://api.jquery.com/jquery.ajax/">Ajax, JQuery</a>  </li>
</ul>
<p>JQuery 이외에도 ajax를 지원하는 다양한 라이브러리가 존재합니다. 예를 들어, <a href="http://prototypejs.org/learn/introduction-to-ajax">Prototypejs</a>도 많이 사용되는 유틸성 라이브러리 중 하나입니다. 그러나 저와 같은 초보자 및 신입 개발자들은 JQuery에 익숙하므로 JQuery가 지원하는 Ajax 기능에 대해서 살펴보고자 합니다.</p>
<blockquote>
<p>Vue.js에서는 <a href="https://github.com/mzabriskie/axios">axios</a>를 선호한다고 합니다.  </p>
</blockquote>
<h2 id="JQuery-ajax"><a href="#JQuery-ajax" class="headerlink" title="JQuery.ajax"></a>JQuery.ajax</h2><p>제이쿼리에서 제공하는 함수는 다음과 같은 구조로 구성되어 있습니다. 물론 이외에도 생략된 다양한 프로퍼티들이 존재하므로 더 찾아보시면 좋을 것 같습니다. 아래의 형태는 아마도 자주 사용되는 프로퍼티만 모아놓은 부분이라고 할 수 있습니다.  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">type</span>	: <span class="string">&quot;GET&quot;</span>, <span class="comment">//요청 메소드 타입</span></span><br><span class="line">  <span class="attr">url</span>		: <span class="string">&quot;url&quot;</span>, <span class="comment">//요청 경로</span></span><br><span class="line">  <span class="attr">async</span> : <span class="literal">true</span>, <span class="comment">//비동기 여부</span></span><br><span class="line">  <span class="attr">data</span>  : &#123;<span class="attr">key</span> : value&#125;, <span class="comment">//요청 시 포함되어질 데이터</span></span><br><span class="line">  <span class="attr">processData</span> : <span class="literal">true</span>, <span class="comment">//데이터를 컨텐트 타입에 맞게 변환 여부</span></span><br><span class="line">  <span class="attr">cache</span> : <span class="literal">true</span>, <span class="comment">//캐시 여부</span></span><br><span class="line">  <span class="attr">contentType</span> : <span class="string">&quot;application/json&quot;</span>, <span class="comment">//요청 컨텐트 타입 &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span></span><br><span class="line">  <span class="attr">dataType</span>	: <span class="string">&quot;json&quot;</span>, <span class="comment">//응답 데이터 형식 명시하지 않을 경우 자동으로 추측</span></span><br><span class="line">  <span class="attr">beforeSend</span>  : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// XHR Header를 포함해서 HTTP Request를 하기전에 호출됩니다.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">success</span>	: <span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 정상적으로 응답 받았을 경우에는 success 콜백이 호출되게 됩니다.</span></span><br><span class="line">    <span class="comment">// 이 콜백 함수의 파라미터에서는 응답 바디, 응답 코드 그리고 XHR 헤더를 확인할 수 있습니다.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>	: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, error</span>)</span>&#123;</span><br><span class="line">  	<span class="comment">// 응답을 받지 못하였다거나 정상적인 응답이지만 데이터 형식을 확인할 수 없기 때문에 error 콜백이 호출될 수 있습니다.</span></span><br><span class="line">  	<span class="comment">// 예를 들어, dataType을 지정해서 응답 받을 데이터 형식을 지정하였지만, 서버에서는 다른 데이터형식으로 응답하면  error 콜백이 호출되게 됩니다.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">complete</span> : <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// success와 error 콜백이 호출된 후에 반드시 호출됩니다.</span></span><br><span class="line">    <span class="comment">// try - catch - finally의 finally 구문과 동일합니다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>여기서 잠깐! GET과 POST의 차이는 무엇인지 아시나요?  </p>
</blockquote>
<p>바로 데이터가 어디에 위치하는가에 있습니다. POST 요청시에 URL에 파라미터가 보이지 않는 이유는 데이터가 요청 바디에 포함되기 때문입니다. 그렇기 때문에 GET과 POST에 따라 데이터를 URL에 추가해야할지 요청 바디에 추가해야할지를 알고 있어야만 합니다.  </p>
<p>예를 들어, processData라는 속성은 GET 요청인데 data에 오브젝트가 지정될 경우에 요청하기전에 그 데이터를 파라미터 형식으로 URL에 추가해주는 역할을 하게 됩니다.</p>
<p>이외에도 JQuery에서는 <a href="https://api.jquery.com/category/ajax/">다양한 ajax 기능</a>을 제공하고 있습니다. 만약, 스프링 시큐리티를 적용해서 HTTP 통신시에 CSRF 토큰이 필요하다면 다음과 같이 XHR Header에 CSRF 토큰을 추가해서 보낼 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 스프링 시큐리티 태그라이브러리로 메타 태그에 토큰 정보를 적용했다는 가정입니다.</span></span><br><span class="line"><span class="keyword">var</span> token = $(<span class="string">&quot;meta[name=&#x27;_csrf&#x27;]&quot;</span>).attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> header = $(<span class="string">&quot;meta[name=&#x27;_csrf_header&#x27;]&quot;</span>).attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">   <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span>(<span class="params">xhr</span>) </span>&#123;</span><br><span class="line">    xhr.setRequestHeader(header, token);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JQuery.ajax에 대해서는 이 정도까지만 알아도 됩니다.</p>
</blockquote>
<h2 id="Spring-Controller"><a href="#Spring-Controller" class="headerlink" title="Spring Controller"></a>Spring Controller</h2><p>스프링 프레임워크에서는 ajax 통신을 위해서 스프링 @MVC로 다양한 어노테이션을 지원합니다. 다양한 어노테이션을 확인하면서 구조를 익혀보도록 하겠습니다. 스프링 애플리케이션은 기본적으로 뷰 리졸버를 통해서 요청에 대한 응답을 하게 됩니다. 일반적인 HTTP 요청의 경우에는 JstlView로써 응답을 하게 되지만, XHR 요청에 의해서 다양한 데이터 형식으로 응답하기 위한 메시지 컨버터라는 것을 지원합니다.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Message Converter List</span><br><span class="line">- StringHttpMessageConverter</span><br><span class="line">- FormHttpMessageConverter</span><br><span class="line">- ByteArrayMessageConverter</span><br><span class="line">- MarshallingHttpMessageConverter</span><br><span class="line">- MappingJacksonHttpMessageConverter</span><br><span class="line">- MappingJackson2HttpMessageConverter</span><br><span class="line">- SourceHttpMessageConverter</span><br><span class="line">- BufferedImagedHttpMessageConverter</span><br></pre></td></tr></table></figure>

<blockquote>
<p>스프링의 <annotation-driven />은 많은 역할을 해주는데, 그 중 하나가 디폴트 메시지 컨버터를 등록해줍니다. 다만, MappingJacksonHttpMessageConverter는 jackson 라이브러리가 존재할때만 등록합니다.  </p>
</blockquote>
<p>우리가 AJAX를 이용할 때 데이터 형식을 JSON으로 많이 사용합니다. 따라서, List, Map등과 같은 오브젝트들을 JSON 형태로 응답하고 싶다면, ModelAndView를 이용하거나 메시지컨버터를 등록해야합니다.  </p>
<blockquote>
<p><em>본 문서에서는 ModelAndView로써 응답하는 방식은 설명하지 않겠습니다. <a href="http://www.nextree.co.kr/p11205/">여기서 확인하도록 합시다</a></em>  </p>
</blockquote>
<p>그러나 스프링 3 이상 부터는 jackson 라이브러리를 의존성으로 추가할 경우에 자동적으로 MappingJacksonHttpMessageConverter를 적용해줍니다.</p>
<blockquote>
<p>여기서 잠깐!<br>스프링 3.1.2 부터는 jackson 2.0을 지원하도록 추가되었습니다. jackson 2.0은 MappingJackson2HttpMessageConverter로 등록됩니다.<br>자세한 사항은 스프링 버전별 jackson 라이브러리 버전 항목에서 확인하시기 바랍니다.</p>
</blockquote>
<p>스프링 부트에서는 이러한 부분도 관리해주므로 추가적으로 jackson 라이브러리를 pom.xml에 추가할 필요가 없습니다.  </p>
<h3 id="스프링-버전별-사용되는-Jackson-Library"><a href="#스프링-버전별-사용되는-Jackson-Library" class="headerlink" title="스프링 버전별 사용되는 Jackson Library"></a>스프링 버전별 사용되는 Jackson Library</h3><p>스프링 3.0 이상부터는 jackson 관련 라이브러리에 따라 메시지 컨버터를 등록해줍니다.</p>
<h4 id="Spring-3-0-x"><a href="#Spring-3-0-x" class="headerlink" title="Spring 3.0.x"></a>Spring 3.0.x</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.jackson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-mapper-asl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.codehaus.jackson&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Spring-3-1-2"><a href="#Spring-3-1-2" class="headerlink" title="Spring 3.1.2"></a>Spring 3.1.2</h4><blockquote>
<p>MappingJackson2HttpMessageConverter로 jackson 2.0을 지원합니다</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.jackson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-mapper-asl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.codehaus.jackson&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Jackson 2.0 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;com.fasterxml.jackson&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;com.fasterxml.jackson&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;com.fasterxml.jackson&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Spring-4-0-0"><a href="#Spring-4-0-0" class="headerlink" title="Spring 4.0.0"></a>Spring 4.0.0</h4><blockquote>
<p>GsonHttpMessageConverter 지원<br>MappingJacksonHttpMessageConverter 미지원  </p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Jackson 2.0 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;com.fasterxml.jackson&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;com.fasterxml.jackson&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;com.fasterxml.jackson&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://github.com/spring-projects/spring-framework/wiki/Migrating-to-Spring-Framework-4.x#jackson-1819">https://github.com/spring-projects/spring-framework/wiki/Migrating-to-Spring-Framework-4.x#jackson-1819</a><br>위 문서에 따르면 스프링 4.1 부터는 org.codehaus.jackson(1.8 or 1.9)의 지원을 중단하였습니다.  </p>
</blockquote>
<ul>
<li>버전별 메시지 컨버터 지원표    </li>
</ul>
<table>
<thead>
<tr>
<th align="center">Spring Version</th>
<th align="center">org.codehaus.jackson(1.8 or 1.9)</th>
<th align="center">com.fasterxml.jackson(2.0)</th>
<th align="center">gson</th>
</tr>
</thead>
<tbody><tr>
<td align="center">3.0.x</td>
<td align="center">MappingJacksonHttpMessageConverter</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3.1.2</td>
<td align="center">MappingJacksonHttpMessageConverter</td>
<td align="center">MappingJackson2HttpMessageConverter</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4.+</td>
<td align="center"></td>
<td align="center">MappingJackson2HttpMessageConverter</td>
<td align="center">GsonHttpMessageConverter</td>
</tr>
</tbody></table>
<h3 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h3><blockquote>
<p>그럼 이제 스프링 컨트롤러에서 사용되는 어노테이션들을 알아보겠습니다.</p>
</blockquote>
<h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><p>@RequestMapping에는 요청과 응답과 관련한 프로퍼티를 설정할 수 있습니다.  produces와 consumes는 확실히 알고 넘어가셔야 합니다.  </p>
<ul>
<li>method=RequestMethod.GET<br>method는 어떠한 요청 타입을 처리할 것인가를 결정하는 부분입니다.</li>
<li>produces=MediaType.APPLICATION_JSON_VALUE<br>produces는 어떠한 데이터 형식으로 응답할 것인가를 결정하는 부분입니다.</li>
<li>consumes=MediaType.APPLICATION_JSON_VALUE<br>consumes는 어떠한 요청에 대해서 처리할 것인가를 결정하는 부분입니다.  </li>
</ul>
<blockquote>
<p>produces와 consumes 프로퍼티는 Spring 3.1에서 부터 지원합니다.  </p>
</blockquote>
<h4 id="ModelAttribute-ReqeustParam"><a href="#ModelAttribute-ReqeustParam" class="headerlink" title="@ModelAttribute, @ReqeustParam"></a>@ModelAttribute, @ReqeustParam</h4><p>이 두개의 어노테이션은 GET과 DELETE 요청에서 활용할 수 있습니다. 그 이유는 파라미터 값을 확인해서 데이터를 바인딩해주기 때문입니다. @RequestParam은 request.getParameter()로써 가져오는 반면에 @ModelAttribute는 자바 클래스의 Getter, Setter에 의해 데이터를 바인딩시키는 것입니다. 그렇기 때문에 만약 객체 단위로 바인딩하고 싶다면 @ModelAttribute를  이용해야 한다는 것입니다.</p>
<blockquote>
<p><em>직접 확인하고 싶으시다면 본 프로젝트를 동작시켜 ajaxList와 ajaxListModel의 차이를 확인하시기 바랍니다.</em>  </p>
</blockquote>
<h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>이 어노테이션은 POST와 PUT 처럼 데이터가 HTTP 요청 바디에 포함되는 경우에 이를 확인해서 데이터를 바인딩 해줍니다. 이 어노테이션의 중요한 부분은 GET 요청과 같이 파라미터를 통해 제공되는 데이터는 바인딩할 수 없다는 점입니다.</p>
<blockquote>
<p><em>직접 확인하고 싶으시다면 본 프로젝트를 동작시켜 ajaxMap와 ajaxMapGet의 차이를 확인하시기 바랍니다. ajaxMapGet의 요청이 왜 실패하는지에 대해서 서버측 로그를 살펴보시기 바랍니다.</em>  </p>
</blockquote>
<h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>이 어노테이션은 응답되는 데이터에 대하여 등록된 메시지 컨버터를 통해 변환시켜 응답하게 됩니다. 따라서, 뷰에 모델로서 데이터를 추가시켜 응답하는 것이 아니라 데이터를 HTTP 본문으로 응답하게 된다는 것입니다.  </p>
<blockquote>
<p><em>ajaxList와 ajaxListNobody를 통해서 @ResponseBody가 있을 경우랑 없을 경우를 비교해보세요. 왜 @ResponseBody가 없을 때 ViewResolver를 찾는 것 같나요?</em>  </p>
</blockquote>
<h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h4><p>이 어노테이션은 스프링 4 부터 지원합니다. 해당 컨트롤러의 메소드들에 @ResponseBody 어노테이션을 적용합니다. 좀 더 편의성을 제공한다고 보시면 됩니다.  </p>
<h2 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h2><p>본 프로젝트에서 현재 진행한 테스트 케이스는 다음과 같습니다.  </p>
<h4 id="1-GET-ResponseBody와-ModelAttribute-RequestParm을-확인할-수-있는-케이스"><a href="#1-GET-ResponseBody와-ModelAttribute-RequestParm을-확인할-수-있는-케이스" class="headerlink" title="1. GET, @ResponseBody와 @ModelAttribute, @RequestParm을 확인할 수 있는 케이스"></a>1. GET, @ResponseBody와 @ModelAttribute, @RequestParm을 확인할 수 있는 케이스</h4><h4 id="2-GET-1번과-동일하나-ModelAttribute를-통해서-객체-단위로-바인딩하는-것을-확인할-수-있는-케이스"><a href="#2-GET-1번과-동일하나-ModelAttribute를-통해서-객체-단위로-바인딩하는-것을-확인할-수-있는-케이스" class="headerlink" title="2. GET, 1번과 동일하나 @ModelAttribute를 통해서 객체 단위로 바인딩하는 것을 확인할 수 있는 케이스"></a>2. GET, 1번과 동일하나 @ModelAttribute를 통해서 객체 단위로 바인딩하는 것을 확인할 수 있는 케이스</h4><h4 id="3-GET-1번과-동일하나-ResponseBody를-지정하지-않았을-경우를-확인할-수-있는-케이스"><a href="#3-GET-1번과-동일하나-ResponseBody를-지정하지-않았을-경우를-확인할-수-있는-케이스" class="headerlink" title="3. GET, 1번과 동일하나 @ResponseBody를 지정하지 않았을 경우를 확인할 수 있는 케이스"></a>3. GET, 1번과 동일하나 @ResponseBody를 지정하지 않았을 경우를 확인할 수 있는 케이스</h4><h4 id="4-PUT-ResponseBody와-RequestBody를-지정했을-경우를-확인할-수-있는-케이스"><a href="#4-PUT-ResponseBody와-RequestBody를-지정했을-경우를-확인할-수-있는-케이스" class="headerlink" title="4. PUT, @ResponseBody와 @RequestBody를 지정했을 경우를 확인할 수 있는 케이스"></a>4. PUT, @ResponseBody와 @RequestBody를 지정했을 경우를 확인할 수 있는 케이스</h4><h4 id="5-GET-4번과-동일하나-GET-요청에-RequestBody를-지정했을-경우를-확인할-수-있는-케이스"><a href="#5-GET-4번과-동일하나-GET-요청에-RequestBody를-지정했을-경우를-확인할-수-있는-케이스" class="headerlink" title="5. GET, 4번과 동일하나 GET 요청에 @RequestBody를 지정했을 경우를 확인할 수 있는 케이스"></a>5. GET, 4번과 동일하나 GET 요청에 @RequestBody를 지정했을 경우를 확인할 수 있는 케이스</h4><h4 id="6-POST-ResponseEntity를-통해서-HttpStatus도-지정할-수-있는-것을-확인하는-케이스"><a href="#6-POST-ResponseEntity를-통해서-HttpStatus도-지정할-수-있는-것을-확인하는-케이스" class="headerlink" title="6. POST, ResponseEntity를 통해서 HttpStatus도 지정할 수 있는 것을 확인하는 케이스"></a>6. POST, ResponseEntity를 통해서 HttpStatus도 지정할 수 있는 것을 확인하는 케이스</h4><h4 id="7-POST-6번과-동일하나-ResponseBody를-지정하지-않을-경우를-확인할-수-있는-케이스"><a href="#7-POST-6번과-동일하나-ResponseBody를-지정하지-않을-경우를-확인할-수-있는-케이스" class="headerlink" title="7. POST, 6번과 동일하나 @ResponseBody를 지정하지 않을 경우를 확인할 수 있는 케이스"></a>7. POST, 6번과 동일하나 @ResponseBody를 지정하지 않을 경우를 확인할 수 있는 케이스</h4><h4 id="8-POST-7번과-동일하나-URL에-파라미터를-함께-요청시에-RequestParam-지원여부를-확인할-수-있는-케이스"><a href="#8-POST-7번과-동일하나-URL에-파라미터를-함께-요청시에-RequestParam-지원여부를-확인할-수-있는-케이스" class="headerlink" title="8. POST, 7번과 동일하나 URL에 파라미터를 함께 요청시에 @RequestParam 지원여부를 확인할 수 있는 케이스"></a>8. POST, 7번과 동일하나 URL에 파라미터를 함께 요청시에 @RequestParam 지원여부를 확인할 수 있는 케이스</h4><blockquote>
<p><em>6번과 7번은 의아해하실 수 있으실 겁니다. 이와 관련된 정보는 <a href="http://okky.kr/article/311196">여기</a>에서 확인하실 수 있습니다. 간단히 말하면 ResponseEntity는 응답 헤더와 바디를 가지는 객체를 응답하는 것이라고 보면 됩니다.</em></p>
</blockquote>
<h2 id="마지막으로-초보자들이-잘못-사용하거나-접근하는-경우를-알아봅시다"><a href="#마지막으로-초보자들이-잘못-사용하거나-접근하는-경우를-알아봅시다" class="headerlink" title="마지막으로 초보자들이 잘못 사용하거나 접근하는 경우를 알아봅시다."></a>마지막으로 초보자들이 잘못 사용하거나 접근하는 경우를 알아봅시다.</h2><blockquote>
<p>Okky에서 Ajax 관련 질문이 올라온다면 지속적으로 추가하도록 하겠습니다.</p>
</blockquote>
<h4 id="1-저는-제대로-구현한-것-같은데-에러로-응답받습니다"><a href="#1-저는-제대로-구현한-것-같은데-에러로-응답받습니다" class="headerlink" title="1. 저는 제대로 구현한 것 같은데 에러로 응답받습니다."></a>1. 저는 제대로 구현한 것 같은데 에러로 응답받습니다.</h4><ul>
<li>dataType을 지정한 뒤 그 형식으로 응답하지 않는다면 정상적으로 응답해도 에러 콜백이 호출될 가능성이 있습니다. 예를 들어, 스프링 컨트롤러에서는 문자열이나 null을 응답하는데 ajax에서는 json으로 지정할 경우에는 서버에서는 정상적으로 응답되지만 클라이언트에서는 해당 데이터를 json으로 파싱할 수 없기 때문에 에러 콜백이 호출됩니다.  </li>
</ul>
<blockquote>
<p>대부분의 Ajax 관련 질문은 여기에 해당되는 경우가 많았습니다. 단순히 error가 난다고 해서 정상적으로 응답받지 못했다고 판단하고 계셨습니다. 서버는 html문서를 응답하는데 ajax 데이터 형식이 json이면 오류가 난다는 것을 기억해주시기 바랍니다.</p>
</blockquote>
<h4 id="2-데이터를-서버에서-받아올-수-없습니다"><a href="#2-데이터를-서버에서-받아올-수-없습니다" class="headerlink" title="2. 데이터를 서버에서 받아올 수 없습니다."></a>2. 데이터를 서버에서 받아올 수 없습니다.</h4><ul>
<li>요청 메소드 타입이 GET일 때 processData를 false로 지정할 경우에는 데이터를 url에 직접 포함시켜줘야 합니다.  만약, POST같은 요청의 경우에는 데이터가 요청 바디에 포함되어져야 한다는 것을 잊지 마시기 바랍니다.  </li>
</ul>
<blockquote>
<p>POST의 경우에도 url에 파라미터가 포함된다면 @RequestParam 어노테이션을 통해 받아올 수 있습니다.</p>
</blockquote>
<h4 id="3-GET-요청을-통해-보내는데-일정-데이터-크기이상-보내지지-않습니다"><a href="#3-GET-요청을-통해-보내는데-일정-데이터-크기이상-보내지지-않습니다" class="headerlink" title="3. GET 요청을 통해 보내는데 일정 데이터 크기이상 보내지지 않습니다."></a>3. GET 요청을 통해 보내는데 일정 데이터 크기이상 보내지지 않습니다.</h4><ul>
<li>브라우저별로 URL의 지원 크기가 다릅니다. 그렇기 때문에 POST로 요청 바디에 데이터를 포함시켜 보내는 이유도 바로 이 때문입니다. 물론 서버 측에서도 요청 바디에 대한 크기를 제한할 수 도 있습니다.  </li>
</ul>
<blockquote>
<p>많은 신입 면접시에 GET과 POST의 차이를 묻는 이유이기도 합니다. 단순히 보안 때문에 구분해서 사용하는 것은 아니라는 점입니다.</p>
</blockquote>
<h4 id="4-406-Not-Acceptable-응답해요-ㅠㅠ-2017-02-14"><a href="#4-406-Not-Acceptable-응답해요-ㅠㅠ-2017-02-14" class="headerlink" title="4. 406 - Not Acceptable 응답해요 ㅠㅠ  [2017-02-14]"></a>4. 406 - Not Acceptable 응답해요 ㅠㅠ  [2017-02-14]</h4><ul>
<li>혹시 @ResponseBody로 List나 Map을 응답하고 계신가요? 응답하기 위해서는 annotation-driven 설정이 되어있어야 하고 요청하는 응답 데이터로 변환할 수 있도록 메시지 컨버터가 필요합니다.</li>
</ul>
<blockquote>
<p>스프링 버전에 따라서 다르겠지만 스프링 3 부터는 annotation-driven 설정을 하고 jackson 라이브러리르 추가한다면 디폴트 전략으로 메시지컨버터가 등록됩니다.  </p>
</blockquote>
<h4 id="5-MessageConverter를-이용하고-싶지-않아요-2017-04-20"><a href="#5-MessageConverter를-이용하고-싶지-않아요-2017-04-20" class="headerlink" title="5. MessageConverter를 이용하고 싶지 않아요 [2017-04-20]"></a>5. MessageConverter를 이용하고 싶지 않아요 [2017-04-20]</h4><ul>
<li>메시지 컨버터를 이용하지 않고도 JSON으로 응답할 수 있는 방법이 있습니다. 바로 ContentNegotiatingViewResolver를 이용하면 됩니다. 확장자를 이용하는 방식입니다.</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;</span>&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!-- ViewResolver 우선순위 설정 --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">&quot;mediaTypes&quot;</span>&gt;</span></span><br><span class="line">	        <span class="comment">&lt;!-- 맵핑될 확장자 정의 --&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">beans:map</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">beans:entry</span> <span class="attr">key</span>=<span class="string">&quot;json&quot;</span> <span class="attr">value</span>=<span class="string">&quot;application/json&quot;</span> /&gt;</span></span><br><span class="line">	        <span class="tag">&lt;/<span class="name">beans:map</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">beans:property</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">&quot;defaultViews&quot;</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">beans:list</span>&gt;</span></span><br><span class="line">	            <span class="comment">&lt;!-- JSON 요청을 처리할 뷰 --&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.json.MappingJacksonJsonView&quot;</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;/<span class="name">beans:list</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">beans:property</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">&quot;ignoreAcceptHeader&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/api/test.json&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">api</span><span class="params">(<span class="keyword">final</span> ModelMap map)</span></span>&#123;</span><br><span class="line">  Message message = <span class="keyword">new</span> Message(<span class="string">&quot;Message Bean&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;response&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ModelMap에 추가하여 JSON 형태로 출력할 수 있게 됩니다.</p>
</blockquote>
<p>참조 : <a href="http://ismydream.tistory.com/139">http://ismydream.tistory.com/139</a></p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>초보가 이해하는 스프링 시큐리티</title>
    <url>/understanding-spring-security/</url>
    <content><![CDATA[<blockquote>
<p>본 글은 OKKY에 공유된 <a href="https://okky.kr/article/382738">초보가 이해하는 스프링 시큐리티</a> 입니다.</p>
</blockquote>
<h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><h2 id="스프링-시큐리티란-무엇인가"><a href="#스프링-시큐리티란-무엇인가" class="headerlink" title="스프링 시큐리티란 무엇인가?"></a>스프링 시큐리티란 무엇인가?</h2><p>스프링 시큐리티를 이해하기 위해서 스프링 시큐리티가 무엇인지를 알아야합니다. 스프링 시큐리티 레퍼런스에서는 자바 EE 기반의 엔터프라이즈 소프트웨어 애플리케이션을 위한 포괄적인 보안 서비스들을 제공하고 오픈 플랫폼이면서 자신만의 인증 매커니즘을 간단하게 만들 수 있다고 자랑(?)하고 있습니다.</p>
<p>하지만, 신입 개발자들 수준에서 스프링 시큐리티와 같은 보안 기술을 이해하기란 참 힘든 과정이라고 생각합니다.</p>
<blockquote>
<p>저만 이해하기 힘들 수 있어요 ㅠㅠ  </p>
</blockquote>
<p>스프링 시큐리티를 이해하기 위해서는 스프링 시큐리티가 애플리케이션 보안을 구성하는 두가지 영역에 대해서 알아야 합니다. 바로 인증(Authentication)과 권한(Authorization)이라는 것입니다. 이 두 영역은 스프링 시큐리티의 목표이기 때문에 반드시 이해하고 넘어가야 합니다. <code>인증</code>은 애플리케이션의 작업을 수행할 수 있는 주체(사용자)라고 주장할 수 있는 것을 말하며 권한은 인증된 주체가 애플리케이션의 동작을 수행할 수 있도록 허락되있는지를 결정하는 것을 말합니다. 따라서, 권한 승인이 필요한 부분으로 접근하려면 인증 과정을 통해 주체가 증명 되어야만 한다는 것입니다.   </p>
<p>앞서 스프링 시큐리티는 자신만의 인증 매커니즘을 간단하게 만들 수 있다고 자랑한다고 했는데요. 스프링 시큐리티는 이와 관련해서 인증 매커니즘과 관계없이 상당히 깊은 권한 부여를 제공하고 있습니다. 권한 부여에도 두가지 영역이 존재하는데 웹 요청 권한, 메소드 호출 및 도메인 인스턴스에 대한 접근 권한 부여입니다. 스프링 시큐리티는 이렇게 모든 중요한 영역에 필요한 기능을 제공하고 있습니다.</p>
<p><a href="http://zgundam.tistory.com/43">제타건담님의 글</a>에서는 로그인 화면을 통해서 아이디와 비밀번호를 입력받아 로그인하는 과정을 인증이라고 서술하고 있습니다. 이와 관련된 용어가 바로 HTTP 기본 인증(HTTP Basic Authentication) 매커니즘이라고 할 수 있습니다. 그리고 이 HTTP 기본 인증 매커니즘을 이용하는 방식이 바로 스프링 시큐리티 레퍼런스에서 설명하는 폼 기반 로그인이 됩니다.  </p>
<blockquote>
<p>아 물론, HTTP 기본 인증 == 폼 기반 로그인이라는 말은 아닙니다. 폼 양식을 통한 로그인도 username과 password를 통해 인증하기 때문에 HTTP 기본 인증 매커니즘을 이용하는 방식이라고 이해할 수 있다는 것입니다.  </p>
</blockquote>
<p>실제로 <a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#basic">스프링 시큐리티 레퍼런스 문서의 Basic and Digest Authentication</a>에서는 다음을 언급하고 있습니다.  </p>
<p>Basic authentication is often used with stateless clients which pass their credentials on each request. It’s quite common to use it in combination with form-based authentication where an application is used through both a browser-based user interface and as a web-service.</p>
<blockquote>
<p>인증과 권한이라는 개념을 이해하셨다면 스프링 시큐리티에 대해서 배워보도록 하겠습니다.</p>
</blockquote>
<h3 id="스프링-시큐리티-시작하기"><a href="#스프링-시큐리티-시작하기" class="headerlink" title="스프링 시큐리티 시작하기"></a>스프링 시큐리티 시작하기</h3><p>스프링 시큐리티는 메이븐이나 그래들같은 빌드도구를 통해 쉽게 가져올 수 있습니다.  </p>
<h4 id="with-Maven"><a href="#with-Maven" class="headerlink" title="with Maven"></a>with Maven</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... other dependency elements ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="with-Gradle"><a href="#with-Gradle" class="headerlink" title="with Gradle"></a>with Gradle</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	compile <span class="string">&#x27;org.springframework.security:spring-security-web:4.2.2.RELEASE&#x27;</span></span><br><span class="line">	compile <span class="string">&#x27;org.springframework.security:spring-security-config:4.2.2.RELEASE&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>저는 메이븐 대신 그래들을 사용해봤습니다.</p>
</blockquote>
<h3 id="Java-Configuration"><a href="#Java-Configuration" class="headerlink" title="Java Configuration"></a>Java Configuration</h3><p>스프링 시큐리티 레퍼런스에서는 자바 기반의 설정으로 설명하고 있습니다. 그 이유는 무엇일까요?  </p>
<p>스프링 프레임워크 3.1에서부터 어노테이션을 통한 자바 설정을 지원하기 때문에 스프링 시큐리티 3.2부터는 XML로 설정하지 않고도 간단하게 설정할 수 있도록 지원하기 때문입니다.  </p>
<p>원래 XML 기반의 설정에서는 web.xml에 org.springframework.web.filter.DelegatingFilterProxy라는 springSecurityFilterChain을 등록하는 것으로 시작합니다만, 자바 기반의 설정에서는 WebSecurityConfigurerAdapter를 상속받은 클래스에 @EnableWebSecurity 어노테이션을 명시하는 것만으로도 springSecurityFilterChain가 자동으로 포함되어집니다.    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 포함된 springSecurityFilterChain을 등록하기 위해서는 AbstractSecurityWebApplicationInitializer를 상속받은 WebApplicationInitializer를 만들어두면 됩니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityWebApplicationInitializer</span></span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span> <span class="title">AbstractSecurityWebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>XML을 작성하는 것보다는 자바 기반의 구성이 더욱 쉽습니다.  </p>
</blockquote>
<p>그 다음에는 보통 스프링 MVC를 이용해서 애플리케이션을 구성하기 때문에 ApplicationIniticalizer에 WebSecurityConfigurerAdapter를 상속받은 클래스를 getRootConfigClasses() 메소드에 추가하는 것으로 스프링 시큐리티에 대한 기본적인 적용은 끝입니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInitializer</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">		<span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Class[] &#123; WebSecurityConfig.class &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... other overrides ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>이로써 유추 해볼때, springSecurityFilterChain은 루트 컨텍스트에서 등록되어야하는 것을 알 수 있겠습니다. 각 필터에 대한 우선순위에 대해서도 추가적으로 알 필요성이 생기는 부분입니다.    </p>
</blockquote>
<h4 id="HttpSecurity"><a href="#HttpSecurity" class="headerlink" title="HttpSecurity"></a>HttpSecurity</h4><p>그리고나서 configure(HttpSecurity http) 메소드를 통해서 우리만의 인증 매커니즘을 구성해야합니다. 그런데 아직까지는 어떻게 구성해야할지 막막하기만 합니다. 관련된 정보를 좀더 찾아보도록 하겠습니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	http.httpBasic()</span><br><span class="line">		.and()</span><br><span class="line">		.authorizeRequests()</span><br><span class="line">			.antMatchers(<span class="string">&quot;/users/&#123;userId&#125;&quot;</span>).access(<span class="string">&quot;@authenticationCheckHandler.checkUserId(authentication,#userId)&quot;</span>)</span><br><span class="line">			.antMatchers(<span class="string">&quot;/admin/db/**&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;ADMIN_MASTER&#x27;) or hasRole(&#x27;ADMIN&#x27;) and hasRole(&#x27;DBA&#x27;)&quot;</span>)</span><br><span class="line">			.antMatchers(<span class="string">&quot;/register/**&quot;</span>).hasRole(<span class="string">&quot;ANONYMOUS&quot;</span>)</span><br><span class="line">		.and()</span><br><span class="line">		.formLogin()</span><br><span class="line">			.loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">			.usernameParameter(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">			.passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">			.successHandler(successHandler())</span><br><span class="line">			.failureHandler(failureHandler())</span><br><span class="line">			.permitAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>뭐 사실상 별게 없습니다. HttpSecurity의 인스턴스를 통해 자신만의 인증 매커니즘을 만들 수 있는 것이라고 보면 됩니다. 대부분의 설정은 여기를 통하게 되니까요 .authorizeRequests()를 통해 요청에 대한 권한을 지정할 수 있게 되는 것 같습니다. 그리고 기본적인 형태의 <code>.anyRequest().authenticated()</code>라는 의미는 어떠한 요청이든지 인증되어야한다는 것이겟죠? .formLogin()은 폼을 통한 로그인을 이용한다는 의미이며, .loginPage(“/login”)을 통해 로그인 페이지는 /login 경로로 제공하며 /login의 POST 요청이 바로 로그인 처리 과정이라는 것입니다.  </p>
<p>확장된 형태에서의 .antMatchers().hasRole() 또는 .antMatchers().access()는 해당 경로에 대해서 어떠한 권한을 가져야만 접근할 수 있는가를 표현하는 것입니다. 다음은 antMatchers() 다음으로 지정할 수 있는 항목들입니다.  </p>
<ul>
<li>anonymous()<br>인증되지 않은 사용자가 접근할 수 있습니다.  </li>
<li>authenticated()<br>인증된 사용자만 접근할 수 있습니다.  </li>
<li>fullyAuthenticated()<br>완전히 인증된 사용자만 접근할 수 있습니다(?)  </li>
<li>hasRole() or hasAnyRole()<br>특정 권한을 가지는 사용자만 접근할 수 있습니다.  </li>
<li>hasAuthority() or hasAnyAuthority()<br>특정 권한을 가지는 사용자만 접근할 수 있습니다.  </li>
<li>hasIpAddress()<br>특정 아이피 주소를 가지는 사용자만 접근할 수 있습니다.  </li>
<li>access()<br>SpEL 표현식에 의한 결과에 따라 접근할 수 있습니다.  </li>
<li>not()<br>접근 제한 기능을 해제합니다.   </li>
<li>permitAll() or denyAll()<br>접근을 전부 허용하거나 제한합니다.  </li>
<li>rememberMe()<br>리멤버 기능을 통해 로그인한 사용자만 접근할 수 있습니다.  </li>
</ul>
<blockquote>
<p>Role은 역할이고 Authority는 권한이지만 사실은 표현의 차이입니다. Role은 “ADMIN”으로 표현하고 Authority는 “ROLE_ADMIN”으로 표기하는 것 뿐입니다. 실제로 hasRole()에 ROLE_ADMIN으로 표기하면 ROLE을 지우라는 에러를 볼수 있게 됩니다.  </p>
</blockquote>
<blockquote>
<p>스프링 시큐리티 태그 라이브러리 또한 SpEL 표현식을 사용할 수 있습니다. &lt;sec:authentication /&gt; 이렇게 말입니다.  </p>
</blockquote>
<h4 id="AuthenticationManagerBuilder"><a href="#AuthenticationManagerBuilder" class="headerlink" title="AuthenticationManagerBuilder"></a>AuthenticationManagerBuilder</h4><p>AuthenticationManagerBuilder를 통해 인증 객체를 만들 수 있도록 제공하고 있습니다. 아래는 스프링 시큐리티 레퍼런스에서 알려주는 방식인데 AuthenticationManagerBuilder를 메소드를 통해 주입받아 처리하는 방식입니다. WebSecurityConfigurerAdapter의 configure(AuthenticationManagerBuilder auth)를 오버라이딩하는 것에 대한 차이는 없습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	auth.inMemoryAuthentication().withUser(<span class="string">&quot;scott&quot;</span>).password(<span class="string">&quot;tiger&quot;</span>).roles(<span class="string">&quot;ROLE_USER&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	auth.inMemoryAuthentication().withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;admin&quot;</span>).roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;DBA&quot;</span>);</span><br><span class="line">	auth.inMemoryAuthentication().withUser(<span class="string">&quot;scott&quot;</span>).password(<span class="string">&quot;tiger&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;SETTING&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>원하는 방식을 사용하면 됩니다. 하지만, 스프링 시큐리티 레퍼런스와 샘플을 만든 개발자가 왜 첫번째 방식으로 설명하는지에 대한 의미를 생각해봅시다.  </p>
<blockquote>
<p>아시는 분이 있다면 알려주시면 감사하겠습니다.  </p>
</blockquote>
<h3 id="스프링-시큐리티-속으로-들어가기"><a href="#스프링-시큐리티-속으로-들어가기" class="headerlink" title="스프링 시큐리티 속으로 들어가기"></a>스프링 시큐리티 속으로 들어가기</h3><p>지금까지 했던 설정들은 아주 기본적인 형태들이기 때문에 실제로 우리만의 인증 매커니즘으로 커스터마이징을 한 뒤 스프링 시큐리티에서 제공하는 부가적인 기능을 추가해야합니다.  </p>
<h4 id="Method-Security"><a href="#Method-Security" class="headerlink" title="Method Security"></a>Method Security</h4><p>스프링 시큐리티 2.0 에서부터 서비스 계층의 메소드에 보안을 추가할 수 있도록 지원합니다. @Secured 어노테이션 뿐만 아니라 JSR-250 어노테이션도 지원하도록 제공됩니다. 스프링 시큐리티 3.0에서는 표현 기반의 어노테이션을 사용할 수 있게 됩니다.  </p>
<p>우리는 Configuration 클래스에 @EnableGlobalMethodSecurity를 적용함으로써 어노테이션 기반의 보안을 활성화시킬 수 있습니다. 예를 들어, 스프링 시큐리티의 @Secured 어노테이션을 활성화시키려면 다음과 같이 구성하게 됩니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고나서 클래스 또는 인터페이스의 메소드에 @Secured 어노테이션을 추가하면 그에 따른 해당 메소드에 대한 액세스가 제한됩니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BankService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">readAccount</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Account[] findAccounts();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Secured(&quot;ROLE_TELLER&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">post</span><span class="params">(Account account, <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>역할 단위로 제약조건을 지정할 수 있음을 알 수 있습니다.</p>
</blockquote>
<p>스프링 시큐리티 3.0부터 지원하는 표현식 기반의 문법을 사용하기 위해서는 다음과 같이 구성합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BankService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;isAnonymous()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">readAccount</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;isAnonymous()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Account[] findAccounts();</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ROLE_TELLER&#x27;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">post</span><span class="params">(Account account, <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Remember-Me"><a href="#Remember-Me" class="headerlink" title="Remember-Me"></a>Remember-Me</h4><p>리멤버-미 기능은 도대체 무엇일까요? 구글에 what is remember me 라는 키워드로 검색을 해보았습니다.</p>
<ul>
<li><a href="https://www.formsite.com/faq/general/What-does-Remember-Me-mean-on-the-Login-page.html">What-does-Remember-Me-mean-on-the-Login-page</a>  </li>
<li><a href="http://help.thunderbird.edu/portal-login/remember-me">What is “Remember Me” ?</a>  </li>
</ul>
<p>단순히 아이디를 기억해놓는 것이 아니라 로그인 정보를 유지하는 것을 말합니다.  </p>
<p>Do NOT use “Remember Me” on any public computer, on campus, in Internet cafe’s, or anywhere else where you cannot control access!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	http.rememberMe().rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>).key(REMEMBER_ME_KEY).rememberMeServices(persistentTokenBasedRememberMeServices());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PersistentTokenBasedRememberMeServices <span class="title">persistentTokenBasedRememberMeServices</span><span class="params">()</span></span>&#123;</span><br><span class="line">	PersistentTokenBasedRememberMeServices persistentTokenBasedRememberMeServices =</span><br><span class="line">			<span class="keyword">new</span> PersistentTokenBasedRememberMeServices(REMEMBER_ME_KEY, userDetailsService, persistentTokenRepository());</span><br><span class="line">	<span class="keyword">return</span> persistentTokenBasedRememberMeServices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">persistentTokenRepository</span><span class="params">()</span></span>&#123;</span><br><span class="line">	TokenRepositoryImpl tokenRepositoryImpl = <span class="keyword">new</span> TokenRepositoryImpl();</span><br><span class="line">	<span class="keyword">return</span> tokenRepositoryImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>저는 영속성 기반의 리멤버-미 기능을 추가하였습니다. 이때, 리멤버-미 토큰을 저장할 수 있도록 TokenRepository 인터페이스를 구현해야하는데요. 일종의 서비스 객체라고 생각하시면 됩니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenRepositoryImpl</span>  <span class="keyword">implements</span> <span class="title">PersistentTokenRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TokenRepository tokenRepository;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNewToken</span><span class="params">(PersistentRememberMeToken token)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Token newToken = <span class="keyword">new</span> Token();</span><br><span class="line">		newToken.setEmail(token.getUsername());</span><br><span class="line">		newToken.setToken(token.getTokenValue());</span><br><span class="line">		newToken.setLast_used(token.getDate());</span><br><span class="line">		newToken.setSeries(token.getSeries());</span><br><span class="line">		tokenRepository.save(newToken);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateToken</span><span class="params">(String series, String tokenValue, Date lastUsed)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		Token updateToken = tokenRepository.findOne(series);</span><br><span class="line">		updateToken.setToken(tokenValue);</span><br><span class="line">		updateToken.setLast_used(lastUsed);</span><br><span class="line">		updateToken.setSeries(series);</span><br><span class="line">		tokenRepository.save(updateToken);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PersistentRememberMeToken <span class="title">getTokenForSeries</span><span class="params">(String series)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Token token = tokenRepository.findOne(series);</span><br><span class="line">		PersistentRememberMeToken persistentRememberMeToken = <span class="keyword">new</span> PersistentRememberMeToken(token.getEmail(), series, token.getToken(), token.getLast_used());</span><br><span class="line">		<span class="keyword">return</span> persistentRememberMeToken;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUserTokens</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		tokenRepository.deleteByEmail(username);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>본 애플리케이션에서의 Email은 유니크한 속성을 가집니다.</code></p>
<h4 id="Password-Encoding"><a href="#Password-Encoding" class="headerlink" title="Password Encoding"></a>Password Encoding</h4><p>AuthenticationManagerBuilder.userDetailsService().passwordEncoder()를 통해 패스워드 암호화에 사용될 PasswordEncoder 구현체를 지정할 수 있습니다. PasswordEncoder 인터페이스는 다음과 같이 구성되어 있습니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Encode the raw password. Generally, a good encoding algorithm applies a SHA-1 or</span></span><br><span class="line"><span class="comment">	 * greater hash combined with an 8-byte or greater randomly generated salt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Verify the encoded password obtained from storage matches the submitted raw</span></span><br><span class="line"><span class="comment">	 * password after it too is encoded. Returns true if the passwords match, false if</span></span><br><span class="line"><span class="comment">	 * they do not. The stored password itself is never decoded.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> rawPassword the raw password to encode and match</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> encodedPassword the encoded password from storage to compare with</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true if the raw password, after encoding, matches the encoded password from</span></span><br><span class="line"><span class="comment">	 * storage</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>단순히 인코딩하는 함수와 평문으로 제공되는 패스워드와 인코딩되어있는 패스워드(예를들어, 데이터베이스에 인코딩되어 저장되어 있는 패스워드)를 비교할 수 있습니다.  </p>
</blockquote>
<p>저는 PasswordEncoder 구현체인 BCryptPasswordEncoder를 지정했습니다. 당연히 직접 구현체를 만들어서 적용해도 됩니다! (아무래도 직접 만들어서 사용하는 것이 더 좋겟죠?)  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PasswordEncoder를 빈으로 등록해두면 다음과 같이 저장된 패스워드를 비교할 수 있습니다. 저장된 패스워드는 PasswordEncoder에 의해 암호화된 평문이기 때문입니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#updateUser.email == authentication.name&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long id, <span class="meta">@ModelAttribute</span> <span class="meta">@Valid</span> UserDTO.Update updateUser, Model model)</span></span>&#123;</span><br><span class="line">	User currentUser = userService.findOne(id);</span><br><span class="line">	<span class="keyword">if</span>(!passwordEncoder.matches(updateUser.getPassword(), currentUser.getPassword()))&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Not password equals...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WebSecurity-Ignoring"><a href="#WebSecurity-Ignoring" class="headerlink" title="WebSecurity Ignoring"></a>WebSecurity Ignoring</h4><p>스프링 시큐리티 레퍼런스와는 달리 리소스와 관련해서는 <code>WebSecurity.ignoring()</code>를 이용해서 보안이 적용되지 않도록 할 수 있도록 지원합니다. 스프링 시큐리티 API 문서에서 확인할 수 있는데 레퍼런스에 설명이 없다는 것이 좀 아쉬운 부분입니다.  </p>
<p><code>음... permitAll과 ignoring의 차이가 있는가를 아시는분은 댓글 남겨주시기 바랍니다 ㅠㅠ</code>  </p>
<h4 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h4><p>스프링 시큐리티는 메시지에 대한 현지화를 지원합니다. 메시지 소스 관련 프로퍼티 파일들은 spring-security-core.jar에 포함 되어져있습니다.  </p>
<p>우리는 메시지 프로퍼티 파일들을 메시지소스로 등록하면 됩니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">		messageSource.addBasenames(<span class="string">&quot;security/messages&quot;</span>);</span><br><span class="line">		messageSource.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> messageSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocaleChangeInterceptor <span class="title">localeChangeInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">		LocaleChangeInterceptor localeChangeInterceptor = <span class="keyword">new</span> LocaleChangeInterceptor();</span><br><span class="line">		localeChangeInterceptor.setParamName(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> localeChangeInterceptor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">		SessionLocaleResolver localeResolver = <span class="keyword">new</span> SessionLocaleResolver();</span><br><span class="line">		localeResolver.setDefaultLocale(Locale.KOREAN);</span><br><span class="line">		<span class="keyword">return</span> localeResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		registry.addInterceptor(localeChangeInterceptor());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>메시지 프로퍼티 파일들은 src/main/resource/security 폴더에 위치하고 있습니다.</p>
</blockquote>
<h4 id="AuthenticationSuccessHandler-amp-AuthenticationFailureHandler"><a href="#AuthenticationSuccessHandler-amp-AuthenticationFailureHandler" class="headerlink" title="AuthenticationSuccessHandler &amp; AuthenticationFailureHandler"></a>AuthenticationSuccessHandler &amp; AuthenticationFailureHandler</h4><p>OKKY의 질문게시판에서 로그인 실패를 어떻게 체크하는가에 대해서 질문하는 글을 보았습니다. 저는 스프링 시큐리티에서 사용하는 AuthenticationFailureHandler 구현체를 상속받아서 처리하도록 하겠습니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationSuccessHandlerImpl</span> <span class="keyword">extends</span> <span class="title">SavedRequestAwareAuthenticationSuccessHandler</span>  </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AuthenticationSuccessHandlerImpl.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">			Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		logger.info(<span class="string">&quot;Login Success... - &#123;&#125;&quot;</span>, authentication.getPrincipal());</span><br><span class="line">		response.sendRedirect(<span class="string">&quot;/?login&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AuthenticationSuccessHandler 구현체에서는 로그인을 성공했을때 호출(인증 객체가 생성되어진 후)되기 때문에 Authentication 인스턴스 파라미터를 이용할 수 있습니다. authentication.getPrincipal()을 호출하게 되면 저 같은 경우에는 org.springframework.security.core.userdetails.User 가 아닌 com.kdev.app.security.userdetails.UserDetails를 이용할 수 있습니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationFailureHandlerImpl</span> <span class="keyword">extends</span> <span class="title">SimpleUrlAuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AuthenticationFailureHandlerImpl.class);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AuthenticationFailureHandlerImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setDefaultFailureUrl(<span class="string">&quot;/login?error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">			AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		logger.info(<span class="string">&quot;Login Failed... - &#123;&#125;&quot;</span>,request.getParameter(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">		<span class="keyword">super</span>.onAuthenticationFailure(request, response, exception);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>로그인 실패 시 SimpleUrlAuthenticationFailureHandler의 defaultFailureUrl를 지정하면 SPRING_SECURITY_LAST_EXCEPTION에 대한 정보를 가지면서 해당 경로로 이동하게 됩니다.  </p>
<p>AuthenticationException으로 로그인 실패의 이유도 체크할 수 있게 되죠  </p>
<h3 id="스프링-시큐리티-페이지"><a href="#스프링-시큐리티-페이지" class="headerlink" title="스프링 시큐리티 페이지"></a>스프링 시큐리티 페이지</h3><p>스프링 시큐리티에서 제공해주는 기본 로그인 페이지 대신에 우리만의 로그인 페이지를 만들어보도록 하겠습니다.  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://www.springframework.org/security/tags&quot; prefix=&quot;sec&quot; %&gt;</span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ko&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		&lt;meta id=&quot;_csrf&quot; name=&quot;_csrf&quot; content=&quot;$&#123;_csrf.token&#125;&quot; /&gt;</span></span><br><span class="line"><span class="comment">		&lt;meta id=&quot;_csrf_header&quot; name=&quot;_csrf_header&quot; content=&quot;$&#123;_csrf.headerName&#125;&quot; /&gt;</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">sec:csrfMetaTags</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring Security + JPA<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Login Page <span class="tag">&lt;<span class="name">small</span>&gt;</span>with Bootstrap<span class="tag">&lt;/<span class="name">small</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span>&gt;</span></span><br><span class="line">		&lt;%-- <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;_csrf.parameterName&#125;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>/&gt;</span> --%&gt;</span><br><span class="line">		  <span class="tag">&lt;<span class="name">sec:csrfInput</span> /&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>이메일<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Email&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>비밀번호<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">		      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> &gt;</span> Remember me</span><br><span class="line">		    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span></span><br><span class="line">		  	<span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">&quot;$&#123;not empty SPRING_SECURITY_LAST_EXCEPTION&#125;&quot;</span>&gt;</span></span><br><span class="line">		  		<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text-danger&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">c:out</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;SPRING_SECURITY_LAST_EXCEPTION.message&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		  		<span class="tag">&lt;<span class="name">c:remove</span> <span class="attr">var</span>=<span class="string">&quot;SPRING_SECURITY_LAST_EXCEPTION&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br><span class="line">		  	<span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>&gt;</span>로그인<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/register&quot;</span>&gt;</span>회원가입<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">   &lt;script src=&quot;https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">   &lt;script src=&quot;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>SPRING_SECURITY_LAST_EXCEPTION</code>의 존재 여부에 따라서 스프링 시큐리티에서 발생하는 예외에 대한 메시지를 출력할 수 있습니다.  </p>
<blockquote>
<p>스프링 시큐리티 레퍼런스에서는 단순히 파라미터의 존재여부에 따라서 출력형태를 지정하고 있습니다. 이 부분도 참 아쉽습니다.  </p>
</blockquote>
<h3 id="UserDetails-amp-UserDetailsService"><a href="#UserDetails-amp-UserDetailsService" class="headerlink" title="UserDetails &amp; UserDetailsService"></a>UserDetails &amp; UserDetailsService</h3><p>아 죄송합니다. UserDetails 인터페이스에 대해서 설명을 안했네요 ㅠㅠ  </p>
<p>스프링 시큐리티는 사용자 정보를 UserDetails 구현체로 사용합니다. 그래서 스프링 시큐리티는 org.springframework.security.core.userdetails.User라는 클래스를 제공합니다. 그러나, 이름과 패스워드 그리고 권한들에 대한 필드만 존재하기 때문에 이메일 정보 또는 프로필 이미지 경로 등과 같은 부가적인 정보를 담을 수 없습니다.  </p>
<p>따라서, UserDetails 구현체를 직접 만들어야 합니다. org.springframework.security.core.userdetails.User 자체도 UserDetails 구현체이기 때문에 이를 상속받아서 구현해도 됩니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">security</span>.<span class="title">core</span>.<span class="title">userdetails</span>.<span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4855890427225819382L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> String nickname;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line">	<span class="keyword">private</span> Date createdAt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserDetails</span><span class="params">(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(username, password, authorities);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserDetails</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(user.getEmail(), user.getPassword(), user.isAccountNonExpired(), user.isAccountNonLocked(), user.isCredentialsNonExpired(), user.isEnabled(), authorities(user));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.id = user.getId();</span><br><span class="line">		<span class="keyword">this</span>.nickname = user.getNickname();</span><br><span class="line">		<span class="keyword">this</span>.email = user.getEmail();</span><br><span class="line">		<span class="keyword">this</span>.createdAt = user.getCreatedAt();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getNickname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNickname</span><span class="params">(String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.email = email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getCreatedAt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> createdAt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreatedAt</span><span class="params">(Date createdAt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.createdAt = createdAt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Collection&lt;? extends GrantedAuthority&gt; authorities(User user) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		List&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;GrantedAuthority&gt;();</span><br><span class="line">		user.getAuthorities().forEach(a -&gt; &#123;</span><br><span class="line">			authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(a.getAuthority()));</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> authorities;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserDetails</span><span class="params">(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities,</span></span></span><br><span class="line"><span class="params"><span class="function">			String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(username, password, authorities);</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">		<span class="keyword">this</span>.email = username;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserDetails</span><span class="params">(String username, String password, <span class="keyword">boolean</span> enabled, <span class="keyword">boolean</span> accountNonExpired,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">boolean</span> credentialsNonExpired, <span class="keyword">boolean</span> accountNonLocked,</span></span></span><br><span class="line"><span class="params"><span class="function">			Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(username, password, authorities);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그러면 우리는 Authentication.getPrincipal() 메소드를 통해 얻은 Principal 객체를 통해서도 부가적인 필드에 접근할 수 있습니다.  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sec:authentication</span> <span class="attr">property</span>=<span class="string">&quot;principal.email&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>org.springframework.security.core.userdetails.UserDetailsService 구현체는 스프링 시큐리티 인증 시에 사용됩니다. UserRepository를 통해 영속성으로 저장된 인증정보를 검색한 후 존재하지 않다면 UsernameNotFoundException을 던지고 있다면 UserDetails 객체를 반환합니다.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsService</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">security</span>.<span class="title">core</span>.<span class="title">userdetails</span>.<span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String email)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		User user = userRepository.findByEmail(email);</span><br><span class="line">		<span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(email);</span><br><span class="line">		&#125;</span><br><span class="line">		com.kdev.app.security.userdetails.UserDetails userDetails = <span class="keyword">new</span> com.kdev.app.security.userdetails.UserDetails(user);</span><br><span class="line">		<span class="keyword">return</span> userDetails;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데 좀 이상하다고 느껴집니다. 그러면 패스워드 검증은 언제하는것일까요? 바로 AuthenticationProvider 구현체에서 진행하게 됩니다. AuthenticationProvider 구현체에서는 authenticate() 메소드를 통해서 Authentication 객체(UsernamePasswordAuthentication)를 반환합니다. 즉, 반환하기 직전에 패스워드를 검증하는 것입니다.  </p>
<p>우리는 AuthenticationProvider를 직접적으로 구현하지 않았으니까 이 부분에 대해서 모르고 넘어갈 뻔 했습니다.</p>
<p><a href="http://syaku.tistory.com/286">샤쿠님의 스프링 시큐리티 커스텀 로그인</a>이라는 글에서 직접 AuthenticationProvider를 구현해서 사용하는 것을 확인할 수 있습니다.</p>
<h2 id="끝마치며"><a href="#끝마치며" class="headerlink" title="끝마치며"></a>끝마치며</h2><p>우리가 알아본 것 이외에도 스프링 시큐리티가 제공하는 기능들이 더 존재합니다. 예를 들어, 웹소켓, RESTful API등에도 보안을 적용할 수 있습니다.</p>
<p>공부하면서 알게된 부분인데, 스프링 프레임워크에서 제공하는 인-메모리 기반 인증 객체(inMemoryAuthentication())는 파라미터로 제공되는 UserDetails의 정보를 활용하여 User 객체를 생성하기 때문에 UserDetails의 구현체를 만든다 하더라도 의미가 없게 됩니다. 만약, 인 메모리 방식과 영속성 방식을 혼용해서 사용하고 싶다면 이 부분에 대해서 연구해볼 필요가 있겠습니다.  </p>
<p>다음은 스프링 시큐리티에 대해서 알아볼 때 좋은 포스트 및 동영상들입니다.  </p>
<ul>
<li><a href="http://syaku.tistory.com/278">샤쿠님의 스프링 시큐리티 커스텀 로그인</a>  </li>
<li><a href="http://zgundam.tistory.com/43">제타건담님의 스프링 시큐리티</a>  </li>
<li><a href="https://www.youtube.com/watch?v=C0BQplG7Epo&list=PLvudjKUrAA6bLu1CvgSPEKLhlIEIAJXjm">아라한사님의 스프링 시큐리티 따라해보기</a>  </li>
<li><a href="https://www.youtube.com/watch?v=AiDjJzMXWmM">백기선님의 스프링 시큐리티</a>  </li>
<li><a href="http://hamait.tistory.com/325">하마님의 스프링 시큐리티</a>  </li>
</ul>
<blockquote>
<p>아는게 없으니 쉽게 이해하지 못하는 부분이 많습니다. 많은 신입 개발자들을 응원합니다 ^ㅡ^  </p>
</blockquote>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS Elastic Beanstalk Java SE 플랫폼 환경으로 애플리케이션 배포하기</title>
    <url>/deploy-application-to-the-aws-elastic-beanstalk-java-se-platform-enviroment/</url>
    <content><![CDATA[<p><img data-src="/images/posts/beanstalk-java-se-platform/aws-elastic-beanstalk-logo.jpg#compact"></p>
<p>안녕하세요 Mambo 입니다. 이번 글은 AWS Elastic Beanstalk의 <code>Java SE 플랫폼 환경</code>을 사용하여 개발된 스프링 부트 애플리케이션을 배포하는 과정에 대해서 학습합니다. AWS를 사용중이라면 <code>Elastic Beanstalk</code> 서비스를 통해 애플리케이션이 실행되는 환경을 빠르고 쉽게 구성할 수 있으며 애플리케이션을 배포하고 환경 성능 지표에 따라 프로비저닝할 수 있는 기능을 적용할 수 있습니다.</p>
<p>저와 같이 Elastic Beanstalk 경험이 부족한 초보 개발자 또는 회사에서 서비스 배포를 담당하지 않는 개발자분들은 이 글을 통해 Elastic Beanstlak로 자바 웹 애플리케이션을 배포할 수 있는 환경을 구성하고 어떤 방식으로 애플리케이션을 배포할 수 있는지를 이해할 수 있을 것 입니다. </p>
<blockquote>
<p>개발 경력은 4년이 지났으나 애플리케이션 배포를 담당하는 것은 얼마되지 않았어요…</p>
</blockquote>
<h2 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h2><p>AWS에서 제공하는 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/Welcome.html">Elastic Beanstalk</a>서비스는 AWS 클라우드 환경에서 빠르게 애플리케이션을 배포하고 애플리케이션이 구동되는 환경을 쉽게 관리할 수 있는 AWS의 주요 서비스입니다. Beanstalk을 사용하면 Go, Java, Node.js, Python 등 다양한 언어로 개발된 애플리케이션을 배포할 수 있습니다.</p>
<p>이 글에서 배포할 애플리케이션 소스 코드는 깃허브 <a href="https://github.com/kdevkr/beanstalk-deploy-sample">beanstalk-deploy-sample</a>에 공유되어있으니 참고하시기를 바랍니다.</p>
<blockquote>
<p>엄청 간단한 애플리케이션이에요!</p>
</blockquote>
<h3 id="Java-SE-플랫폼"><a href="#Java-SE-플랫폼" class="headerlink" title="Java SE 플랫폼"></a>Java SE 플랫폼</h3><p>Elastic Beanstalk는 다양한 언어로 작성된 애플리케이션을 배포할 수 있게 여러 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/concepts.platforms.html">플랫폼 환경</a>을 지원합니다. 이 중에서 제가 준비한 애플리케이션을 배포할 수 있는 환경은 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/platforms/platforms-supported.html#platforms-supported.javase">Java SE 플랫폼</a>입니다.</p>
<blockquote>
<p>별도로 Tomcat 플랫폼이 존재하기는 하지만 이 글에서의 주요 관심사는 아니에요.</p>
</blockquote>
<p><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-platform.html">Elastic Beanstalk Java SE 플랫폼</a>은 자체적으로 실행가능하도록 컴파일된 JAR 파일으로 애플리케이션을 실행할 수 있는 환경으로 제가 준비한 애플리케이션이 스프링 부트 기반으로 작성되어있으므로 이 환경이 애플리케이션을 배포할 수 있는 가장 적합한 환경입니다. 스프링 부트에서 제공하는 지원 중 하나는 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-executable-jar-format.html">실행가능한 JAR 또는 WAR 파일</a>으로 패키징할 수 있는 부분입니다.</p>
<h4 id="기본-배포-유형"><a href="#기본-배포-유형" class="headerlink" title="기본 배포 유형"></a>기본 배포 유형</h4><p>Elastic Beanstalk의 Java SE 플랫폼 환경은 두가지 방식으로 환경에 업로드된 애플리케이션 파일을 배포할 수 있게 지원합니다. 기본적으로 배포되는 방식은 단일 파일로 자체적으로 실행가능하도록 컴파일된 JAR 파일을 이용하는 것으로 다음의 명령어를 수행하여 Java SE 플랫폼 환경에서 애플리케이션을 구동합니다.</p>
<figure class="highlight sh"><figcaption><span>기본 실행 명령어</span></figcaption><table><tr><td class="code"><pre><span class="line">java -jar application.jar</span><br></pre></td></tr></table></figure>

<p>위 명령에서 애플리케이션 파일명이 <code>application.jar</code>인 이유는 우리가 환경에 업로드한 애플리케이션 파일을 application.jar라는 이름으로 변경하기 때문이며 여러분이 어떤 파일의 이름으로 제공하든 상관이 없습니다.</p>
<h4 id="사용자-정의-배포"><a href="#사용자-정의-배포" class="headerlink" title="사용자 정의 배포"></a>사용자 정의 배포</h4><p>두번째는 다수의 컴파일된 JAR 또는 <code>Procfile</code>이라는 명령어 파일을 통해 애플리케이션을 실행할 수 있는 방식입니다. 이 방식을 사용하면 하나의 환경에서 여러개의 애플리케이션을 실행할 수 있거나 직접 실행할 수 있는 명령어를 정의하므로 JVM 옵션 또는 커맨드 라인 파라미터를 설정할 수 있습니다.</p>
<figure class="highlight plaintext"><figcaption><span>Procfile</span></figcaption><table><tr><td class="code"><pre><span class="line">web: java -Dfile.encoding=UTF-8 -Djava.net.preferIPv4Stack=true -Xmx1g -jar app.jar</span><br></pre></td></tr></table></figure>

<p>이렇게 패키징된 JAR 파일과 Procfile을 묶어서 제공하는 파일을 Elastic Beanstalk에서는 소스 번들(Source Bundle)이라고 말합니다. 소스 번들 파일을 Java SE 플랫폼 환경에 업로드하여 배포하는 방식은 아마존 웹 서비스에서도 추천하는 방식입니다.</p>
<h3 id="Linux-플랫폼-확장"><a href="#Linux-플랫폼-확장" class="headerlink" title="Linux 플랫폼 확장"></a>Linux 플랫폼 확장</h3><p>소스 번들 파일로 사용자 정의 배포 방식을 사용하는 경우 .ebextensions, .platform이라는 폴더를 포함시켜 Java SE 플랫폼 환경에 대한 확장을 수행할 수 있도록 지원합니다. 플랫폼 확장에 대한 자세한 내용은 AWS Elastic Beanstalk 개발자 가이드의 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/platforms-linux-extend.html">Elastic Beanstalk Linux 플랫폼 확장</a>를 통해 확인할 수 있습니다.</p>
<p><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/platforms-linux-extend.html#platforms-linux-extend.workflow">인스턴스 배포 워크플로우</a>를 참고하면 업로드된 소스 번들 파일을 통해 Elastic Beanstalk이 어떻게 애플리케이션을 배포하는지 확인할 수 있습니다. 플랫폼 확장을 통해 다음의 작업을 수행할 수 있습니다.</p>
<ul>
<li>애플리케이션 실행하기 전 명령어 수행</li>
<li>역방향 프록시 구성</li>
</ul>
<p>우아한 형제들 기술 블로그의 <a href="https://woowabros.github.io/woowabros/2017/08/07/ebextension.html">Elastic Beanstalk Configuration files(.ebextensions)</a>에서처럼 플랫폼 확장을 통해 모니터링 패키지를 설치하거나 로컬 타임을 변경할 수 있습니다.</p>
<h2 id="빌드부터-배포까지"><a href="#빌드부터-배포까지" class="headerlink" title="빌드부터 배포까지"></a>빌드부터 배포까지</h2><p>Elastic Beanstalk의 Java SE 플랫폼 환경에 대해서 알게되었으니 이제부터 제가 준비한 애플리케이션을 Java SE 플랫폼 환경에 배포하는 과정을 확인하면서 빌드부터 배포까지의 프로세스를 숙지해보도록 하겠습니다.</p>
<p>여러분들도 따라하고 싶다면 <a href="https://github.com/kdevkr/beanstalk-deploy-sample">kdevkr/beanstalk-deploy-sample</a>을 참고하시기 바랍니다.</p>
<h3 id="실행가능한-JAR-파일-준비하기"><a href="#실행가능한-JAR-파일-준비하기" class="headerlink" title="실행가능한 JAR 파일 준비하기"></a>실행가능한 JAR 파일 준비하기</h3><p>스프링 부트는 그래들(Gradle) 또는 메이븐(Maven) 도구를 사용하여 실행가능한 JAR 또는 WAR 파일을 패키징할 수 있는 방법을 제공합니다. 저는 그래들을 빌드 도구로 사용하는 스프링 부트 프로젝트를 구성하여 다음과 같이 빌드 태스크에 <code>bootJar</code>와 <code>bootWar</code>가 포함되어있습니다. </p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/spring-boot-gradle-build-01.png"></p>
<p>실행가능한 JAR 파일로만 배포할 수 있는 것이 아님을 확인하기 위해 저는 bootWar 태스크로 애플리케이션을 실행가능한 WAR 파일로 패키징하겠습니다. 이 태스크로 패키징된 WAR 파일을 <code>build/libs</code> 폴더에 생성됩니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/spring-boot-gradle-build-02.png"></p>
<p>이렇게 패키징된 WAR 파일을 확인할 수 있으나 Java SE 플랫폼에 애플리케이션을 배포하는 방식 중 사용자 정의 배포 방식을 위해 생성된 WAR 파일과 함께 이 파일을 실행하는 명령어를 정의한 <code>Procfile</code>을 만들어 하나의 소스 번들로 만드는 과정을 진행하겠습니다.</p>
<p>소스 번들 파일을 만들기 위해서 build/libs 폴더에 직접 Procfile을 생성하여 실행 명령어를 정의하면 안됩니다. build 폴더는 Git에서 무시되는 경로이며 clean 태스크에 의해서 쉽게 삭제될 수 있습니다. 가장 쉽게 떠오르는 방법은 프로젝트 루트 경로에 Procfile을 만들어서 build/libs에 패키징된 WAR파일과 압축하는 것입니다.</p>
<p>다행히도 그래들 태스트 유형 중에서 아카이브(압축 파일)을 만들 수 있는 <a href="https://docs.gradle.org/current/userguide/working_with_files.html#sec:creating_archives_example">Zip</a> 태스크 유형이 있으므로 이 유형에 대한 태스크를 작성하여 소스 번들을 만드는 태스크를 수행하도록 하겠습니다.</p>
<p>먼저, 프로젝트 루트 경로에 <code>Procfile</code>을 만들어 애플리케이션 실행 명령어를 작성합니다.</p>
<figure class="highlight plaintext"><figcaption><span>Procfile</span></figcaption><table><tr><td class="code"><pre><span class="line">web: java -Xmx1g -jar demo.war</span><br></pre></td></tr></table></figure>

<p>그리고 패키징된 WAR 파일과 Procfile을 압축한 파일을 생성하는 태스크를 작성합니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">task zipSourceBundle(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> <span class="string">&#x27;bootWar&#x27;</span>) &#123;</span><br><span class="line">    from (<span class="string">&#x27;Procfile&#x27;</span>) &#123;</span><br><span class="line">        include(<span class="string">&#x27;Procfile&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        println bootWar.archiveName</span><br><span class="line">        include(bootWar.archiveName)</span><br><span class="line">    &#125;</span><br><span class="line">    baseName = <span class="string">&#x27;beanstalk&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>작성된 zipSourceBundle 태스크를 수행하면 <code>build/distributions</code> 폴더에 <code>beanstalk.zip</code>이라는 소스 번들 파일이 생성됨을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/spring-boot-gradle-build-03.png"></p>
<p>그런데 말입니다. 만약, bootWar 태스크에 의해 만들어지는 파일명이 <code>demo.war</code>가 아니라면 어떻게 될까요? Procfile에 정의한 명령어와 일치하지 않아 애플리케이션을 배포하는 과정에서 오류가 발생할 것입니다. 이 문제를 해결할 수 있는 좋은 방법은 그래들 빌드 과정에서 Procfile을 생성하는 것입니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">task procfile(<span class="attr">dependsOn:</span> <span class="string">&#x27;bootWar&#x27;</span>) &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&quot;build/libs&quot;</span>, <span class="string">&quot;Procfile&quot;</span>).text = <span class="string">&quot;web: java -Xmx1g -jar $&#123;bootWar.archiveName&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>작성된 procfile 태스크는 bootWar 태스크에 의해 만들어지는 WAR 파일명을 주입하여 Procfile을 build/libs 위치에 생성합니다. 그리고 앞서 작성한 zipSourceBundle를 보완한 zipBeanstalk 태스크를 작성합니다. </p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">task zipBeanstalk(<span class="attr">type:</span> Zip, <span class="attr">dependsOn:</span> <span class="string">&#x27;procfile&#x27;</span>) &#123;</span><br><span class="line">    from (<span class="string">&#x27;build/libs&#x27;</span>) &#123;</span><br><span class="line">        println bootWar.archiveName</span><br><span class="line">        include(bootWar.archiveName)</span><br><span class="line">        include(<span class="string">&quot;Procfile&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    baseName = <span class="string">&#x27;beanstalk&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 zipBeanstalk 태스크를 수행하였더니 다음과 같이 애플리케이션 소스 번들 파일이 생성되었습니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/spring-boot-gradle-build-04.png"></p>
<p>그래들 빌드 시 프로젝트 버전(project.version)이 명시되어도 Procfile과 패키징된 WAR 파일명이 다른 경우가 발생하지 않습니다.</p>
<blockquote>
<p>프로젝트 버전을 명시하면 아카이브 파일명에 프로젝트 버전이 포함되요!</p>
</blockquote>
<p><img data-src="/images/posts/beanstalk-java-se-platform/spring-boot-gradle-build-05.png" alt="-Pversion=1.0.0"></p>
<blockquote>
<p>오옷! 좋아요.</p>
</blockquote>
<h3 id="Java-SE-플랫폼-환경-시작하기"><a href="#Java-SE-플랫폼-환경-시작하기" class="headerlink" title="Java SE 플랫폼 환경 시작하기"></a>Java SE 플랫폼 환경 시작하기</h3><p>애플리케이션 소스 번들 파일이 준비되었으므로 Elastic Beanstalk 서비스에서 자바 애플리케이션을 배포할 수 있는 환경을 생성합니다. 환경에 대한 이름, 도메인을 설정한 후 우리가 준비한 스프링 부트 애플리케이션은 자체적으로 실행되는 JAR로 컴파일된 애플리케이션이므로 <code>Java SE 플랫폼 환경</code>을 선택합니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-01.png" alt="웹 서버 환경 선택"></p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-02.png" alt="환경 및 도메인 설정"></p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-03.png" alt="Java SE 플랫폼 선택"></p>
<p>앞서 준비한 애플리케이션 소스 번들파일을 선택하여 업로드합니다. </p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-04.png"></p>
<p><strong>주의!</strong></p>
<p>위 화면에서 환경 생성 버튼을 누르면 기본으로 정의되어있는 인스턴스 프로파일이 구성된 Java SE 플랫폼 환경을 구성하여 애플리케이션을 배포할 수 있습니다. 그러나 주의해야될 사항은 다음 처럼 환경을 생성하고나서 <strong>변경할 수 없는 부분들이 있다</strong>는 점입니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-05.png"></p>
<p>기본 Java SE 플랫폼은 <strong>CLB(Classic Load Balancer)</strong> 를 로드밸런서로 사용하는데 환경이 생성된 이후에 로드 밸런서 유형을 변경하고자 구성 편집을 시도하였지만 유형을 변경하는 것을 제공하지 않습니다. 따라서, L7 레벨의 로드밸런서인 <strong>ALB(Application Load Balancer)</strong> 또는 L4 레벨의 <strong>NLB(Network Load Balancer)</strong> 를 환경에 대한 로드밸런서로 사용하기 위해서는 추가 옵션 구성 기능으로 사용자 정의 환경을 생성해야합니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-06.png" alt="기본 VPC를 지워서 VPC 환경이 없는 채로 만들어진..."></p>
<blockquote>
<p>aws ec2 create-default-vpc 명령으로 기본 VPC를 다시 만들수는 있다…</p>
</blockquote>
<p>Java SE 플랫폼에서 기본적으로 제공하는 Nginx 프록시 구성은 HTTP(80) 트래픽에 대해 5000 포트를 사용하는 애플리케이션으로 라우팅되도록 설정되어있습니다. Beanstalk에 의해 생성된 EC2 인스턴스에 접속해서 Nginx 설정 정보를 찾아보면 다음과 같이 <code>00_application.conf</code> 파일에 프록시 구성이 정의되어 있음을 확인할 수 있습니다.</p>
<figure class="highlight sh"><figcaption><span>/etc/nginx/conf.d/elasticbeanstalk/00_application.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@ip-172-31-40-185 ~]<span class="comment"># cat /etc/nginx/conf.d/elasticbeanstalk/00_application.conf </span></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass          http://127.0.0.1:5000;</span><br><span class="line">    proxy_http_version  1.1;</span><br><span class="line"></span><br><span class="line">    proxy_set_header    Connection          <span class="variable">$connection_upgrade</span>;</span><br><span class="line">    proxy_set_header    Upgrade             <span class="variable">$http_upgrade</span>;</span><br><span class="line">    proxy_set_header    Host                <span class="variable">$host</span>;</span><br><span class="line">    proxy_set_header    X-Real-IP           <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_set_header    X-Forwarded-For     <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데 제가 배포한 스프링 부트 애플리케이션은 별도로 실행되는 포트를 지정하지 않아 8080 포트를 할당합니다. </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@ip-172-31-40-185 ~]<span class="comment"># netstat -tnlp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name           </span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      3512/java </span><br></pre></td></tr></table></figure>

<p>Elastic Beanstalk은 5000 포트에 대한 애플리케이션 상태를 확인하므로 Elastic Beanstalk은 환경 상태를 올바르지 않다고 피드백하게 됩니다. 따라서, 로드밸런서가 트래픽을 애플리케이션으로 라우팅할 수 있도록 애플리케이션을 5000 포트로 할당하도록 해야합니다. 다만, 애플리케이션이 5000 포트를 사용하도록 애플리케이션 프로퍼티 중 <strong>server.port</strong> 를 5000으로 지정하고 다시 패키징하여 배포하는 것은 불편할 수 있습니다.</p>
<p>다시 패키징하지 않더라도 애플리케이션이 구동되는 포트를 변경할 수 있는 방법을 고려해보도록 하죠.</p>
<ol>
<li>기본 <a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-nginx.html">역방향 프록시 구성</a> 파일에 정의된 포트 변경</li>
</ol>
<ul>
<li>PORT 환경 속성으로 기본 애플리케이션이 수신 대기하는 포트를 재정의</li>
</ul>
<ol start="2">
<li>JVM 옵션을 지정하여 애플리케이션 실행 포트 변경</li>
</ol>
<p>1번 방법은 기본으로 정의되는 Nginx 프록시 구성을 변경하는 방법으로 <code>PORT</code>라는 환경 속성에 따라 00_application.conf의 내용을 정의합니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-07.png" alt="PORT 환경 속성 정의"></p>
<figure class="highlight sh"><figcaption><span>00_application.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@ip-172-31-40-185 ~]<span class="comment"># cat /etc/nginx/conf.d/elasticbeanstalk/00_application.conf </span></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass          http://127.0.0.1:8080;</span><br><span class="line">    proxy_http_version  1.1;</span><br><span class="line"></span><br><span class="line">    proxy_set_header    Connection          <span class="variable">$connection_upgrade</span>;</span><br><span class="line">    proxy_set_header    Upgrade             <span class="variable">$http_upgrade</span>;</span><br><span class="line">    proxy_set_header    Host                <span class="variable">$host</span>;</span><br><span class="line">    proxy_set_header    X-Real-IP           <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_set_header    X-Forwarded-For     <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PORT 환경 속성에 따라 애플리케이션 프록시 포트가 변경되었어요!</p>
</blockquote>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-08.png"></p>
<p>스프링 부트 기반의 애플리케이션을 개발하는 개발자라면 환경 속성이라는 이름을 보고 스프링 부트가 지원하는 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">외부화 구성(Externalized Configuration)</a>을 떠올랐을 수 있습니다. 외부화 구성 순서 5번 항목에 <code>OS 환경 변수</code>가 있는데 인텔리제이로 애플리케이션을 구동할 때 환경 변수를 지정하여 프로퍼티 값을 설정할 수 있는 것이 이 부분입니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/spring-boot-run-configuration-environment-variables.png"></p>
<p>이번에는 PORT 환경 속성이 아닌 <code>SERVER_PORT</code> 환경 속성에 5000을 설정하여 애플리케이션이 5000 포트로 구동되는지를 확인해봅시다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-09.png" alt="SERVER_PORT 환경 속성"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@ip-172-31-40-185 ~]<span class="comment"># netstat -tnlp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name              </span><br><span class="line">tcp6       0      0 :::5000                 :::*                    LISTEN      6244/java           </span><br></pre></td></tr></table></figure>

<blockquote>
<p>SERVER_PORT 환경 속성에 정의된 포트로 애플리케이션이 실행되었어요!</p>
</blockquote>
<h4 id="JVM-옵션-설정"><a href="#JVM-옵션-설정" class="headerlink" title="JVM 옵션 설정"></a>JVM 옵션 설정</h4><p>환경 속성을 통해 SERVER_PORT를 정의하여 애플리케이션 프로퍼티를 변경할 수 있지만 JVM 옵션으로 <code>server.port</code>에 대한 값으로 5000을 지정하는 것을 시도해보겠습니다. 일반적으로 JVM 옵션을 지정하기 위해서는 -Dserver.port와 같이 java 명령어를 수행할 때 지정해야합니다. 하지만 우리는 Procfile에 실행 명령어를 정의해놓았으므로 추가적인 JVM 옵션을 지정할 수 있는 방안이 없습니다.</p>
<p>Elastic Beanstalk에서 JVM 옵션을 지정하는 방법을 검색해보면 <a href="https://www.oracle.com/java/technologies/javase/envvars.html#gbmsy">JAVA_TOOL_OPTIONS</a> 환경 변수로 지정할 수 있음을 찾을 수 있습니다. JAVA_TOOL_OPTIONS 환경 변수 외에도 JVM 마다 JAVA_OPTS 또는 <a href="https://stackoverflow.com/questions/28327620/difference-between-java-options-java-tool-options-and-java-opts">_JAVA_OPTIONS</a>를 사용할 수 있습니다만 JAVA_TOOL_OPTIONS이 <code>JVMTI</code> 표준 스펙이므로 JAVA_TOOL_OPTIONS을 사용하여 JVM 옵션을 설정하는 게 올바른 방법입니다.</p>
<blockquote>
<p>Java SE 플랫폼 환경의 Correcto JDK는 _JAVA_OPTIONS 환경 속성도 적용되요!</p>
</blockquote>
<p>다음은 Elastic Beanstalk Java SE 플랫폼 환경에서 JAVA_TOOL_OPTIONS와 _JAVA_OPTIONS 환경 속성을 지정했을 때 적용 순서입니다.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Mar  5 16:37:54 ip-172-31-40-185 web: Picked up JAVA_TOOL_OPTIONS: -Dserver.port=5000</span><br><span class="line">Mar  5 16:37:54 ip-172-31-40-185 web: Picked up _JAVA_OPTIONS: -Dserver.port=5001</span><br><span class="line"></span><br><span class="line">[root@ip-172-31-40-185 ~]<span class="comment"># jps -v</span></span><br><span class="line">3634 war -Dserver.port=5000 -Xmx1g -Dserver.port=5001</span><br><span class="line">3740 Jps -Dapplication.home=/usr/lib/jvm/java-11-amazon-corretto.x86_64 -Xms8m -Djdk.module.main=jdk.jcmd</span><br></pre></td></tr></table></figure>

<p>JAVA_TOOL_OPTIONS 보다 _JAVA_OPTIONS 환경 속성이 나중에 적용되며 Procfile에 정의된 JVM 옵션과의 순서도 다른 것을 확인할 수 있습니다.</p>
<h3 id="추가-옵션-구성"><a href="#추가-옵션-구성" class="headerlink" title="추가 옵션 구성"></a>추가 옵션 구성</h3><p>기본으로 정의된 환경으로 시작하기보다는 <code>추가 옵션 구성</code> 기능을 통해 사용자 정의된 Java SE 플랫폼 환경을 구성하는 것이 좋습니다. 사전 설정을 통해 인스턴스 규모를 선택할 수 있으나 직접 환경 옵션을 정의하기 위해 <strong>사용자 지정 구성</strong> 을 선택합니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-10.png"></p>
<p>사용자 지정 구성 선택시 제공되는 기본 옵션은 다음과 같습니다. 몇가지 옵션에 대해서 수정을 해보도록 하죠.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-11.png"></p>
<h4 id="소프트웨어"><a href="#소프트웨어" class="headerlink" title="소프트웨어"></a>소프트웨어</h4><p>가장 먼저, 소프트웨어 옵션을 편집하여 기본으로 지정된 애플리케이션 프록시 포트에 맞게 실행될 수 있도록 SERVER_PORT 환경변수를 등록합니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-12.png"></p>
<h4 id="용량"><a href="#용량" class="headerlink" title="용량"></a>용량</h4><p>용량 옵션을 편집하여 Elastic Beanstalk이 EC2 인스턴스를 어떻게 실행하고 관리할지 설정할 수 있습니다. 기본 단일 인스턴스 환경은 로드밸런서를 사용할 수 없으므로 오토 스케일링 기능을 활성화하기 위하여 로드 밸런싱 수행 환경으로 변경합니다. 로드 밸런싱 수행 환경이지만 처음에는 <strong>단일 인스턴스</strong> 로 시작하기 위하여 인스턴스의 최대 크기를 1로 지정합니다.</p>
<p>만약, 여러분의 애플리케이션이 요구하는 메모리 크기와 CPU 성능이 있다면 인스턴스 유형을 변경합니다. 저는 간단한 애플리케이션을 배포하므로 기본으로 설정된 t2.micro를 사용하겠습니다.</p>
<blockquote>
<p>t2.micro는 1GB의 메모리 크기를 가집니다.</p>
</blockquote>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-13.png"></p>
<h4 id="로드밸런서"><a href="#로드밸런서" class="headerlink" title="로드밸런서"></a>로드밸런서</h4><p>용량 옵션에서 로드 밸런싱 환경을 선택하면 로드밸런서 옵션을 설정할 수 있게 활성화됩니다. </p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-14.png"></p>
<p>기본으로 지정된 로드밸런서는 L7 레벨의 ALB(Application Load Balancer)으로 변경할 필요는 없지만 회사에서는 빠른 트래픽 처리를 위해 L4 레벨의 NLB(Network Load Balancer)를 사용하므로 NLB로 지정하겠습니다. </p>
<p>각 로드밸런서가 지원하는 기능이 궁금하다면 <a href="https://aws.amazon.com/ko/elasticloadbalancing/features/">Elastic Load Balancing 기능</a>을 참고하세요. 로드밸런서가 트래픽을 처리하는 리스너와 프로세스를 설정할 수 있지만 여기서는 넘어가도록 하겠습니다.</p>
<h4 id="보안"><a href="#보안" class="headerlink" title="보안"></a>보안</h4><p>보안 옵션을 편집하여 EC2 인스턴스에 접근할 수 있는 권한을 설정할 수 있습니다. 키 페어를 지정하면 EC2 콘솔을 통해 연결할 수 있습니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-15.png"></p>
<h4 id="네트워크"><a href="#네트워크" class="headerlink" title="네트워크"></a>네트워크</h4><p>네트워크 옵션을 편집하여 VPC를 선택하고 로드밸런서와 인스턴스가 사용할 서브넷 대역을 설정할 수 있습니다. </p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-16.png"></p>
<p>이제 옵션 구성이 끝났으므로 환경 생성 버튼을 클릭하여 Elastic Beanstalk이 환경을 구성하는 것을 기다립니다. Elastic Beanstalk가 생성한 환경의 상태를 확인하고 애플리케이션으로 트래픽이 처리되는지를 확인하면 됩니다.</p>
<p>Elastic Beanstalk이 환경을 생성하는 것을 기다렸으나 제가 실수로 인스턴스 서브넷을 잘못 지정하여 인스턴스가 생성되지 못하였으나 Elastic Beanstalk는 환경 생성을 위해 상태를 계속 확인하고 기다리는 무한 루프 증상에 빠져버렸습니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-17.png"></p>
<p>인스턴스 서브넷을 올바르게 지정하기 위해서 환경 구성 페이지로 가보았지만 Elastic Beanstalk는 환경에 대한 이벤트를 수행하고 있어 어떠한 작업도 진행할 수 없습니다.</p>
<blockquote>
<p>이처럼 환경에 대한 작업이 수행되고 있을때는 어떠한 요청도 수행할 수 없는 단점이…</p>
</blockquote>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-18.png" alt="비활성화된 환경 작업"></p>
<h4 id="제대로-생성되지-않는-Beanstalk-환경-삭제하기"><a href="#제대로-생성되지-않는-Beanstalk-환경-삭제하기" class="headerlink" title="제대로 생성되지 않는 Beanstalk 환경 삭제하기"></a>제대로 생성되지 않는 Beanstalk 환경 삭제하기</h4><p>Elastic Beanstalk 서비스에서는 위 환경 생성 작업을 중지할 수 있는 방법이 없습니다. 다만, AWS 서비스 중 CloudFormation을 검색하여 들어가보면 Elastic Beanstalk 환경을 구성하는 스택을 찾을 수 있고 <code>CREATE_IN_PROGRESS</code> 상태에 머물러 있는 것을 확인할 수 있습니다. 이 스택을 선택하여 삭제하면 됩니다.</p>
<blockquote>
<p>Java SE 플랫폼 환경을 CloudFormation로 정의해서 구성하는군요?</p>
</blockquote>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-19.png"></p>
<p>Beanstalk 환경을 생성하는 스택이 삭제되어 Beanstalk 서비스로 다시 가보면 생성할 때 오류가 발생했던 환경이 삭제되고 있음을 확인할 수 있습니다. 다행입니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-20.png"></p>
<blockquote>
<p>단, 삭제된 환경 이름을 다시 사용하고 싶은 경우 1시간동안 기다려야해요…</p>
</blockquote>
<p>환경을 정상적으로 구성한 경우 다음과 같이 배포가 완료되었음을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-21.png"></p>
<blockquote>
<p>휴…</p>
</blockquote>
<h2 id="플랫폼-확장-구성"><a href="#플랫폼-확장-구성" class="headerlink" title="플랫폼 확장 구성"></a>플랫폼 확장 구성</h2><p>Elastic Beanstalk은 애플리케이션 소스 번들에 포함된 구성 및 플랫폼 파일을 통해 환경에 대한 구성을 확장하는 것을 지원합니다. 구성 파일은 <strong>.ebextensions</strong> 폴더, 플랫폼 파일은 <strong>.platform</strong> 폴더에 위치하게 됩니다. 저는 인프라에 대한 튜닝 방법에 대해서는 잘 모르기 때문에 인터넷에 공유된 내용을 소개하도록 하겠습니다.</p>
<h3 id="EC2-인스턴스-타임존-변경하기"><a href="#EC2-인스턴스-타임존-변경하기" class="headerlink" title="EC2 인스턴스 타임존 변경하기"></a>EC2 인스턴스 타임존 변경하기</h3><p>AWS의 <a href="https://github.com/awsdocs/elastic-beanstalk-samples/tree/main/configuration-files">elastic-beanstalk-samples/configuration-files</a>에는 EC2 인스턴스의 타임존을 변경할 수 있는 구성 파일 예제(timezone-linux.config)가 있습니다.</p>
<figure class="highlight plaintext"><figcaption><span>.ebextensions/00-timezone-linux.config</span></figcaption><table><tr><td class="code"><pre><span class="line">option_settings:</span><br><span class="line">  - namespace: aws:elasticbeanstalk:application:environment</span><br><span class="line">    option_name: TZ</span><br><span class="line">    value: &quot;Asia/Seoul&quot;</span><br><span class="line"></span><br><span class="line">files:</span><br><span class="line">  &quot;/tmp/set_timezone.sh&quot;:</span><br><span class="line">    mode: &quot;000755&quot;</span><br><span class="line">    owner: root</span><br><span class="line">    group: root</span><br><span class="line">    content: |</span><br><span class="line">      #!/bin/bash</span><br><span class="line">      NEWTIMEZONE=&quot;$(/opt/elasticbeanstalk/bin/get-config environment -k TZ)&quot;</span><br><span class="line">      if [ -z $NEWTIMEZONE ] ; then</span><br><span class="line">          echo &quot;TZ&quot; environment property not set</span><br><span class="line">          exit 1</span><br><span class="line">      fi</span><br><span class="line">      if [ ! -f /usr/share/zoneinfo/$NEWTIMEZONE ] ; then</span><br><span class="line">          echo /usr/share/zoneinfo/$NEWTIMEZONE does not exist</span><br><span class="line">          exit 1</span><br><span class="line">      fi</span><br><span class="line">      echo &#x27;ZONE=&quot;&#x27;$NEWTIMEZONE&#x27;&quot;&#x27; &gt; /etc/sysconfig/clock</span><br><span class="line">      echo &#x27;UTC=true&#x27; &gt;&gt; /etc/sysconfig/clock</span><br><span class="line">      ln -f -s /usr/share/zoneinfo/$NEWTIMEZONE /etc/localtime</span><br><span class="line"></span><br><span class="line">commands:</span><br><span class="line">  00-custom-timezone:</span><br><span class="line">    command: /tmp/set_timezone.sh</span><br></pre></td></tr></table></figure>

<p>기존 예제와 다르게 ntpdate로 NTP 서버 동기화 명령어를 수행하지 않고 <a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/set-time.html">Linux 인스턴스의 시간 설정</a>에 따라 Amazon Time Sync Service와 동기화되는 시간을 그대로 사용하겠습니다.</p>
<p><img data-src="/images/posts/beanstalk-java-se-platform/beanstalk-environment-22.png" alt="TZ 환경속성"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@ip-10-1-0-52 ~]<span class="comment"># date</span></span><br><span class="line">Sun Mar  7 13:58:57 KST 2021</span><br></pre></td></tr></table></figure>

<blockquote>
<p>명령어가 수행되어 한국 시간으로 표시된다.</p>
</blockquote>
<h3 id="Node-Exporter-에이전트-설치"><a href="#Node-Exporter-에이전트-설치" class="headerlink" title="Node Exporter 에이전트 설치"></a>Node Exporter 에이전트 설치</h3><p>OKKY에서 운영회원으로 활동중이신 창천향로님의 <a href="https://github.com/jojoldu/aws-beanstalk-tunning">AWS Beanstalk 성능 튜닝 시리즈</a>에서처럼 애플리케이션 성능 모니터링을 위한 APM 에이전트를 설치할 수도 있습니다. 저는 프로메테우스로 EC2 인스턴스에 대한 매트릭을 수집할 수 있도록 Beanstalk로 생성되는 EC2 인스턴스에 Node Exporter를 설치하고 실행하도록 확장 구성을 진행해보겠습니다.</p>
<p>먼저 Nginx 프록시 구성에 Node Exporter에 대한 프록시 구성 파일을 추가합니다.</p>
<figure class="highlight plaintext"><figcaption><span>.platform/nginx/conf.d/elasticbeanstalk/01_node_exporter.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">location /metrics &#123;</span><br><span class="line">    proxy_pass          http://127.0.0.1:9100/metrics;</span><br><span class="line">    proxy_http_version  1.1;</span><br><span class="line"></span><br><span class="line">    proxy_set_header    Connection          $connection_upgrade;</span><br><span class="line">    proxy_set_header    Upgrade             $http_upgrade;</span><br><span class="line">    proxy_set_header    Host                $host;</span><br><span class="line">    proxy_set_header    X-Real-IP           $remote_addr;</span><br><span class="line">    proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>역방향 프록시 구성을 통해 <code>/metrics</code>에 대한 트래픽을 Node Exporter로 라우팅할 수 있게 됩니다. 그럼 이제 Node Exporter를 설치하고 실행하는 구성 파일을 만듭니다.</p>
<figure class="highlight plaintext"><figcaption><span>.ebextensions/99-install-node-exporter.config</span></figcaption><table><tr><td class="code"><pre><span class="line">commands:</span><br><span class="line">  command block:</span><br><span class="line">    cwd: /home/webapp</span><br><span class="line">    command: |</span><br><span class="line">      curl -L https://github.com/prometheus/node_exporter/releases/download/v1.1.2/node_exporter-1.1.2.linux-amd64.tar.gz | tar zxv</span><br><span class="line">      cd node_exporter-1.1.2.linux-amd64</span><br><span class="line">      nohup ./node_exporter &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>여러가지 명령어를 하나로 합칠 수 있는 <code>command block</code>을 사용했으며 Node Exporter를 백그라운드로 실행하도록 하였습니다. 이제 이 파일들을 소스 번들에 포함하여 환경에 배포하면 다음과 같이 EC2 인스턴스에 대한 지표를 수집할 수 있게 됩니다.</p>
<h3 id="Beanstalk-배포-프로세스-확인"><a href="#Beanstalk-배포-프로세스-확인" class="headerlink" title="Beanstalk 배포 프로세스 확인"></a>Beanstalk 배포 프로세스 확인</h3><p>Elastic Beanstalk로 애플리케이션을 배포하기까지 문제가 발생했을때 어떤 부분을 체크해야하는지 알아보도록 하죠. </p>
<h4 id="로그"><a href="#로그" class="headerlink" title="로그"></a>로그</h4><p>가장 먼저 확인해야될 부분은 로그입니다.</p>
<figure class="highlight sh"><figcaption><span>/var/log</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@ip-10-1-0-52 <span class="built_in">log</span>]<span class="comment"># ll -h</span></span><br><span class="line">total 736K</span><br><span class="line">drwx------ 3 root    root      17 Mar  7 11:58 amazon</span><br><span class="line">-rw------- 1 root    root    8.3K Mar  7 11:58 boot.log</span><br><span class="line">-rw------- 1 root    utmp     15K Mar  7 13:36 btmp</span><br><span class="line">-rw-r--r-- 1 root    root    6.9K Mar  7 14:45 cfn-hup.log</span><br><span class="line">-rw-r--r-- 1 root    root     23K Mar  7 14:04 cfn-init-cmd.log</span><br><span class="line">-rw-r--r-- 1 root    root     14K Mar  7 14:04 cfn-init.log</span><br><span class="line">-rw-r--r-- 1 root    root     39K Mar  7 14:04 cfn-wire.log</span><br><span class="line">drwxr-xr-x 2 chrony  chrony     6 Mar  7 11:58 chrony</span><br><span class="line">-rw-r--r-- 1 root    root     93K Mar  7 11:58 cloud-init.log</span><br><span class="line">-rw-r--r-- 1 root    root    2.5K Mar  7 11:58 cloud-init-output.log</span><br><span class="line">-rw------- 1 root    root    9.4K Mar  7 14:40 cron</span><br><span class="line">-rw-r--r-- 1 root    root     27K Mar  7 11:58 dmesg</span><br><span class="line">-rw-r--r-- 1 root    root       0 Mar  7 11:58 eb-cfn-init-call.log</span><br><span class="line">-rw-r--r-- 1 root    root     41K Mar  7 11:58 eb-cfn-init.log</span><br><span class="line">-rw-r--r-- 1 root    root    137K Mar  7 14:04 eb-engine.log</span><br><span class="line">-rw-r--r-- 1 root    root    1.3K Mar  7 14:30 eb-publish.log</span><br><span class="line">-rw-r--r-- 1 root    root     455 Mar  7 12:30 eb-tools.log</span><br><span class="line">drwxr-xr-x 3 healthd healthd   39 Mar  7 12:00 healthd</span><br><span class="line">-rw------- 1 root    root     204 Mar  7 11:58 maillog</span><br><span class="line">-rw------- 1 root    root    205K Mar  7 14:47 messages</span><br><span class="line">drwxr-xr-x 4 nginx   nginx     71 Mar  7 12:45 nginx</span><br><span class="line">drwxr-xr-x 2 root    root       6 Mar  7 11:58 rotated</span><br><span class="line">drwxr-xr-x 2 root    root      18 Mar  7 11:58 sa</span><br><span class="line">-rw------- 1 root    root     41K Mar  7 14:32 secure</span><br><span class="line">-rw------- 1 root    root     21K Mar  7 14:33 web.stdout.log</span><br><span class="line">-rw-rw-r-- 1 root    utmp    7.9K Mar  7 14:32 wtmp</span><br><span class="line">drwxr-xr-x 2 xray    xray       6 Feb 25 22:54 xray</span><br></pre></td></tr></table></figure>

<p>로그 파일들은 <strong>/var/log</strong> 폴더에 위치하게 되는데 주로 확인하는 로그는 <strong>eb-engine.log</strong> 와 <strong>web.stdout.log</strong> 입니다. </p>
<ul>
<li>eb-engine.log: Beanstalk 프로세스 로그</li>
<li>web.stdout.log: 현재 실행되고 있는 애플리케이션의 로그</li>
<li>cfn-init-cmd.log: .eb-extensions 구성 파일에 정의한 명령어를 수행한 로그</li>
</ul>
<h4 id="소스-번들-파일"><a href="#소스-번들-파일" class="headerlink" title="소스 번들 파일"></a>소스 번들 파일</h4><p>업로드된 소스 번들에 포함된 파일들은 Elastic Beanstalk에 의해서 다양한 위치로 복사됩니다. </p>
<p>먼저, 현재 배포되고 있는 애플리케이션에 대한 소스 번들 파일과 환경 속성이 정의된 파일은 /opt/elasticbeanstalk/deployment에서 찾을 수 있습니다.</p>
<figure class="highlight sh"><figcaption><span>/opt/elasticbeanstalk/deployment</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@ip-10-1-0-52 deployment]<span class="comment"># ll -h</span></span><br><span class="line">total 18M</span><br><span class="line">-rw-r--r-- 1 root root  18M Mar  7 14:04 app_source_bundle</span><br><span class="line">-rw-r--r-- 1 root root   92 Mar  7 14:04 app_version_manifest.json</span><br><span class="line">-rw-r--r-- 1 root root 4.0K Mar  7 14:04 cfn-metadata-cache.json</span><br><span class="line">-r-------- 1 root root  211 Mar  7 14:04 env</span><br></pre></td></tr></table></figure>

<p>그리고 소스 번들(app_source_bundle)에 포함된 WAR 파일과 Procfile은 /var/app/current에 복사되어 실행합니다. 현재 배포되고 있는 애플리케이션이 제대로된 버전으로 실행되고 있는지 파악할 수 있겠습니다.</p>
<figure class="highlight sh"><figcaption><span>/var/app/current</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@ip-10-1-0-52 current]<span class="comment"># ll -h</span></span><br><span class="line">total 20M</span><br><span class="line">-rw-r--r-- 1 webapp webapp 20M Mar  7 14:02 demo-1.0.0.war</span><br><span class="line">-rw-r--r-- 1 webapp webapp  36 Mar  7 14:02 Procfile</span><br></pre></td></tr></table></figure>

<p>플랫폼(.platform)에 추가된 프록시 구성파일은 해당 프록시 하위로 복사됩니다. 예를 들어, 앞서 작성해본 01_node_exporter.conf 프록시 구성 파일은 /etc/nginx/conf.d/elasticbeanstalk에 복사됩니다.</p>
<figure class="highlight sh"><figcaption><span>/etc/nginx/conf.d/elasticbeanstalk</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@ip-10-1-0-52 elasticbeanstalk]<span class="comment"># ll -h</span></span><br><span class="line">total 12K</span><br><span class="line">-rw-r--r-- 1 root   root   397 Mar  7 14:04 00_application.conf</span><br><span class="line">-rw-r--r-- 1 webapp webapp 420 Mar  7 00:05 01_node_exporter.conf</span><br><span class="line">-rw-r--r-- 1 root   root   215 Mar  7 14:04 healthd.conf</span><br></pre></td></tr></table></figure>

<p>/etc/nginx/conf.d/elasticbeanstalk 폴더에는 기본으로 제공되는 프록시 구성 파일과 함께 소스 번들에 포함된 프록시 구성 파일이 존재하는 것을 확인할 수 있습니다.</p>
<h2 id="끝마치며"><a href="#끝마치며" class="headerlink" title="끝마치며"></a>끝마치며</h2><p>실제로 실무에서 Elastic Beanstalk로 애플리케이션을 배포하는 것은 다양한 부분에서 검토를 진행해야합니다. 개발된 애플리케이션이 요구하는 최소 환경 사양에 따라 인스턴스 유형을 설정해야하며 서비스 구조에 따라 유연하게 트래픽을 처리할 수 있는 ALB를 적용할 지 빠른 트래픽 처리를 위해 NLB로 로드 밸런싱을 단순화 해야할지를 정해야할 수 있습니다. </p>
<p>Elastic Beanstalk로 애플리케이션을 배포하는 것이 쉽다는 장점은 있지만 <strong>문제가 발생했을때 해결하는 것이 쉽지 않다는 단점</strong> 이 분명히 존재합니다. 실제로 최근에 애플리케이션을 배포하는 과정에서 많은 변경사항들로 인하여 배포 전환이 용이하지 않아 별도로 환경을 구성하고 트래픽을 전환하는 과정을 수행하기도 했습니다. 실무에서 예기치 못하게 발생하는 문제들로 인하여 쉽게 배포되겠지라는 생각과 달리 배포가 쉽지 않아 작성해보았습니다. 이상으로 AWS Elastic Beanstalk Java SE 플랫폼 환경으로 애플리케이션 배포하기를 마치겠습니다.</p>
<p>감사합니다.</p>
]]></content>
      <tags>
        <tag>AWS</tag>
        <tag>Beanstalk</tag>
        <tag>Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>쿠버네티스 클러스터 구성하기</title>
    <url>/setup-kubernetes-cluster/</url>
    <content><![CDATA[<p>안녕하세요 Mambo 입니다.</p>
<p>이번 글의 주제는 <strong>쿠버네티스 클러스터 구성하기</strong>입니다. IT 인프라에 대한 전문 인력이 아닌 일반 개발자가 컨테이너 환경을 위한 쿠버네티스 클러스터를 이해하고 구성하기까지는 생각보다 많은 시간이 소요되는 것 같습니다. 단순히 도커를 사용하여 컨테이너를 실행하는 것은 어렵지 않아서 도커 컴포즈 문서를 정의해서 여러가지 인스턴스를 별다른 설정없이 간단하게 실행해왔습니다. 하지만, 애플리케이션을 배포하고 운영하기 위하여 컨테이너 인프라 환경을 쿠버네티스 클러스터로 구성하는 것은 IT 인프라에 대한 전문 지식이 필요합니다.</p>
<p>현재 다니고 있는 회사의 소속팀에서는 애플리케이션을 아마존 웹 서비스의 빈스톡(Beanstalk)을 사용하여 배포하고 운영하기 때문에 컨테이너 환경의 쿠버네티스 클러스터에 대한 학습이 필요하진 않았습니다.</p>
<blockquote>
<p>물론, 쿠버네티스 클러스터 도입을 시도하긴 했습니다만… 현재 애플리케이션 규모 상 배보다 배꼽이 더 크다는 결과를 가진다고 판단하여 도입을 취소했습니다.</p>
</blockquote>
<p>그러나 2021년 클라우드 플래그십 프로젝트 중 에너지 분야에 참여함으로써 현재 운영중인 애플리케이션을 클라우드 환경에서 컨테이너 환경으로 배포하고 운영하기 위하여 모놀리식 아키텍처로 개발된 애플리케이션의 일정 부분을 마이크로서비스 아키텍처로 변경하여 기능적으로 분리하는 작업을 진행중입니다. 이렇게 마이크로서비스 아키텍처로 분리되는 애플리케이션들은 나무기술의 <strong>칵테일 클라우드</strong>라고하는 PaaS를 통해 배포되고 운영될 예정입니다.</p>
<p>쿠버네티스 클러스터를 직접 구성하여 운영 및 관리를 수행하는 것은 아니지만 쿠버네티스 클러스터 기반의 컨테이너 인프라 환경을 이해하기 위해 쿠버네티스 클러스터를 직접 구성해보고 간단한 애플리케이션을 배포해보는 것을 학습하고 이 글을 통해 공유하고자합니다.</p>
<h2 id="쿠버네티스-클러스터"><a href="#쿠버네티스-클러스터" class="headerlink" title="쿠버네티스 클러스터"></a>쿠버네티스 클러스터</h2><p>쿠버네티스는 분산형 코디네이터인 주키퍼처럼 다수의 호스트가 서로 통신하여 클러스터를 구성하게되며 컨트롤 플레인 노드의 API 서버가 동작하게 되는 마스터 노드와 컨테이너를 실행하는 환경이 되는 워커 노드로 구분됩니다. 우리는 워커 노드와는 통신할 필요가 없으며 마스터 노드의 API 서버와 통신하여 클러스터를 제어하고 애플리케이션을 배포하게됩니다.</p>
<h3 id="클러스터-구성의-어려움"><a href="#클러스터-구성의-어려움" class="headerlink" title="클러스터 구성의 어려움"></a>클러스터 구성의 어려움</h3><p>쿠버네티스 클러스터를 구성하는게 어려운 이유는 IT 인프라 지식 뿐만 아니라 클러스터 구성을 위해 여러가지 오픈소스 기술이 사용된다는 점입니다. 쿠버네티스 클러스터 구성에 대한 서비스를 PaaS로 제공하는 <a href="https://paas-ta.kr/intro/guideInstall">파스-타(PaaS-TA)</a> 또는 <a href="https://www.cocktailcloud.io/main.do">칵테일 클라우드</a>도 <strong>kubespray, istio</strong> 등 여러가지 오픈소스를 결합한 솔루션을 만들어 제공하는 것입니다. 또한, 쿠버네티스 클러스터 운영 관리의 어려움으로 인하여 쿠버네티스 클러스터를 쉽게 구성하고 관리할 수 있는 AWS의 <a href="https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html">Amazon EKS</a> 또는 구글 클라우드 플랫폼의 GKE와 같이 클라우드 서비스에서 쉽게 쿠버네티스 클러스터를 구성할 수 있는 서비스를 제공하는 이유이기도 합니다.</p>
<h3 id="쿠버네티스-클러스터-배포-도구"><a href="#쿠버네티스-클러스터-배포-도구" class="headerlink" title="쿠버네티스 클러스터 배포 도구"></a>쿠버네티스 클러스터 배포 도구</h3><p>쿠버네티스 클러스터를 구성할 수 있는 도구는 <strong>kubeadm, kops, kubespray</strong> 뿐만 아니라 IoT를 목적으로 경량화된 클러스터 구성을 목적으로하는 <a href="https://k3s.io/">k3s</a>, <a href="https://microk8s.io/">MicroK8s</a>등 여러가지 오픈소스가 존재합니다. 저는 쿠버네티스 공식 문서에서도 가이드를 제공하고 온-프레미스 환경에서 일반적으로 많이 사용될 수 있는 기본적인 배포 도구인 <code>kubeadm</code>을 사용하여 쿠버네티스 클러스터를 구성하겠습니다.</p>
<blockquote>
<p>본 글에서는 쿠버네티스 클러스터를 데비안 계열의 배포판인 우분투 리눅스를 사용합니다.</p>
</blockquote>
<figure class="highlight sh"><figcaption><span>우분투 kubeadm 패키지 설치</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y apt-transport-https ca-certificates curl</span><br><span class="line"></span><br><span class="line">sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot;</span> | sudo tee /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>

<p>위 명령어에 의해 설치된 패키지는 다음의 역할을 수행하게 되며 클러스터를 구성하는 모든 호스트에 설치해야합니다.</p>
<table>
<thead>
<tr>
<th>패키지</th>
<th>용도</th>
</tr>
</thead>
<tbody><tr>
<td>kubeadm</td>
<td>쿠버네티스 클러스터 배포</td>
</tr>
<tr>
<td>kubelet</td>
<td>컨트롤 플레인 노드와 통신하여 컨테이너가 파드에 실행될 수 있도록 도와주는 에이전트</td>
</tr>
<tr>
<td>kubectl</td>
<td>쿠버네티스 클러스터에 명령을 내리기 위해 사용하는 CLI</td>
</tr>
</tbody></table>
<blockquote>
<p>본 글에서는 최신 버전의 <strong>쿠버네티스 클러스터 1.21+</strong> 를 사용합니다.<br>쿠버네티스 클러스터를 안정적으로 유지하기 위하여 주기적으로 쿠버네티스 클러스터의 버전을 업그레이드하는 것을 권장한다고 합니다.</p>
</blockquote>
<h3 id="컨테이너-인프라-환경의-가용성"><a href="#컨테이너-인프라-환경의-가용성" class="headerlink" title="컨테이너 인프라 환경의 가용성"></a>컨테이너 인프라 환경의 가용성</h3><p>쿠버네티스 클러스터 구성 가이드에 따르면 클러스터를 구성하게 되는 모든 호스트가 컨테이너 인프라 환경을 구성할 수 있는지 가용성을 확인해야합니다. 따라서, 이미 사용하고 있는 호스트 보다는 쿠버네티스 클러스터를 구성을 위한 별도의 호스트를 사용하는게 좋습니다.</p>
<h4 id="메모리-스왑-기능-비활성화"><a href="#메모리-스왑-기능-비활성화" class="headerlink" title="메모리 스왑 기능 비활성화"></a>메모리 스왑 기능 비활성화</h4><p><a href="https://github.com/kubernetes/enhancements/issues/2400">Node swap support</a>와 같이 쿠버네티스 클러스터에서 스왑 기능을 활성화하기 위한 작업을 진행중이지만 현재로선 <strong>kubelet</strong>이 정상적으로 동작하기 위해서는 반드시 우분투 리눅스의 메모리 스왑 기능을 비활성화 해야합니다.</p>
<figure class="highlight sh"><figcaption><span>우분투 메모리 스왑 비활성화</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo swapoff -a &amp;&amp; sudo sed -i <span class="string">&#x27;/ swap / s/^\(.*\)$/#\1/g&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure>

<h4 id="클러스터-노드의-고유-주소-확인"><a href="#클러스터-노드의-고유-주소-확인" class="headerlink" title="클러스터 노드의 고유 주소 확인"></a>클러스터 노드의 고유 주소 확인</h4><p>쿠버네티스 클러스터를 구성하는 호스트들이 서로 통신할 수 있도록 네트워크 환경에서 고유한 주소를 가지고 있는지 확인해야합니다. 쿠버네티스 클러스터에서는 각 노드를 <strong>호스트의 MAC 주소</strong> 및 <strong>product_uuid</strong>를 기준으로 구분한다고 합니다.</p>
<figure class="highlight sh"><figcaption><span>MAC 주소 및 product_uuid 조회</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo apt install net-tools</span><br><span class="line">sudo ifconfig -a</span><br><span class="line">sudo cat /sys/class/dmi/id/product_uuid</span><br></pre></td></tr></table></figure>

<p>그리고 쿠버네티스 클러스터를 구성하는 호스트의 역할에 맞게 사용해야될 포트를 점유하고 있는지 확인해야합니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/setup-kubernetes-cluster-01.png"></p>
<h4 id="컨테이너-런타임-선택하기"><a href="#컨테이너-런타임-선택하기" class="headerlink" title="컨테이너 런타임 선택하기"></a>컨테이너 런타임 선택하기</h4><p>쿠버네티스 클러스터에서 파드 안에 컨테이너를 실행하기 위해 사용하게 될 컨테이너 런타임을 선택하고 설치해야합니다. 쿠버네티스 클러스터를 구성하는 많은 글에서 도커를 컨테이너 런타임으로 사용하는 것으로 소개하고있지만 앞으로 최신 쿠버네티스 클러스터 버전에서는 <a href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/">컨테이너 런타임 인터페이스를 준수하지 않는 도커</a>를 컨테이너 런타임으로 지원하지 않을 예정입니다. 따라서, 저는 <a href="https://cri-o.io/">CRI-O</a>를 컨테이너 런타임으로 선택하고 설치하겠습니다.</p>
<p>CRI-O를 설치하기 전에 우분투의 iptables가 브릿지된 트래픽을 바라보도록 설정해야합니다.</p>
<figure class="highlight sh"><figcaption><span>오버레이 네트워크 및 iptables 브릿지 트래픽 활성화</span></figcaption><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/crio.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>

<p>위 작업이 완료되었다면 다음의 명령어로 CRI-O 관련 패키지를 설치합니다.</p>
<figure class="highlight sh"><figcaption><span>CRI-O 관련 패키지 설치</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /&quot;</span> | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/1.21/xUbuntu_20.04/ /&quot;</span> | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:1.21.list</span><br><span class="line"></span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:1.21/xUbuntu_20.04/Release.key | sudo apt-key add -</span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/Release.key | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y cri-o cri-o-runc</span><br><span class="line">sudo apt-mark hold cri-o cri-o-runc</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> crio --now</span><br></pre></td></tr></table></figure>

<h4 id="파드-네트워크-플러그인-결정하기"><a href="#파드-네트워크-플러그인-결정하기" class="headerlink" title="파드 네트워크 플러그인 결정하기"></a>파드 네트워크 플러그인 결정하기</h4><p>쿠버네티스 클러스터에 실행되는 파드에서 컨테이너 간 통신을 위해서 <a href="https://github.com/containernetworking/cni">컨테이너 네트워크 인터페이스(CNI)</a>를 사용하게 됩니다. 다양한 CNI 오픈소스 중에서 파드 네트워크 플러그인을 선택해야하며 파드 네트워크 플러그인에 따라 쿠버네티스 클러스터를 시작할 때 CIDR 블록을 지정해야할 수 있습니다. </p>
<p>예를 들어, <a href="https://github.com/flannel-io/flannel">플라넬(Flannel)</a>을 CNI로 사용하는 경우 쿠버네티스 클러스터 시작 시 <strong>10.244.0.0/16</strong>를 파드 네트워크 CIDR 블록으로 지정해야합니다.</p>
<figure class="highlight sh"><figcaption><span>플라넬을 파드 네트워크 플러그인으로 사용하는 클러스터 시작 예시</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo kubeadm init --pod-network-cidr=10.244.0.0/16</span><br><span class="line">sudo kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<h4 id="네트워크-정책-플러그인"><a href="#네트워크-정책-플러그인" class="headerlink" title="네트워크 정책 플러그인"></a>네트워크 정책 플러그인</h4><p>파드 네트워크 플러그인으로 결정한 <strong>플라넬</strong>이라는 CNI는 네트워크 정책 기능을 포함하고 있지 않는 순수하게 네트워크 통신을 목적으로 만들어진 오픈소스입니다. 만약, 우리의 쿠버네티스 클러스터의 파드에 대한 트래픽 제어를 위해서 인그레스 또는 이그레스와 같은 기능을 적용해야한다면 <strong>네트워크 정책</strong> 기능이 포함된 플러그인을 파드 네트워크 플러그인으로 사용해야합니다.</p>
<p>일반적으로 구현 방식의 차이가 있지만 다음과 같은 네트워크 정책을 포함하는 플러그인을 사용합니다.</p>
<ul>
<li><a href="https://github.com/antrea-io/antrea">Antrea</a></li>
<li><a href="https://github.com/projectcalico/calico">Calico</a></li>
<li><a href="https://github.com/weaveworks/weave">Weave Net</a></li>
<li><a href="https://docs.projectcalico.org/getting-started/kubernetes/flannel/flannel">Canal</a></li>
</ul>
<p>예를 들어, 플라넬을 CNI로 사용하고 싶다면 캘리코(Calico)를 네트워크 정책 공급자로 사용할 수 있는 <strong>카날(Canal)</strong> 을 선택하면 됩니다.</p>
<figure class="highlight sh"><figcaption><span>카날을 사용하는 클러스터 시작 예시</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo kubeadm init --pod-network-cidr=10.244.0.0/16</span><br><span class="line">sudo kubectl apply -f https://docs.projectcalico.org/manifests/canal.yaml</span><br></pre></td></tr></table></figure>

<blockquote>
<p>카날은 플라넬을 CNI로 사용하므로 플라넬의 파드 네트워크 CIDR 블록을 지정합니다.</p>
</blockquote>
<h3 id="쿠버네티스-클러스터-DNS-서버"><a href="#쿠버네티스-클러스터-DNS-서버" class="headerlink" title="쿠버네티스 클러스터 DNS 서버"></a>쿠버네티스 클러스터 DNS 서버</h3><p>쿠버네티스 클러스터에 서비스 디스커버리를 적용하기 위하여 DNS 서버를 설치해야합니다. 쿠버네티스 클러스터 1.11+ 부터는 <a href="https://github.com/kubernetes/dns">kube-dns</a> 보다는 <a href="https://coredns.io/">CoreDNS</a>을 권장하고 우리가 클러스터 시작 시 사용하게 될 kubeadm은 기본적으로 <strong>CoreDNS</strong>를 포함하고 있습니다. 기본적으로 포함되는 CoreDNS는 <strong>대기 상태</strong>에 있다가 우리가 쿠버네티스 클러스터에 파드 네트워크 플러그인을 설치하면 자동으로 실행됩니다.</p>
<h2 id="쿠버네티스-클러스터-시작하기"><a href="#쿠버네티스-클러스터-시작하기" class="headerlink" title="쿠버네티스 클러스터 시작하기"></a>쿠버네티스 클러스터 시작하기</h2><p>쿠버네티스 클러스터 구성을 위해 확인해야할 몇가지 항목에 대해서 알아보았습니다. 이제 저와 함께 쿠버네티스 클러스터를 구성할 호스트를 준비하고 쿠버네티스 배포 도구인 <strong>kubeadm</strong>을 사용하여 쿠버네티스 클러스터를 시작해보겠습니다.</p>
<p>먼저, 아마존 웹 서비스의 EC2 인스턴스를 <strong>우분투 20.04 LTS</strong> 로 시작하겠습니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/setup-kubernetes-cluster-02.png"></p>
<p>그리고 kubeadm는 클러스터 시작을 위해 <strong>CPU 2코어 이상, 메모리 2GB 이상</strong> 을 요구하므로 t2.medium 인스턴스를 선택했습니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/setup-kubernetes-cluster-03.png"></p>
<p>쿠버네티스 클러스터 구성을 위한 학습을 목적으로 하므로 <strong>마스터 노드와 함께 1개 이상의 워커 노드를 구성</strong>하기 위하여 <strong>최소 2개의 우분투 인스턴스</strong>를 준비합니다.</p>
<h3 id="클러스터-구성-호스트에-대한-사전-작업"><a href="#클러스터-구성-호스트에-대한-사전-작업" class="headerlink" title="클러스터 구성 호스트에 대한 사전 작업"></a>클러스터 구성 호스트에 대한 사전 작업</h3><p>우리가 준비한 우분투 인스턴스에 쿠버네티스 인프라 환경을 구성하기 위한 사전작업을 수행합니다.</p>
<figure class="highlight sh"><figcaption><span>메모리 스왑 기능 비활성화</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo swapoff -a &amp;&amp; sudo sed -i <span class="string">&#x27;/ swap / s/^\(.*\)$/#\1/g&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/crio.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><figcaption><span>CRI-O 컨테이너 런타임 설치하기</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /&quot;</span> | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/1.21/xUbuntu_20.04/ /&quot;</span> | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:1.21.list</span><br><span class="line"></span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:1.21/xUbuntu_20.04/Release.key | sudo apt-key add -</span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/Release.key | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y cri-o cri-o-runc</span><br><span class="line">sudo apt-mark hold cri-o cri-o-runc</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> crio --now</span><br></pre></td></tr></table></figure>

<h3 id="컨트롤-플레인-노드-초기화"><a href="#컨트롤-플레인-노드-초기화" class="headerlink" title="컨트롤 플레인 노드 초기화"></a>컨트롤 플레인 노드 초기화</h3><p>이제 쿠버네티스 클러스터를 시작하기 위해서 <strong>kubeadm init</strong> 명령어를 사용하여 <strong>컨트롤 플레인 노드를 초기화</strong> 합니다. 컨트롤 플레인 노드가 형성된 호스트를 <strong>마스터 노드</strong>라고 부르게 됩니다.</p>
<p>쿠버네티스 클러스터에서 파드 네트워크 플러그인을 플라넬을 사용할 예정이므로 컨트롤 플레인 노드 시작 시 <strong>파드 네트워크 CIDR 블록</strong>을 <code>10.244.0.0/16</code>으로 지정해야합니다.</p>
<figure class="highlight sh"><figcaption><span>컨트롤 플레인 노드를 초기화하여 클러스터 시작</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo kubeadm init --pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 172.31.11.193:6443 --token oov7g6.bi85jo3kv15oeryf \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:08874017445a8ddf06dde3e9e7be79097c470883f0384c046290e207ec3342bd</span><br></pre></td></tr></table></figure>

<p>컨트롤 플레인 노드가 성공적으로 초기화되었으니 파드 네트워크 플러그인으로 플라넬을 설치해야합니다. 플라넬을 설치하기 위해서는 쿠버네티스 클러스터를 제어하는데 사용하는 <strong>큐브컨트롤(kubectl)</strong> 에 클러스터 접근을 위한 설정을 진행해야합니다. 컨트롤 플레인 노드 초기화 시 출력된 다음의 명령어를 실행합니다.</p>
<figure class="highlight sh"><figcaption><span>큐브컨트롤에 클러스터 접근 설정</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<p>위 명령어를 수행하고 나면 큐브컨트롤이 <strong>$HOME/.kube</strong> 경로에 있는 클러스터 접근 구성파일이라고 하는 <code>kubeconfig</code>를 참조하여 클러스터에 접근하여 명령을 수행합니다. 클러스터 접근 구성파일에 대해서는 자세히 알아볼 필요가 없으므로 넘어가겠습니다.</p>
<p>쿠버네티스 클러스터에 실행된 모든 파드를 조회하기 위하여 다음의 명령어를 실행합니다.</p>
<figure class="highlight sh"><figcaption><span>클러스터의 모든 네임스페이스에 대한 파드 조회</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br><span class="line">...</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-558bd4d5db-b9t9v                   0/1     Pending   0          106s</span><br><span class="line">kube-system   coredns-558bd4d5db-bkhc4                   0/1     Pending   0          106s</span><br><span class="line">kube-system   etcd-ip-172-31-11-193                      1/1     Running   0          117s</span><br><span class="line">kube-system   kube-apiserver-ip-172-31-11-193            1/1     Running   0          117s</span><br><span class="line">kube-system   kube-controller-manager-ip-172-31-11-193   1/1     Running   0          2m4s</span><br><span class="line">kube-system   kube-proxy-gm8tr                           1/1     Running   0          106s</span><br><span class="line">kube-system   kube-scheduler-ip-172-31-11-193            1/1     Running   0          2m5s</span><br></pre></td></tr></table></figure>

<p>앞서 쿠버네티스 클러스터 DNS 서버 관련해서 CoreDNS는 파드 네트워크 플러그인이 설치되기까지 대기 상태에 있다고 하였습니다. 플라넬을 파드 네트워크 플러그인으로 설치하고나서 CoreDNS가 실행되는지 확인해보겠습니다.</p>
<h3 id="네트워크-플러그인-설치"><a href="#네트워크-플러그인-설치" class="headerlink" title="네트워크 플러그인 설치"></a>네트워크 플러그인 설치</h3><p>파드 네트워크 플러그인으로 플라넬을 사용하면서 네트워크 정책 기능을 추가하기 위해 네트워크 정책 플러그인으로 캘리코를 사용하는 카날(Canal)을 쿠버네티스 클러스터에 설치하겠습니다.</p>
<figure class="highlight sh"><figcaption><span>카날 네트워크 플러그인 설치</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/canal.yaml</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">kubectl get pods -A</span><br><span class="line">...</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   calico-kube-controllers-78d6f96c7b-ltz89   1/1     Running   0          22s</span><br><span class="line">kube-system   canal-2mmz5                                2/2     Running   0          23s</span><br><span class="line">kube-system   coredns-558bd4d5db-t4w4s                   1/1     Running   0          94s</span><br><span class="line">kube-system   coredns-558bd4d5db-wg7zg                   1/1     Running   0          94s</span><br><span class="line">kube-system   etcd-ip-172-31-11-193                      1/1     Running   0          102s</span><br><span class="line">kube-system   kube-apiserver-ip-172-31-11-193            1/1     Running   0          109s</span><br><span class="line">kube-system   kube-controller-manager-ip-172-31-11-193   1/1     Running   0          102s</span><br><span class="line">kube-system   kube-proxy-gmp4q                           1/1     Running   0          93s</span><br><span class="line">kube-system   kube-scheduler-ip-172-31-11-193            1/1     Running   0          102s</span><br></pre></td></tr></table></figure>

<p>카날을 설치하고나서 파드 조회 명령어를 실행하니 대기중이었던 <strong>CoreDNS</strong>가 실행되었음을 확인할 수 있습니다.</p>
<blockquote>
<p>눈치채신 분들도 계시겠지만 큐브컨트롤로 모든 네임스페이스에 대해서 조회하기 위해서 사용하는 <strong>–all-namespaces</strong> 옵션 대신에 <strong>-A</strong>를 대신 사용할 수 있습니다.<br>이렇게 큐브컨트롤을 사용할 때 긴 이름을 대신할 수 있는 축약어를 지원하니 여러가지 축약 형태를 찾아보세요.</p>
</blockquote>
<h3 id="쿠버네티스-클러스터-워커-노드-추가"><a href="#쿠버네티스-클러스터-워커-노드-추가" class="headerlink" title="쿠버네티스 클러스터 워커 노드 추가"></a>쿠버네티스 클러스터 워커 노드 추가</h3><p>앞선 작업까지 수행하면 쿠버네티스 클러스터 시작이 완료되었다고 볼 수 있습니다. 이제 쿠버네티스 클러스터 구성을 완료하기 위하여 클러스터가 파드에 컨테이너를 실행하는 환경이 되는 워커 노드를 참여시켜야합니다. 쿠버네티스 클러스터에 다른 호스트를 워커 노드로 참여시키기 위해서는 컨트롤 플레인 노드를 초기화하고 나서 출력되는 다음의 명령어를 워커 노드가 될 호스트에서 실행해야합니다.</p>
<blockquote>
<p>클러스터를 구성하는 모든 호스트에 kubectl, kubelet을 설치하는 것이 이러한 이유입니다.</p>
</blockquote>
<figure class="highlight sh"><figcaption><span>쿠버네티스 클러스터에 워커 노드 참여</span></figcaption><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.11.193:6443 --token oov7g6.bi85jo3kv15oeryf \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:08874017445a8ddf06dde3e9e7be79097c470883f0384c046290e207ec3342bd </span><br><span class="line">...</span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run <span class="string">&#x27;kubectl get nodes&#x27;</span> on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure>

<p>마지막 문장에 따라 컨트롤 플레인 노드가 있는 마스터 노드에서 <strong>kubectl get nodes</strong> 명령어를 실행해봅니다.</p>
<figure class="highlight sh"><figcaption><span>쿠버네티스 클러스터의 노드 조회</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get [nodes/node/no]</span></span><br><span class="line">kubectl get no</span><br><span class="line">...</span><br><span class="line">NAME               STATUS   ROLES                  AGE     VERSION</span><br><span class="line">ip-172-31-11-193   Ready    control-plane,master   3m18s   v1.21.3</span><br><span class="line">ip-172-31-41-106   Ready    &lt;none&gt;                 42s     v1.21.3</span><br></pre></td></tr></table></figure>

<p>저는 클러스터를 구성하는 노드를 조회하는 명령어를 축약 형태로 실행했습니다. 이렇게 큐브컨트롤로 명령어를 실행할 때 쿠버네티스 리소스를 <strong>복수형, 단수형, 축약형</strong>을 모두 사용할 수 있습니다. 이렇게 쿠버네티스 배포 도구로 클러스터를 시작하고 워커 노드를 참여시켜 쿠버네티스 클러스터 구성을 완료했습니다.</p>
<blockquote>
<p>위 명령어 수행결과에서 워커 노드에 ROLES가 없는 것이 문제가 안되지만 정확한 구분을 위해 worker를 추가하고 싶다면 다음의 명령어를 실행하시면 됩니다.</p>
</blockquote>
<figure class="highlight sh"><figcaption><span>워커 노드에 worker ROLE 레이블 추가</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl label node ip-172-31-41-106 node-role.kubernetes.io/worker=worker</span><br></pre></td></tr></table></figure>

<h2 id="쿠버네티스-클러스터-제어하기"><a href="#쿠버네티스-클러스터-제어하기" class="headerlink" title="쿠버네티스 클러스터 제어하기"></a>쿠버네티스 클러스터 제어하기</h2><p>쿠버네티스 클러스터를 제어하기 위해서는 마스터 노드인 호스트에 접속하여 큐브컨트롤으로 명령어를 실행해야합니다. 그러나, 반드시 쿠버네티스 클러스터 제어를 위해서 마스터 노드에서 수행할 필요는 없습니다. 그 이유는 <strong>큐브컨트롤(kubectl)</strong> 이 쿠버네티스 클러스터 접근을 위해서 <strong>클러스터 접근 구성 파일(kubeconfig)</strong> 을 참조해서 클러스터에 접근하기 때문입니다. </p>
<p>쿠버네티스 클러스터의 마스터 노드가 아닌 <strong>로컬 컴퓨터(외부 호스트)</strong> 에서 큐브컨트롤을 사용하여 쿠버네티스 클러스터에 명령어를 실행하기 위해서 <a href="https://kubernetes.io/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig">클러스터 접근 구성 파일을 정의</a>하고 <a href="https://kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-certs">쿠버네티스 클러스터에서 사용중인 인증서를 갱신</a>하는 작업을 수행해야합니다.</p>
<h3 id="외부-호스트를-위한-클러스터-접근-구성-파일-정의"><a href="#외부-호스트를-위한-클러스터-접근-구성-파일-정의" class="headerlink" title="외부 호스트를 위한 클러스터 접근 구성 파일 정의"></a>외부 호스트를 위한 클러스터 접근 구성 파일 정의</h3><p>먼저, 마스터 노드에서 사용중인 클러스터 접근 구성파일을 외부 호스트인 로컬 컴퓨터에 복사하여 로컬 컴퓨터에 설치된 큐브컨트롤로 쿠버네티스 클러스터에 접근할 수 있는지 확인합니다.</p>
<blockquote>
<p>마스터 노드인 호스트의 외부 아이피는 54.180.137.161 입니다.</p>
</blockquote>
<figure class="highlight ps"><figcaption><span>외부 호스트에서 클러스터 접근 구성파일 복사</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir .kube</span><br><span class="line">scp <span class="literal">-i</span> .\keypair\mambo.pem ubuntu@<span class="number">54.180</span>.<span class="number">137.161</span>:.kube/config .kube/config</span><br></pre></td></tr></table></figure>

<p>로컬 컴퓨터에서 큐브컨트롤이 참조하는 클러스터 접근 구성정보를 조회해보면 마스터 노드에서 사용하던 클러스터 접근 구성 파일이기 때문에 클러스터의 주소가 마스터 노드의 내부 아이피인 것을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/control-kubernetes-cluster-03.png" alt="클러스터 주소가 마스터 노드의 내부 아이피"></p>
<p>클러스터 주소를 외부 아이피로 변경하기 위해서 다음의 명령어를 수행합니다.</p>
<figure class="highlight ps"><figcaption><span>클러스터 접근 구성 파일의 클러스터 주소 변경</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl config -<span class="literal">-kubeconfig</span>=config <span class="built_in">set-cluster</span> kubernetes -<span class="literal">-server</span>=https://<span class="number">54.180</span>.<span class="number">137.161</span>:<span class="number">6443</span> </span><br></pre></td></tr></table></figure>

<p>다시 큐브컨트롤이 참조하는 클러스터 접근 구성 정보를 조회해보면 다음과 같이 클러스터 주소가 외부 아이피로 변경된 것을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/control-kubernetes-cluster-04.png" alt="외부 아이피로 변경된 클러스터 주소"></p>
<p>이제 로컬 컴퓨터에서 큐브컨트롤이 클러스터에 접근할 수 있게 접근 구성 파일을 정의했습니다. (수정이지만…?) 큐브컨트롤로 클러스터의 모든 네임스페이스에 대한 파드를 조회해봅니다.</p>
<figure class="highlight ps"><figcaption><span>외부 호스트에서 클러스터의 모든 네임스페이스에 대한 파드 조회</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl get po <span class="literal">-A</span></span><br><span class="line">...</span><br><span class="line">Unable to connect to the server: x509: certificate is valid <span class="keyword">for</span> <span class="number">10.96</span>.<span class="number">0.1</span>, <span class="number">172.31</span>.<span class="number">6.192</span>, not <span class="number">54.180</span>.<span class="number">137.16</span></span><br></pre></td></tr></table></figure>

<p>위와 같이 X509 인증서 관련 오류가 발생한 이유는 우리가 입력한 쿠버네티스 클러스터 주소인 54.180.137.161이 접근 구성 파일에 있는 인증서 정보에 포함되어있지 않기 때문입니다. 기본적으로 쿠버네티스 클러스터 시작 시 컨트롤 플레인 노드를 초기화할 때 API 서버에서 사용할 인증서를 생성하는 과정에서 내부 아이피만을 인증서에 포함시키기 때문입니다. </p>
<p>마스터 노드로 돌아가서 쿠버네티스 클러스터 시작 시 인증서에 외부아이피를 포함시키기 위해서 힘들게 구성하였던 클러스터를 초기화시키겠습니다.</p>
<figure class="highlight sh"><figcaption><span>쿠버네티스 클러스터 초기화</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo kubeadm reset</span><br><span class="line">rm <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 클러스터 시작 시 외부 아이피를 API 서버에 대한 인증서에 포함하도록 <strong>--apiserver-cert-extra-sans</strong> 파라미터 옵션을 추가합니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/control-kubernetes-cluster-05.png"></p>
<p>위와 같이 쿠버네티스 클러스터 시작 시 출력되는 정보를 통해 우리가 파라미터로 입력한 <strong>외부 아이피(54.180.137.161)가 인증서에 포함됨</strong> 을 확인할 수 있었습니다. 쿠버네티스 클러스터를 시작하여 컨트롤 플레인 노드가 초기화되었으면 kubeconfig 파일을 로컬 컴퓨터로 복사하고 큐브컨트롤으로 파드 조회를 시도해봅니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/control-kubernetes-cluster-06.png"></p>
<p>쿠버네티스 클러스터에서 인증서에 포함된 외부 아이피를 확인하여 클러스터 접근을 허용하여 모든 네임스페이스에 대한 파드가 조회되었습니다.</p>
<h3 id="외부-호스트를-위한-사용자-및-인증서-발행"><a href="#외부-호스트를-위한-사용자-및-인증서-발행" class="headerlink" title="외부 호스트를 위한 사용자 및 인증서 발행"></a>외부 호스트를 위한 사용자 및 인증서 발행</h3><p>앞서 확인한 내용은 클러스터 접근 구성파일을 통해 외부 호스트에서 클러스터에 접근할 수 있는 것입니다. 그런데 우리가 마스터 노드에서 사용하던 클러스터 접근 구성파일에는 쿠버네티스 클러스터를 제어하기 위한 kubernetes-admin 사용자의 인증정보가 포함되어있습니다. 쿠버네티스 클러스터 관리 담당자는 클러스터에 대한 모든 권한을 가지는 접근 구성파일을 내보내지않고 클러스터에 접근할 수 있으며 특정 네임스페이스 권한이 부여된 사용자를 만들고 쿠버네티스 클러스터의 루트 CA 인증서를 기반으로 사용자의 인증서를 발행하여 클러스터 접근 구성 파일을 정의할 수 있게 지원하는 게 좋습니다.</p>
<p>쿠버네티스 클러스터에는 사용자라는 오브젝트는 없지만 인증서에 포함되는 주체를 통해 그룹과 사용자 개념을 사용해서 인증을 수행합니다. 따라서, 우리는 쿠버네티스 클러스터의 루트 CA 인증서를 기반으로 하위 인증서 발행하고 하위 인증서에 포함된 주체에 대한 RBAC 기반의 Role을 쿠버네티스 클러스터에 생성해야합니다.</p>
<p>먼저, 루트 CA 인증서를 기반으로 하위 인증서를 발행하기 위하여 클라우드플레어에서 만든 cfssl 설치합니다.</p>
<figure class="highlight sh"><figcaption><span>마스터 노드에 cfssl 패키지 설치</span></figcaption><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl</span><br><span class="line">curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson</span><br><span class="line">curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo</span><br><span class="line"></span><br><span class="line">chmod +x cfssl* </span><br><span class="line">sudo mv cfssl* /usr/bin/</span><br></pre></td></tr></table></figure>

<p>cfssl이 설치되었으면 사용자 인증서가 발행될 폴더를 만들고나서 쿠버네티스 클러스터가 사용중인 루트 CA 인증서 파일을 복사합니다. 루트 CA 인증서 파일은 일반적으로 <strong>/etc/kubernetes/pki</strong> 폴더에 있습니다.</p>
<p>인증서 발행을 위해 다음의 명령어를 차례대로 실행합니다.</p>
<figure class="highlight sh"><figcaption><span>인증서 발행 폴더 이동 및 쿠버네티스 클러스터 루트 CA 인증서 복사</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir cert &amp;&amp; <span class="built_in">cd</span> cert</span><br><span class="line">sudo cp /etc/kubernetes/pki/ca* ./</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><figcaption><span>하위 인증서 발행 정보 및 서명 요청 정의</span></figcaption><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF | tee mambo-config.json</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;8760h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;mambo&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">          &quot;signing&quot;,</span></span><br><span class="line"><span class="string">          &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">          &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">          &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        &quot;expiry&quot;: &quot;8760h&quot;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | tee mambo-csr.json</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;mambo&quot;,</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;:[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;system:masters&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><figcaption><span>사용자 인증서 발행</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo cfssl gencert -ca=ca.crt -ca-key=ca.key -config=mambo-config.json -profile=mambo mambo-csr.json | cfssljson -bare mambo</span><br><span class="line"></span><br><span class="line">ll</span><br><span class="line">-rw-r--r-- 1 mambo mambo 1066 Jul 28 15:04 ca.crt</span><br><span class="line">-rw------- 1 root  root  1679 Jul 28 15:04 ca.key</span><br><span class="line">-rw-rw-r-- 1 mambo mambo  277 Jul 28 15:02 mambo-config.json</span><br><span class="line">-rw-r--r-- 1 mambo mambo  920 Jul 28 15:08 mambo.csr</span><br><span class="line">-rw-rw-r-- 1 mambo mambo  129 Jul 28 15:02 mambo-csr.json</span><br><span class="line">-rw------- 1 mambo mambo 1675 Jul 28 15:08 mambo-key.pem</span><br><span class="line">-rw-rw-r-- 1 mambo mambo 1204 Jul 28 15:08 mambo.pem</span><br></pre></td></tr></table></figure>

<p>이렇게 만들어진 인증서를 기반으로 큐브컨트롤을 사용하여 클러스터 접근 구성 파일(kubeconfig)를 정의합니다.</p>
<figure class="highlight sh"><figcaption><span>사용자 클러스터 접근 구성 파일 정의</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl config --kubeconfig=mambo-config set-cluster kubernetes --server=https://54.180.137.161:6443 --certificate-authority=ca.crt</span><br><span class="line">kubectl config --kubeconfig=mambo-config set-credentials mambo --client-certificate=mambo.pem --client-key=mambo-key.pem</span><br><span class="line">kubectl config --kubeconfig=mambo-config set-context kubernetes-master --cluster=kubernetes --user=mambo</span><br><span class="line">kubectl config --kubeconfig=mambo-config use-context kubernetes-master</span><br></pre></td></tr></table></figure>

<p>만들어진 클러스터 접근 구성 정보를 조회하고 파드를 조회합니다.</p>
<figure class="highlight sh"><figcaption><span>클러스터 접근 구성 정보 조회</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl config view --kubeconfig=mambo-config</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority: ca.crt</span><br><span class="line">    server: https://54.180.137.161:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: mambo</span><br><span class="line">  name: kubernetes-master</span><br><span class="line">current-context: kubernetes-master</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: mambo</span><br><span class="line">  user:</span><br><span class="line">    client-certificate: mambo.pem</span><br><span class="line">    client-key: mambo-key.pem</span><br></pre></td></tr></table></figure>

<p>우리는 mambo 사용자에 대한 Role을 쿠버네티스 클러스터에 생성하지 않았지만 파드가 조회가 가능한 이유는 인증서 발행 시 <strong>system:masters</strong> 라고 지정하였기 때문입니다. 쿠버네티스 클러스터에는 미리 정의된 <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles">Role</a>이 존재하는데 그 중에서 <code>system:masters</code>는 모든 권한을 가지는 사용자 그룹(cluster-admin)을 가리키게되어 mambo라는 사용자는 모든 권한을 보유한 것으로 처리된 것입니다.</p>
<blockquote>
<p>결국 mambo 라는 사용자는 모든 권한을 가지는 사용자 kubernetes-admin과 같습니다.</p>
</blockquote>
<p>우리는 모든 권한을 가지는 사용자가 아니라 특정 권한을 가지는 사용자를 만들고 인증해야하므로 기존에 만들었던 인증서를 삭제하고 특정 권한을 가지는 인증서를 다시 발행해야합니다. </p>
<figure class="highlight sh"><figcaption><span>인증서 서명 요청 파일 수정 및 인증서 재발행</span></figcaption><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF | tee mambo-csr.json</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;mambo&quot;,</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;:[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;admin:mambo&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo cfssl gencert -ca=ca.crt -ca-key=ca.key -config=mambo-config.json -profile=mambo mambo-csr.json | cfssljson -bare mambo</span><br></pre></td></tr></table></figure>

<p>이제 다시 큐브컨트롤을 사용하여 클러스터의 파드를 조회합니다.</p>
<figure class="highlight sh"><figcaption><span>클러스터 파드 조회</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl get po -n kube-system --kubeconfig=config</span><br><span class="line">Error from server (Forbidden): pods is forbidden: User <span class="string">&quot;mambo&quot;</span> cannot list resource <span class="string">&quot;pods&quot;</span> <span class="keyword">in</span> API group <span class="string">&quot;&quot;</span> <span class="keyword">in</span> the namespace <span class="string">&quot;kube-system&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>system:masters</strong>을 지정했던것과 다르게 mambo 사용자는 kube-system 네임스페이스에 대한 파드 조회를 수행할 수 없게되었습니다. 이것은 우리가 아직 쿠버네티스 클러스터에 mambo 사용자에 대한 Role을 생성하지 않았기 때문입니다. 이제 다음과 같이 쿠버네티스 클러스터에 Mambo 사용자가 파드 조회를 위한 권한을 가지도록 Role을 생성합니다. </p>
<figure class="highlight sh"><figcaption><span>사용자 Role 및 Rolebinding 생성</span></figcaption><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF | tee mambo-rbac.yaml</span></span><br><span class="line"><span class="string">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: Role</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  namespace: kube-system</span></span><br><span class="line"><span class="string">  name: mambo-rbac-role</span></span><br><span class="line"><span class="string">rules:</span></span><br><span class="line"><span class="string">- apiGroups: [&quot;&quot;]</span></span><br><span class="line"><span class="string">  resources: [&quot;pods&quot;]</span></span><br><span class="line"><span class="string">  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: RoleBinding</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  namespace: kube-system</span></span><br><span class="line"><span class="string">  name: mambo-rbac-rolebinding</span></span><br><span class="line"><span class="string">subjects:</span></span><br><span class="line"><span class="string">- kind: User</span></span><br><span class="line"><span class="string">  name: mambo</span></span><br><span class="line"><span class="string">  apiGroup: rbac.authorization.k8s.io</span></span><br><span class="line"><span class="string">roleRef:</span></span><br><span class="line"><span class="string">  kind: Role</span></span><br><span class="line"><span class="string">  name: mambo-rbac-role</span></span><br><span class="line"><span class="string">  apiGroup: rbac.authorization.k8s.io</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">kubectl create -f mambo-rbac.yaml</span><br><span class="line">role.rbac.authorization.k8s.io/mambo-rbac-role created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/mambo-rbac-rolebinding created</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><figcaption><span>클러스터 파드 조회</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl get po -n kube-system --kubeconfig=mambo-config</span><br><span class="line">...</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-558bd4d5db-kvfhl                  1/1     Running   0          4h33m</span><br><span class="line">coredns-558bd4d5db-z7kf7                  1/1     Running   0          4h33m</span><br><span class="line">etcd-ip-172-31-6-192                      1/1     Running   0          3h54m</span><br><span class="line">kube-apiserver-ip-172-31-6-192            1/1     Running   0          3h54m</span><br><span class="line">kube-controller-manager-ip-172-31-6-192   1/1     Running   0          3h54m</span><br><span class="line">kube-flannel-ds-dh2xp                     1/1     Running   0          4h23m</span><br><span class="line">kube-proxy-tbm76                          1/1     Running   0          4h33m</span><br><span class="line">kube-scheduler-ip-172-31-6-192            1/1     Running   0          3h54m</span><br></pre></td></tr></table></figure>

<p>신규 사용자에 대한 인증서를 발행하고 Role을 만들어 사용자에게 바인딩함으로써 쿠버네티스 클러스터에 동작중인 파드를 조회할 수 있게 되었습니다.</p>
<h2 id="쿠버네티스-클러스터-관리하기"><a href="#쿠버네티스-클러스터-관리하기" class="headerlink" title="쿠버네티스 클러스터 관리하기"></a>쿠버네티스 클러스터 관리하기</h2><p>쿠버네티스 클러스터 시작 시 발행되는 인증서는 기본적으로 1년동안 사용할 수 있게 만료일자가 설정됩니다. 따라서, 쿠버네티스 클러스터가 시작된 지 1년이 지나게되면 쿠버네티스 클러스터 동작이 정상적이지 않을 수 있습니다. 그래서 우리는 쿠버네티스 클러스터에서 사용중인 인증서가 만료되기전에 인증서를 갱신할 수 있어야합니다.</p>
<h3 id="클러스터-인증서-갱신하기"><a href="#클러스터-인증서-갱신하기" class="headerlink" title="클러스터 인증서 갱신하기"></a>클러스터 인증서 갱신하기</h3><p>앞서 우리는 클러스터 외부 호스트에서 접근할 수 있도록 쿠버네티스 클러스터 시작 시 외부 아이피를 파라미터 옵션으로 추가했습니다. 하지만, 쿠버네티스 클러스터를 운영하고 있는 도중에는 클러스터를 초기화하고 다시 시작할 수 없습니다. 그래서 쿠버네티스 클러스터에서 사용중인 인증서를 다시 발행하기 위해서는 <a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs">kubeadm init phase certs</a> 명령어를 사용해야합니다. </p>
<figure class="highlight sh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/kubernetes/pki</span><br><span class="line"><span class="comment"># 기존 인증서 삭제 또는 백업</span></span><br><span class="line">sudo cp apiserver.crt apiserver.crt.old</span><br><span class="line">sudo cp apiserver.key apiserver.key.old</span><br><span class="line">sudo rm apiserver.crt apiserver.key</span><br><span class="line"></span><br><span class="line">sudo kubeadm init phase certs apiserver --apiserver-advertise-address=172.31.6.192 --apiserver-cert-extra-sans=54.180.137.161</span><br><span class="line">[certs] Generating <span class="string">&quot;apiserver&quot;</span> certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed <span class="keyword">for</span> DNS names [ip-172-31-6-192 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 172.31.6.192 54.180.137.161]</span><br><span class="line"></span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 시작 시 수행하는 과정 중 일부를 수행하여 API 서버에 대한 인증서를 발행하면서 외부 아이피가 포함된 것을 확인할 수 있습니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/control-kubernetes-cluster-07.png"></p>
<p>위와 같이 외부 호스트인 로컬 컴퓨터에서도 클러스터에 접근할 수 있게 됩니다.</p>
<h3 id="클러스터-인증서-만료일자-조회하기"><a href="#클러스터-인증서-만료일자-조회하기" class="headerlink" title="클러스터 인증서 만료일자 조회하기"></a>클러스터 인증서 만료일자 조회하기</h3><p>쿠버네티스 클러스터에서 사용중인 인증서를 발행할 수 있는 방법을 알았지만 인증서가 언제 만료되는지도 알아야합니다. <strong>kubeadm certs check-expiration</strong> 명령어를 사용하면 쿠버네티스 클러스터에서 사용중인 인증서의 만료일자를 조회할 수 있습니다. </p>
<figure class="highlight sh"><figcaption><span>클러스터 인증서 만료일자 조회</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo kubeadm certs check-expiration</span><br><span class="line">[check-expiration] Reading configuration from the cluster...</span><br><span class="line">[check-expiration] FYI: You can look at this config file with <span class="string">&#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span></span><br><span class="line"></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Jul 28, 2022 11:17 UTC   364d                                    no</span><br><span class="line">apiserver                  Jul 28, 2022 11:17 UTC   364d            ca                      no</span><br><span class="line">apiserver-etcd-client      Jul 28, 2022 11:17 UTC   364d            etcd-ca                 no</span><br><span class="line">apiserver-kubelet-client   Jul 28, 2022 11:17 UTC   364d            ca                      no</span><br><span class="line">controller-manager.conf    Jul 28, 2022 11:17 UTC   364d                                    no</span><br><span class="line">etcd-healthcheck-client    Jul 28, 2022 11:17 UTC   364d            etcd-ca                 no</span><br><span class="line">etcd-peer                  Jul 28, 2022 11:17 UTC   364d            etcd-ca                 no</span><br><span class="line">etcd-server                Jul 28, 2022 11:17 UTC   364d            etcd-ca                 no</span><br><span class="line">front-proxy-client         Jul 28, 2022 11:17 UTC   364d            front-proxy-ca          no</span><br><span class="line">scheduler.conf             Jul 28, 2022 11:17 UTC   364d                                    no</span><br><span class="line"></span><br><span class="line">CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">ca                      Jul 26, 2031 11:17 UTC   9y              no</span><br><span class="line">etcd-ca                 Jul 26, 2031 11:17 UTC   9y              no</span><br><span class="line">front-proxy-ca          Jul 26, 2031 11:17 UTC   9y              no</span><br></pre></td></tr></table></figure>

<h3 id="클러스터-인증서-수동-갱신"><a href="#클러스터-인증서-수동-갱신" class="headerlink" title="클러스터 인증서 수동 갱신"></a>클러스터 인증서 수동 갱신</h3><p>쿠버네티스 클러스터에서 사용중인 인증서를 갱신하는 방법에는 쿠버네티스 클러스터 버전을 업그레이드하여 자동으로 갱신되게하거나 사용중인 인증서를 수동으로 갱신하는 명령어를 실행해야합니다. <strong>kubeadm certs renew all</strong> 명령어를 실행하면 쿠버네티스 클러스터에서 사용중인 인증서를 수동으로 갱신할 수 있습니다.</p>
<figure class="highlight sh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo kubeadm certs renew all</span><br><span class="line">[renew] Reading configuration from the cluster...</span><br><span class="line">[renew] FYI: You can look at this config file with <span class="string">&#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span></span><br><span class="line"></span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the admin to use and <span class="keyword">for</span> kubeadm itself renewed</span><br><span class="line">certificate <span class="keyword">for</span> serving the Kubernetes API renewed</span><br><span class="line">certificate the apiserver uses to access etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> the API server to connect to kubelet renewed</span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the controller manager to use renewed</span><br><span class="line">certificate <span class="keyword">for</span> liveness probes to healthcheck etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> etcd nodes to communicate with each other renewed</span><br><span class="line">certificate <span class="keyword">for</span> serving etcd renewed</span><br><span class="line">certificate <span class="keyword">for</span> the front proxy client renewed</span><br><span class="line">certificate embedded <span class="keyword">in</span> the kubeconfig file <span class="keyword">for</span> the scheduler manager to use renewed</span><br><span class="line"></span><br><span class="line">Done renewing certificates. You must restart the kube-apiserver, kube-controller-manager, kube-scheduler and etcd, so that they can use the new certificates.</span><br></pre></td></tr></table></figure>

<p>마지막에 출력된 정보에 따라 갱신된 인증서를 사용할 수 있도록 kube-apiserver, kube-controller-manager, kube-scheduler, etcd 파드를 다시 실행해야하므로 큐브컨트롤을 사용하여 파드 삭제 명령을 실행하면 쿠버네티스 클러스터는 파드를 제거한 뒤 다시 실행하게 됩니다. </p>
<figure class="highlight sh"><figcaption><span>인증서를 갱신한 파드를 삭제하여 재실행</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 삭제할 파드 조회</span></span><br><span class="line">kubectl get po -n kube-system</span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-558bd4d5db-6fqm2               1/1     Running   0          33m</span><br><span class="line">coredns-558bd4d5db-kgdfs               1/1     Running   0          33m</span><br><span class="line">etcd-mambo-master                      1/1     Running   0          33m</span><br><span class="line">kube-apiserver-mambo-master            1/1     Running   0          33m</span><br><span class="line">kube-controller-manager-mambo-master   1/1     Running   0          33m</span><br><span class="line">kube-flannel-ds-g59bl                  1/1     Running   0          23m</span><br><span class="line">kube-flannel-ds-nf4xt                  1/1     Running   0          23m</span><br><span class="line">kube-flannel-ds-q5hkb                  1/1     Running   0          32m</span><br><span class="line">kube-proxy-7j5b6                       1/1     Running   0          33m</span><br><span class="line">kube-proxy-8f47j                       1/1     Running   0          23m</span><br><span class="line">kube-proxy-rflgf                       1/1     Running   0          23m</span><br><span class="line">kube-scheduler-mambo-master            1/1     Running   0          33m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인증서가 갱신된 파드를 삭제</span></span><br><span class="line">kubectl delete po kube-apiserver-mambo-master kube-controller-manager-mambo-master kube-scheduler-mambo-master etcd-mambo-master -n kube-system</span><br><span class="line">pod <span class="string">&quot;kube-apiserver-mambo-master&quot;</span> deleted</span><br><span class="line">pod <span class="string">&quot;kube-controller-manager-mambo-master&quot;</span> deleted</span><br><span class="line">pod <span class="string">&quot;kube-scheduler-mambo-master&quot;</span> deleted</span><br><span class="line">pod <span class="string">&quot;etcd-mambo-master&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 삭제한 파드가 다시 실행되었는지 조회</span></span><br><span class="line">kubectl get po -n kube-system</span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-558bd4d5db-6fqm2               1/1     Running   0          38m</span><br><span class="line">coredns-558bd4d5db-kgdfs               1/1     Running   0          38m</span><br><span class="line">etcd-mambo-master                      1/1     Running   0          11s</span><br><span class="line">kube-apiserver-mambo-master            1/1     Running   0          11s</span><br><span class="line">kube-controller-manager-mambo-master   1/1     Running   0          11s</span><br><span class="line">kube-flannel-ds-g59bl                  1/1     Running   0          29m</span><br><span class="line">kube-flannel-ds-nf4xt                  1/1     Running   0          29m</span><br><span class="line">kube-flannel-ds-q5hkb                  1/1     Running   0          38m</span><br><span class="line">kube-proxy-7j5b6                       1/1     Running   0          38m</span><br><span class="line">kube-proxy-8f47j                       1/1     Running   0          29m</span><br><span class="line">kube-proxy-rflgf                       1/1     Running   0          29m</span><br><span class="line">kube-scheduler-mambo-master            1/1     Running   0          11s</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 클러스터에서 사용중인 인증서에 대한 만료일자를 다시 조회합니다.</p>
<figure class="highlight sh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo kubeadm certs check-expiration</span><br><span class="line">[check-expiration] Reading configuration from the cluster...</span><br><span class="line">[check-expiration] FYI: You can look at this config file with <span class="string">&#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span></span><br><span class="line"></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Jul 28, 2022 11:45 UTC   364d                                    no</span><br><span class="line">apiserver                  Jul 28, 2022 11:45 UTC   364d            ca                      no</span><br><span class="line">apiserver-etcd-client      Jul 28, 2022 11:45 UTC   364d            etcd-ca                 no</span><br><span class="line">apiserver-kubelet-client   Jul 28, 2022 11:45 UTC   364d            ca                      no</span><br><span class="line">controller-manager.conf    Jul 28, 2022 11:45 UTC   364d                                    no</span><br><span class="line">etcd-healthcheck-client    Jul 28, 2022 11:45 UTC   364d            etcd-ca                 no</span><br><span class="line">etcd-peer                  Jul 28, 2022 11:45 UTC   364d            etcd-ca                 no</span><br><span class="line">etcd-server                Jul 28, 2022 11:45 UTC   364d            etcd-ca                 no</span><br><span class="line">front-proxy-client         Jul 28, 2022 11:45 UTC   364d            front-proxy-ca          no</span><br><span class="line">scheduler.conf             Jul 28, 2022 11:45 UTC   364d                                    no</span><br><span class="line"></span><br><span class="line">CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">ca                      Jul 26, 2031 11:17 UTC   9y              no</span><br><span class="line">etcd-ca                 Jul 26, 2031 11:17 UTC   9y              no</span><br><span class="line">front-proxy-ca          Jul 26, 2031 11:17 UTC   9y              no</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 클러스터의 만료일자가 갱신되었음을 확인할 수 있습니다.</p>
<h2 id="쿠버네티스-대시보드-설치하기"><a href="#쿠버네티스-대시보드-설치하기" class="headerlink" title="쿠버네티스 대시보드 설치하기"></a>쿠버네티스 대시보드 설치하기</h2><p>쿠버네티스 대시보드 애드온은 쿠버네티스 클러스터를 웹 UI 기반으로 제어하고 클러스터에 대한 정보를 조회하고 모니터링할 수 있는 기능을 제공합니다. 쿠버네티스 대시보드를 클러스터에 추가하기 위하여 다음의 명령어를 실행합니다.</p>
<figure class="highlight sh"><figcaption><span>쿠버네티스 대시보드 애드온 설치</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br><span class="line">---</span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br><span class="line"></span><br><span class="line">kubectl get deploy -n kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">NAME                        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">dashboard-metrics-scraper   1/1     1            1           24s</span><br><span class="line">kubernetes-dashboard        1/1     1            1           24s</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 대시보드를 설치했지만 서비스를 조회해보면 다음과 같이 <strong>ClusterIP</strong> 유형인 것을 확인할 수 있습니다.</p>
<figure class="highlight sh"><figcaption><span>쿠버네티스 대시보드 서비스 조회</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl get svc -n kubernetes-dashboard</span><br><span class="line">NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">dashboard-metrics-scraper   ClusterIP   10.108.18.117   &lt;none&gt;        8000/TCP   74s</span><br><span class="line">kubernetes-dashboard        ClusterIP   10.100.36.145   &lt;none&gt;        443/TCP    74s</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 대시보드에 대한 서비스는 기본적으로 ClusterIP 유형으로 되어있으므로 쿠버네티스 클러스터 환경에서만 접근할 수 있습니다. 마스터 노드에서 큐브컨트롤로 쿠버네티스 클러스터에 프록시를 활성화하고나서 로컬 컴퓨터에서 마스터 노드에 대해서 SSH 터널링을 통해 쿠버네티스 대시보드에 접근할 수 있습니다.</p>
<figure class="highlight sh"><figcaption><span>쿠버네티스 클러스터 프록시 및 SSH 터널링</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl cluster-info</span><br><span class="line">Kubernetes control plane is running at https://192.168.0.5:6443</span><br><span class="line">CoreDNS is running at https://192.168.0.5:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">kubectl proxy</span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br><span class="line"><span class="comment"># http://127.0.0.1:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</span></span><br><span class="line"></span><br><span class="line">ssh -L 8001:localhost:8001 mambo@192.168.0.5</span><br></pre></td></tr></table></figure>

<p>이제 로컬 컴퓨터에서 <a href="http://127.0.0.1:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/%EB%A1%9C">http://127.0.0.1:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/로</a> 접속하면 쿠버네티스 대시보드 로그인 화면이 표시됩니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/access-kubernetes-dashboard-02.png"></p>
<p>하지만, 이렇게 SSH 터널링으로 쿠버네티스 대시보드로 접근하는 방식은 불편한점이 있기 때문에 쿠버네티스 대시보드를 외부에서 직접 접근할 수 있으면 좋겠습니다. 외부에서 접근하기 위해서는 쿠버네티스 대시보드를 외부로 노출할 수 있도록 쿠버네티스 대시보드 서비스의 유형을 ClusterIP 에서 <strong>NodePort</strong>로 변경해야합니다.</p>
<h3 id="쿠버네티스-대시보드-서비스-유형-변경하기"><a href="#쿠버네티스-대시보드-서비스-유형-변경하기" class="headerlink" title="쿠버네티스 대시보드 서비스 유형 변경하기"></a>쿠버네티스 대시보드 서비스 유형 변경하기</h3><figure class="highlight sh"><figcaption><span>쿠버네티스 대시보드 서비스 변경</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2021-07-30T10:47:00Z&quot;</span></span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">  resourceVersion: <span class="string">&quot;240375&quot;</span></span><br><span class="line">  uid: ae974cb2-d0af-46be-8036-4a9d33c9afbd</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: 10.100.36.145</span><br><span class="line">  clusterIPs:</span><br><span class="line">  - 10.100.36.145</span><br><span class="line">  ipFamilies:</span><br><span class="line">  - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  ports:</span><br><span class="line">  - port: 443</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get service kubernetes-dashboard -n kubernetes-dashboard -o jsonpath=&quot;&#123;.spec.ports[0].nodePort&#125;&quot; | awk &#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">kubectl get svc kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line">NAME                   TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kubernetes-dashboard   NodePort   10.100.36.145   &lt;none&gt;        443:31532/TCP   21m</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 대시보드가 31532 포트로 노출되었으니 <strong><a href="https://192.168.0.5:31532/">https://192.168.0.5:31532</a></strong>으로 접속합니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/access-kubernetes-dashboard-01.png"></p>
<p>쿠버네티스 클러스터에서 사용하는 루트 CA 인증서가 현재 브라우저에 신뢰할 수 있는 CA 인증서로 등록되어있지 않기 때문에 <strong>안전하지 않음으로 이동</strong>을 눌러 쿠버네티스 대시보드로 들어갑니다.</p>
<h3 id="쿠버네티스-대시보드-로그인하기"><a href="#쿠버네티스-대시보드-로그인하기" class="headerlink" title="쿠버네티스 대시보드 로그인하기"></a>쿠버네티스 대시보드 로그인하기</h3><p><img data-src="/images/posts/setup-kubernetes-cluster/access-kubernetes-dashboard-02.png"></p>
<p>쿠버네티스 대시보드 서비스 어카운트의 토큰으로 쿠버네티스 대시보드에 로그인할 수 있습니다. 큐브컨트롤로 다음의 명령어를 실행하여 쿠버네티스 대시보드 사용자의 토큰을 조회합니다.</p>
<figure class="highlight sh"><figcaption><span>쿠버네티스 대시보드 사용자 토큰 조회</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get secret -n kubernetes-dashboard $(kubectl get sa kubernetes-dashboard -n kubernetes-dashboard -o jsonpath=&quot;&#123;.secrets[0].name&#125;&quot;) -o jsonpath=&quot;&#123;.data.token&#125;&quot; | base64 --decode | awk &#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">kubectl describe secret $(kubectl get secret -n kubernetes-dashboard | grep kubernetes-dashboard-token | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>) -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">Name:         kubernetes-dashboard-token-4qs2r</span><br><span class="line">Namespace:    kubernetes-dashboard</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: kubernetes-dashboard</span><br><span class="line">              kubernetes.io/service-account.uid: 52ab8346-d0ce-465a-b170-1a240cbcbf83</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">namespace:  20 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6InhrcWdOeEV2RFh2ajZES0Z1b0lLb3F2TmtuSUVnLVdFbktadk9SWjNYXzQifQ....</span><br><span class="line">ca.crt:     1066 bytes</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 대시보드 사용자의 토큰을 복사해서 쿠버네티스 대시보드에 로그인합니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/access-kubernetes-dashboard-03.png"></p>
<p>토큰을 사용하여 로그인되었지만 이 서비스 어카운트는 쿠버네티스 클러스터에 대한 권한을 가지고 있지 않아서 어떠한 정보도 표시되지 않습니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/access-kubernetes-dashboard-04.png"></p>
<p>우리는 쿠버네티스 클러스터에 대한 권한을 쿠버네티스 대시보드 사용자에게 부여해야합니다.</p>
<figure class="highlight sh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl delete clusterrole kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line">kubectl delete clusterrolebinding kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | tee dashboard-admin.yaml</span></span><br><span class="line"><span class="string">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: ClusterRoleBinding</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: kubernetes-dashboard</span></span><br><span class="line"><span class="string">  namespace: kubernetes-dashboard</span></span><br><span class="line"><span class="string">roleRef:</span></span><br><span class="line"><span class="string">  apiGroup: rbac.authorization.k8s.io</span></span><br><span class="line"><span class="string">  kind: ClusterRole</span></span><br><span class="line"><span class="string">  name: cluster-admin</span></span><br><span class="line"><span class="string">subjects:</span></span><br><span class="line"><span class="string">  - kind: ServiceAccount</span></span><br><span class="line"><span class="string">    name: kubernetes-dashboard</span></span><br><span class="line"><span class="string">    namespace: kubernetes-dashboard</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">kubectl create -f dashboard-admin.yaml</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br></pre></td></tr></table></figure>

<p>쿠버네티스 대시보드 사용자에게 모든 권한을 부여하는 <strong>ClusterRole</strong>과 <strong>ClusterRoleBinding</strong>을 다시 만들었으니 쿠버네티스 대시보드에 다시 로그인해보겠습니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/access-kubernetes-dashboard-05.png"></p>
<p>쿠버네티스 대시보드의 서비스 어카운트가 클러스터 권한을 가지게 되었으므로 대시보드에 <strong>모든 네임스페이스</strong>에 대한 워크로드 상태를 조회할 수 있습니다.</p>
<h3 id="쿠버네티스-대시보드에서-매트릭-서버-설치하기"><a href="#쿠버네티스-대시보드에서-매트릭-서버-설치하기" class="headerlink" title="쿠버네티스 대시보드에서 매트릭 서버 설치하기"></a>쿠버네티스 대시보드에서 매트릭 서버 설치하기</h3><p>쿠버네티스 대시보드에서 클러스터 제어가 가능한지 검증하기 위해서 대시보드를 통해 클러스터에 매트릭 서버(metrics-server)를 설치해보도록 하겠습니다. </p>
<p><a href="https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml">https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</a></p>
<p>위 YAML 파일을 다운받아서 아래 화면과 같이 <strong>kubelet-insecure-tls</strong> 옵션을 추가하여 업로드 버튼을 선택합니다.</p>
<p><img data-src="/images/posts/setup-kubernetes-cluster/access-kubernetes-dashboard-06.png"></p>
<p>매트릭 서버가 설치되었으므로 큐브컨트롤으로 매트릭을 조회할 수 있는지 확인합니다.</p>
<figure class="highlight sh"><figcaption><span>Terminal</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl top no --use-protocol-buffers</span><br><span class="line"></span><br><span class="line">NAME              CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%</span><br><span class="line">mambo-master      136m         13%    1275Mi          67%</span><br><span class="line">mambo-worker-01   22m          2%     710Mi           37%</span><br><span class="line">mambo-worker-02   33m          3%     815Mi           43%</span><br></pre></td></tr></table></figure>

<p>이렇게 쿠버네티스 대시보드를 통해서도 클러스터를 제어할 수 있음을 확인했습니다. 그러나, 쿠버네티스 대시보드는 클러스터 외부에 노출되어있으므로 사용자의 토큰이 유출되지 않도록 잘 관리해야합니다. 저는 학습 목적으로 기본으로 제공하는 쿠버네티스 대시보드 사용자가 모든 권한을 가지게 하였지만 클러스터에 대한 모든 권한을 가지는게 아니라 쿠버네티스 대시보드에 로그인할 사용자를 별도로 만들어서 특정 네임스페이스와 리소스에 대한 권한을 개별적으로 지정하는게 좋습니다.</p>
<p>이상으로 쿠버네티스 클러스터에 대한 학습을 마칩니다.</p>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
</search>
